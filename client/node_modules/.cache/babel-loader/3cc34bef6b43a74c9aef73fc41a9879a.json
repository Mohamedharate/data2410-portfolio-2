{"ast":null,"code":"'use strict';\n\nconst deprecate = require('util').deprecate;\n\nconst deprecateOptions = require('./utils').deprecateOptions;\n\nconst emitWarningOnce = require('./utils').emitWarningOnce;\n\nconst checkCollectionName = require('./utils').checkCollectionName;\n\nconst ObjectID = require('./core').BSON.ObjectID;\n\nconst MongoError = require('./core').MongoError;\n\nconst normalizeHintField = require('./utils').normalizeHintField;\n\nconst decorateCommand = require('./utils').decorateCommand;\n\nconst decorateWithCollation = require('./utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('./utils').decorateWithReadConcern;\n\nconst formattedOrderClause = require('./utils').formattedOrderClause;\n\nconst ReadPreference = require('./core').ReadPreference;\n\nconst unordered = require('./bulk/unordered');\n\nconst ordered = require('./bulk/ordered');\n\nconst ChangeStream = require('./change_stream');\n\nconst executeLegacyOperation = require('./utils').executeLegacyOperation;\n\nconst WriteConcern = require('./write_concern');\n\nconst ReadConcern = require('./read_concern');\n\nconst MongoDBNamespace = require('./utils').MongoDBNamespace;\n\nconst AggregationCursor = require('./aggregation_cursor');\n\nconst CommandCursor = require('./command_cursor'); // Operations\n\n\nconst ensureIndex = require('./operations/collection_ops').ensureIndex;\n\nconst group = require('./operations/collection_ops').group;\n\nconst parallelCollectionScan = require('./operations/collection_ops').parallelCollectionScan;\n\nconst removeDocuments = require('./operations/common_functions').removeDocuments;\n\nconst save = require('./operations/collection_ops').save;\n\nconst updateDocuments = require('./operations/common_functions').updateDocuments;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst BulkWriteOperation = require('./operations/bulk_write');\n\nconst CountDocumentsOperation = require('./operations/count_documents');\n\nconst CreateIndexesOperation = require('./operations/create_indexes');\n\nconst DeleteManyOperation = require('./operations/delete_many');\n\nconst DeleteOneOperation = require('./operations/delete_one');\n\nconst DistinctOperation = require('./operations/distinct');\n\nconst DropCollectionOperation = require('./operations/drop').DropCollectionOperation;\n\nconst DropIndexOperation = require('./operations/drop_index');\n\nconst DropIndexesOperation = require('./operations/drop_indexes');\n\nconst EstimatedDocumentCountOperation = require('./operations/estimated_document_count');\n\nconst FindOperation = require('./operations/find');\n\nconst FindOneOperation = require('./operations/find_one');\n\nconst FindAndModifyOperation = require('./operations/find_and_modify');\n\nconst FindOneAndDeleteOperation = require('./operations/find_one_and_delete');\n\nconst FindOneAndReplaceOperation = require('./operations/find_one_and_replace');\n\nconst FindOneAndUpdateOperation = require('./operations/find_one_and_update');\n\nconst GeoHaystackSearchOperation = require('./operations/geo_haystack_search');\n\nconst IndexesOperation = require('./operations/indexes');\n\nconst IndexExistsOperation = require('./operations/index_exists');\n\nconst IndexInformationOperation = require('./operations/index_information');\n\nconst InsertManyOperation = require('./operations/insert_many');\n\nconst InsertOneOperation = require('./operations/insert_one');\n\nconst IsCappedOperation = require('./operations/is_capped');\n\nconst ListIndexesOperation = require('./operations/list_indexes');\n\nconst MapReduceOperation = require('./operations/map_reduce');\n\nconst OptionsOperation = require('./operations/options_operation');\n\nconst RenameOperation = require('./operations/rename');\n\nconst ReIndexOperation = require('./operations/re_index');\n\nconst ReplaceOneOperation = require('./operations/replace_one');\n\nconst StatsOperation = require('./operations/stats');\n\nconst UpdateManyOperation = require('./operations/update_many');\n\nconst UpdateOneOperation = require('./operations/update_one');\n\nconst executeOperation = require('./operations/execute_operation');\n/**\n * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     test.equal(null, err);\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n */\n\n\nconst mergeKeys = ['ignoreUndefined'];\n/**\n * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n */\n\nfunction Collection(db, topology, dbName, name, pkFactory, options) {\n  checkCollectionName(name); // Unpack variables\n\n  const internalHint = null;\n  const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;\n  const serializeFunctions = options == null || options.serializeFunctions == null ? db.s.options.serializeFunctions : options.serializeFunctions;\n  const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;\n  const promoteLongs = options == null || options.promoteLongs == null ? db.s.options.promoteLongs : options.promoteLongs;\n  const promoteValues = options == null || options.promoteValues == null ? db.s.options.promoteValues : options.promoteValues;\n  const promoteBuffers = options == null || options.promoteBuffers == null ? db.s.options.promoteBuffers : options.promoteBuffers;\n  const collectionHint = null;\n  const namespace = new MongoDBNamespace(dbName, name); // Get the promiseLibrary\n\n  const promiseLibrary = options.promiseLibrary || Promise; // Set custom primary key factory if provided\n\n  pkFactory = pkFactory == null ? ObjectID : pkFactory; // Internal state\n\n  this.s = {\n    // Set custom primary key factory if provided\n    pkFactory: pkFactory,\n    // Db\n    db: db,\n    // Topology\n    topology: topology,\n    // Options\n    options: options,\n    // Namespace\n    namespace: namespace,\n    // Read preference\n    readPreference: ReadPreference.fromOptions(options),\n    // SlaveOK\n    slaveOk: slaveOk,\n    // Serialize functions\n    serializeFunctions: serializeFunctions,\n    // Raw\n    raw: raw,\n    // promoteLongs\n    promoteLongs: promoteLongs,\n    // promoteValues\n    promoteValues: promoteValues,\n    // promoteBuffers\n    promoteBuffers: promoteBuffers,\n    // internalHint\n    internalHint: internalHint,\n    // collectionHint\n    collectionHint: collectionHint,\n    // Promise library\n    promiseLibrary: promiseLibrary,\n    // Read Concern\n    readConcern: ReadConcern.fromOptions(options),\n    // Write Concern\n    writeConcern: WriteConcern.fromOptions(options)\n  };\n}\n/**\n * The name of the database this collection belongs to\n * @member {string} dbName\n * @memberof Collection#\n * @readonly\n */\n\n\nObject.defineProperty(Collection.prototype, 'dbName', {\n  enumerable: true,\n  get: function () {\n    return this.s.namespace.db;\n  }\n});\n/**\n * The name of this collection\n * @member {string} collectionName\n * @memberof Collection#\n * @readonly\n */\n\nObject.defineProperty(Collection.prototype, 'collectionName', {\n  enumerable: true,\n  get: function () {\n    return this.s.namespace.collection;\n  }\n});\n/**\n * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n * @member {string} namespace\n * @memberof Collection#\n * @readonly\n */\n\nObject.defineProperty(Collection.prototype, 'namespace', {\n  enumerable: true,\n  get: function () {\n    return this.s.namespace.toString();\n  }\n});\n/**\n * The current readConcern of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {ReadConcern} [readConcern]\n * @memberof Collection#\n * @readonly\n */\n\nObject.defineProperty(Collection.prototype, 'readConcern', {\n  enumerable: true,\n  get: function () {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n\n    return this.s.readConcern;\n  }\n});\n/**\n * The current readPreference of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {ReadPreference} [readPreference]\n * @memberof Collection#\n * @readonly\n */\n\nObject.defineProperty(Collection.prototype, 'readPreference', {\n  enumerable: true,\n  get: function () {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n});\n/**\n * The current writeConcern of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {WriteConcern} [writeConcern]\n * @memberof Collection#\n * @readonly\n */\n\nObject.defineProperty(Collection.prototype, 'writeConcern', {\n  enumerable: true,\n  get: function () {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n\n    return this.s.writeConcern;\n  }\n});\n/**\n * The current index hint for the collection\n * @member {object} [hint]\n * @memberof Collection#\n */\n\nObject.defineProperty(Collection.prototype, 'hint', {\n  enumerable: true,\n  get: function () {\n    return this.s.collectionHint;\n  },\n  set: function (v) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n});\nconst DEPRECATED_FIND_OPTIONS = ['maxScan', 'fields', 'snapshot', 'oplogReplay'];\n/**\n * Creates a cursor for a query that can be used to iterate over results from MongoDB\n * @method\n * @param {object} [query={}] The cursor query object.\n * @param {object} [options] Optional settings.\n * @param {number} [options.limit=0] Sets the limit of documents returned in the query.\n * @param {(array|object)} [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n * @param {object} [options.projection] The fields to return in the query. Object of fields to either include or exclude (one of, not both), {'a':1, 'b': 1} **or** {'a': 0, 'b': 0}\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).\n * @param {Object} [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n * @param {boolean} [options.snapshot=false] DEPRECATED: Snapshot query.\n * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.\n * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.\n * @param {boolean} [options.awaitData=false] Specify if the cursor is a a tailable-await cursor. Requires `tailable` to be true\n * @param {number} [options.batchSize=1000] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {boolean} [options.returnKey=false] Only return the index key.\n * @param {number} [options.maxScan] DEPRECATED: Limit the number of items to scan.\n * @param {number} [options.min] Set index bounds.\n * @param {number} [options.max] Set index bounds.\n * @param {boolean} [options.showDiskLoc=false] Show disk location of results.\n * @param {string} [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @param {boolean} [options.noCursorTimeout] The server normally times out idle cursors after an inactivity period (10 minutes) to prevent excess memory use. Set this option to prevent that.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {boolean} [options.allowDiskUse] Enables writing to temporary files on the server.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @throws {MongoError}\n * @return {Cursor}\n */\n\nCollection.prototype.find = deprecateOptions({\n  name: 'collection.find',\n  deprecatedOptions: DEPRECATED_FIND_OPTIONS,\n  optionsIndex: 1\n}, function (query, options, callback) {\n  if (typeof callback === 'object') {\n    // TODO(MAJOR): throw in the future\n    emitWarningOnce('Third parameter to `find()` must be a callback or undefined');\n  }\n\n  let selector = query; // figuring out arguments\n\n  if (typeof callback !== 'function') {\n    if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options == null) {\n      callback = typeof selector === 'function' ? selector : undefined;\n      selector = typeof selector === 'object' ? selector : undefined;\n    }\n  } // Ensure selector is not null\n\n\n  selector = selector == null ? {} : selector; // Validate correctness off the selector\n\n  const object = selector;\n\n  if (Buffer.isBuffer(object)) {\n    const object_size = object[0] | object[1] << 8 | object[2] << 16 | object[3] << 24;\n\n    if (object_size !== object.length) {\n      const error = new Error('query selector raw message size does not match message header size [' + object.length + '] != [' + object_size + ']');\n      error.name = 'MongoError';\n      throw error;\n    }\n  } // Check special case where we are using an objectId\n\n\n  if (selector != null && selector._bsontype === 'ObjectID') {\n    selector = {\n      _id: selector\n    };\n  }\n\n  if (!options) options = {};\n  let projection = options.projection || options.fields;\n\n  if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {\n    projection = projection.length ? projection.reduce((result, field) => {\n      result[field] = 1;\n      return result;\n    }, {}) : {\n      _id: 1\n    };\n  } // Make a shallow copy of options\n\n\n  let newOptions = Object.assign({}, options); // Make a shallow copy of the collection options\n\n  for (let key in this.s.options) {\n    if (mergeKeys.indexOf(key) !== -1) {\n      newOptions[key] = this.s.options[key];\n    }\n  } // Unpack options\n\n\n  newOptions.skip = options.skip ? options.skip : 0;\n  newOptions.limit = options.limit ? options.limit : 0;\n  newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;\n  newOptions.hint = options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;\n  newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout; // // If we have overridden slaveOk otherwise use the default db setting\n\n  newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk; // Add read preference if needed\n\n  newOptions.readPreference = ReadPreference.resolve(this, newOptions); // Set slave ok to true if read preference different from primary\n\n  if (newOptions.readPreference != null && (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')) {\n    newOptions.slaveOk = true;\n  } // Ensure the query is an object\n\n\n  if (selector != null && typeof selector !== 'object') {\n    throw MongoError.create({\n      message: 'query selector must be an object',\n      driver: true\n    });\n  } // Build the find command\n\n\n  const findCommand = {\n    find: this.s.namespace.toString(),\n    limit: newOptions.limit,\n    skip: newOptions.skip,\n    query: selector\n  };\n\n  if (typeof options.allowDiskUse === 'boolean') {\n    findCommand.allowDiskUse = options.allowDiskUse;\n  } // Ensure we use the right await data option\n\n\n  if (typeof newOptions.awaitdata === 'boolean') {\n    newOptions.awaitData = newOptions.awaitdata;\n  } // Translate to new command option noCursorTimeout\n\n\n  if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = !newOptions.timeout;\n  decorateCommand(findCommand, newOptions, ['session', 'collation']);\n  if (projection) findCommand.fields = projection; // Add db object to the new options\n\n  newOptions.db = this.s.db; // Add the promise library\n\n  newOptions.promiseLibrary = this.s.promiseLibrary; // Set raw if available at collection level\n\n  if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw; // Set promoteLongs if available at collection level\n\n  if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean') newOptions.promoteLongs = this.s.promoteLongs;\n  if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean') newOptions.promoteValues = this.s.promoteValues;\n  if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean') newOptions.promoteBuffers = this.s.promoteBuffers; // Sort options\n\n  if (findCommand.sort) {\n    findCommand.sort = formattedOrderClause(findCommand.sort);\n  } // Set the readConcern\n\n\n  decorateWithReadConcern(findCommand, this, options); // Decorate find command with collation options\n\n  try {\n    decorateWithCollation(findCommand, this, options);\n  } catch (err) {\n    if (typeof callback === 'function') return callback(err, null);\n    throw err;\n  }\n\n  const cursor = this.s.topology.cursor(new FindOperation(this, this.s.namespace, findCommand, newOptions), newOptions); // TODO: remove this when NODE-2074 is resolved\n\n  if (typeof callback === 'function') {\n    callback(null, cursor);\n    return;\n  }\n\n  return cursor;\n});\n/**\n * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object} doc Document to insert.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=true] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.insertOne = function (doc, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const insertOneOperation = new InsertOneOperation(this, doc, options);\n  return executeOperation(this.s.topology, insertOneOperation, callback);\n};\n/**\n * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} docs Documents to insert.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=true] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.insertMany = function (docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options ? Object.assign({}, options) : {\n    ordered: true\n  };\n  const insertManyOperation = new InsertManyOperation(this, docs, options);\n  return executeOperation(this.s.topology, insertManyOperation, callback);\n};\n/**\n * @typedef {Object} Collection~BulkWriteOpResult\n * @property {number} insertedCount Number of documents inserted.\n * @property {number} matchedCount Number of documents matched for update.\n * @property {number} modifiedCount Number of documents modified.\n * @property {number} deletedCount Number of documents deleted.\n * @property {number} upsertedCount Number of documents upserted.\n * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation\n * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~bulkWriteOpCallback\n * @param {BulkWriteError} error An error instance representing the error during the execution.\n * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Perform a bulkWrite operation without a fluent API\n *\n * Legal operation types are\n *\n *  { insertOne: { document: { a: 1 } } }\n *\n *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { updateMany: { filter: {}, update: {$set: {\"a.$[i].x\": 5}}, arrayFilters: [{ \"i.x\": 5 }]} }\n *\n *  { deleteOne: { filter: {c:1} } }\n *\n *  { deleteMany: { filter: {c:1} } }\n *\n *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}\n *\n * If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} operations Bulk operations to perform.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object[]} [options.arrayFilters] Determines which array elements to modify for update operation in MongoDB 3.6 or higher.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~bulkWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.bulkWrite = function (operations, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {\n    ordered: true\n  };\n\n  if (!Array.isArray(operations)) {\n    throw MongoError.create({\n      message: 'operations must be an array of documents',\n      driver: true\n    });\n  }\n\n  const bulkWriteOperation = new BulkWriteOperation(this, operations, options);\n  return executeOperation(this.s.topology, bulkWriteOperation, callback);\n};\n/**\n * @typedef {Object} Collection~WriteOpResult\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~writeOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * @typedef {Object} Collection~insertWriteOpResult\n * @property {number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {Object.<Number, ObjectId>} insertedIds Map of the index of the inserted document to the id of the inserted document.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {number} result.ok Is 1 if the command executed correctly.\n * @property {number} result.n The total count of documents inserted.\n */\n\n/**\n * @typedef {Object} Collection~insertOneWriteOpResult\n * @property {number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {ObjectId} insertedId The driver generated ObjectId for the insert operation.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {number} result.ok Is 1 if the command executed correctly.\n * @property {number} result.n The total count of documents inserted.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertOneWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertOneWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {(object|object[])} docs Documents to insert.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated Use insertOne, insertMany or bulkWrite\n */\n\n\nCollection.prototype.insert = deprecate(function (docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {\n    ordered: false\n  };\n  docs = !Array.isArray(docs) ? [docs] : docs;\n\n  if (options.keepGoing === true) {\n    options.ordered = false;\n  }\n\n  return this.insertMany(docs, options, callback);\n}, 'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n/**\n * @typedef {Object} Collection~updateWriteOpResult\n * @property {Object} result The raw result returned from MongoDB. Will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents scanned.\n * @property {Number} result.nModified The total count of documents modified.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} matchedCount The number of documents that matched the filter.\n * @property {Number} modifiedCount The number of documents that were modified.\n * @property {Number} upsertedCount The number of documents upserted.\n * @property {Object} upsertedId The upserted id.\n * @property {ObjectId} upsertedId._id The upserted _id returned from the server.\n * @property {Object} message The raw msg response wrapped in an internal class\n * @property {object[]} [ops] In a response to {@link Collection#replaceOne replaceOne}, contains the new value of the document on the server. This is the same document that was originally passed in, and is only here for legacy purposes.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~updateWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~updateWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Update a single document in a collection\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query..\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.updateOne = function (filter, update, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new UpdateOneOperation(this, filter, update, options), callback);\n};\n/**\n * Replace a document in a collection with another document\n * @method\n * @param {object} filter The Filter used to select the document to replace\n * @param {object} doc The Document that replaces the matching document\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise<Collection~updateWriteOpResult>} returns Promise if no callback passed\n */\n\n\nCollection.prototype.replaceOne = function (filter, doc, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new ReplaceOneOperation(this, filter, doc, options), callback);\n};\n/**\n * Update multiple documents in a collection\n * @method\n * @param {object} filter The Filter used to select the documents to update\n * @param {object} update The update operations to be applied to the documents\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query..\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise<Collection~updateWriteOpResult>} returns Promise if no callback passed\n */\n\n\nCollection.prototype.updateMany = function (filter, update, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new UpdateManyOperation(this, filter, update, options), callback);\n};\n/**\n * Updates documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} update The update operations to be applied to the documents\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {boolean} [options.multi=false] Update one/all documents with operation.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use updateOne, updateMany or bulkWrite\n */\n\n\nCollection.prototype.update = deprecate(function (selector, update, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, updateDocuments, [this, selector, update, options, callback]);\n}, 'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n/**\n * @typedef {Object} Collection~deleteWriteOpResult\n * @property {Object} result The raw result returned from MongoDB. Will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents deleted.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} deletedCount The number of documents deleted.\n */\n\n/**\n * The callback format for deletes\n * @callback Collection~deleteWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~deleteWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Delete a document from a collection\n * @method\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {string|object} [options.hint] optional index hint for optimizing the filter query\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.deleteOne = function (filter, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const deleteOneOperation = new DeleteOneOperation(this, filter, options);\n  return executeOperation(this.s.topology, deleteOneOperation, callback);\n};\n\nCollection.prototype.removeOne = Collection.prototype.deleteOne;\n/**\n * Delete multiple documents from a collection\n * @method\n * @param {object} filter The Filter used to select the documents to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {string|object} [options.hint] optional index hint for optimizing the filter query\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.deleteMany = function (filter, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options); // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const deleteManyOperation = new DeleteManyOperation(this, filter, options);\n  return executeOperation(this.s.topology, deleteManyOperation, callback);\n};\n\nCollection.prototype.removeMany = Collection.prototype.deleteMany;\n/**\n * Remove documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.single=false] Removes the first document found.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use deleteOne, deleteMany or bulkWrite\n */\n\nCollection.prototype.remove = deprecate(function (selector, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, removeDocuments, [this, selector, options, callback]);\n}, 'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n/**\n * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic\n * operators and update instead for more efficient operations.\n * @method\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\n\nCollection.prototype.save = deprecate(function (doc, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);\n}, 'collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.');\n/**\n * The callback format for results\n * @callback Collection~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object} result The result object if the command was executed successfully.\n */\n\n/**\n * The callback format for an aggregation call\n * @callback Collection~aggregationCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {AggregationCursor} cursor The cursor if the aggregation command was executed successfully.\n */\n\n/**\n * Fetches the first document that matches the query\n * @method\n * @param {object} query Query for find Operation\n * @param {object} [options] Optional settings.\n * @param {number} [options.limit=0] Sets the limit of documents returned in the query.\n * @param {(array|object)} [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n * @param {object} [options.projection] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).\n * @param {Object} [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n * @param {boolean} [options.snapshot=false] DEPRECATED: Snapshot query.\n * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.\n * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.\n * @param {number} [options.batchSize=1] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {boolean} [options.returnKey=false] Only return the index key.\n * @param {number} [options.maxScan] DEPRECATED: Limit the number of items to scan.\n * @param {number} [options.min] Set index bounds.\n * @param {number} [options.max] Set index bounds.\n * @param {boolean} [options.showDiskLoc=false] Show disk location of results.\n * @param {string} [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.findOne = deprecateOptions({\n  name: 'collection.find',\n  deprecatedOptions: DEPRECATED_FIND_OPTIONS,\n  optionsIndex: 1\n}, function (query, options, callback) {\n  if (typeof callback === 'object') {\n    // TODO(MAJOR): throw in the future\n    emitWarningOnce('Third parameter to `findOne()` must be a callback or undefined');\n  }\n\n  if (typeof query === 'function') callback = query, query = {}, options = {};\n  if (typeof options === 'function') callback = options, options = {};\n  query = query || {};\n  options = options || {};\n  const findOneOperation = new FindOneOperation(this, query, options);\n  return executeOperation(this.s.topology, findOneOperation, callback);\n});\n/**\n * The callback format for the collection method, must be used if strict is specified\n * @callback Collection~collectionResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection} collection The collection instance.\n */\n\n/**\n * Rename the collection.\n *\n * @method\n * @param {string} newName New name of of the collection.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~collectionResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.rename = function (newName, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = Object.assign({}, options, {\n    readPreference: ReadPreference.PRIMARY\n  });\n  const renameOperation = new RenameOperation(this, newName, options);\n  return executeOperation(this.s.topology, renameOperation, callback);\n};\n/**\n * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.drop = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const dropCollectionOperation = new DropCollectionOperation(this.s.db, this.collectionName, options);\n  return executeOperation(this.s.topology, dropCollectionOperation, callback);\n};\n/**\n * Returns the options of the collection.\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.options = function (opts, callback) {\n  if (typeof opts === 'function') callback = opts, opts = {};\n  opts = opts || {};\n  const optionsOperation = new OptionsOperation(this, opts);\n  return executeOperation(this.s.topology, optionsOperation, callback);\n};\n/**\n * Returns if the collection is a capped collection\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.isCapped = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const isCappedOperation = new IsCappedOperation(this, options);\n  return executeOperation(this.s.topology, isCappedOperation, callback);\n};\n/**\n * Creates an index on the db and collection collection.\n * @method\n * @param {(string|array|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {string} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.partialFilterExpression] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {(number|string)} [options.commitQuorum] (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @example\n * const collection = client.db('foo').collection('bar');\n *\n * await collection.createIndex({ a: 1, b: -1 });\n *\n * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n * await collection.createIndex([ [c, 1], [d, -1] ]);\n *\n * // Equivalent to { e: 1 }\n * await collection.createIndex('e');\n *\n * // Equivalent to { f: 1, g: 1 }\n * await collection.createIndex(['f', 'g'])\n *\n * // Equivalent to { h: 1, i: -1 }\n * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n *\n * // Equivalent to { j: 1, k: -1, l: 2d }\n * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n */\n\n\nCollection.prototype.createIndex = function (fieldOrSpec, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, fieldOrSpec, options);\n  return executeOperation(this.s.topology, createIndexesOperation, callback);\n};\n/**\n * @typedef {object} Collection~IndexDefinition\n * @description A definition for an index. Used by the createIndex command.\n * @see https://docs.mongodb.com/manual/reference/command/createIndexes/\n */\n\n/**\n * Creates multiple indexes in the collection, this method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error.\n *\n * **Note**: Unlike {@link Collection#createIndex createIndex}, this function takes in raw index specifications.\n * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/ here}.\n *\n * @method\n * @param {Collection~IndexDefinition[]} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {(number|string)} [options.commitQuorum] (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @example\n * const collection = client.db('foo').collection('bar');\n * await collection.createIndexes([\n *   // Simple index on field fizz\n *   {\n *     key: { fizz: 1 },\n *   }\n *   // wildcard index\n *   {\n *     key: { '$**': 1 }\n *   },\n *   // named index on darmok and jalad\n *   {\n *     key: { darmok: 1, jalad: -1 }\n *     name: 'tanagra'\n *   }\n * ]);\n */\n\n\nCollection.prototype.createIndexes = function (indexSpecs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options ? Object.assign({}, options) : {};\n  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n  const createIndexesOperation = new CreateIndexesOperation(this, this.collectionName, indexSpecs, options);\n  return executeOperation(this.s.topology, createIndexesOperation, callback);\n};\n/**\n * Drops an index from this collection.\n * @method\n * @param {string} indexName Name of the index to drop.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.dropIndex = function (indexName, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {}; // Run only against primary\n\n  options.readPreference = ReadPreference.PRIMARY;\n  const dropIndexOperation = new DropIndexOperation(this, indexName, options);\n  return executeOperation(this.s.topology, dropIndexOperation, callback);\n};\n/**\n * Drops all indexes from this collection.\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.dropIndexes = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options ? Object.assign({}, options) : {};\n  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n  const dropIndexesOperation = new DropIndexesOperation(this, options);\n  return executeOperation(this.s.topology, dropIndexesOperation, callback);\n};\n/**\n * Drops all indexes from this collection.\n * @method\n * @deprecated use dropIndexes\n * @param {Collection~resultCallback} callback The command result callback\n * @return {Promise} returns Promise if no [callback] passed\n */\n\n\nCollection.prototype.dropAllIndexes = deprecate(Collection.prototype.dropIndexes, 'collection.dropAllIndexes is deprecated. Use dropIndexes instead.');\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n * @method\n * @deprecated use db.command instead\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.reIndex = deprecate(function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const reIndexOperation = new ReIndexOperation(this, options);\n  return executeOperation(this.s.topology, reIndexOperation, callback);\n}, 'collection.reIndex is deprecated. Use db.command instead.');\n/**\n * Get the list of all indexes information for the collection.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.batchSize=1000] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {CommandCursor}\n */\n\nCollection.prototype.listIndexes = function (options) {\n  const cursor = new CommandCursor(this.s.topology, new ListIndexesOperation(this, options), options);\n  return cursor;\n};\n/**\n * Ensures that an index exists, if it does not it creates it\n * @method\n * @deprecated use createIndexes instead\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {number} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.ensureIndex = deprecate(function (fieldOrSpec, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.s.topology, ensureIndex, [this, fieldOrSpec, options, callback]);\n}, 'collection.ensureIndex is deprecated. Use createIndexes instead.');\n/**\n * Checks if one or more indexes exist on the collection, fails on first non-existing index\n * @method\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.indexExists = function (indexes, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const indexExistsOperation = new IndexExistsOperation(this, indexes, options);\n  return executeOperation(this.s.topology, indexExistsOperation, callback);\n};\n/**\n * Retrieves this collections index info.\n * @method\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.full=false] Returns the full raw index information.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.indexInformation = function (options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n  const indexInformationOperation = new IndexInformationOperation(this.s.db, this.collectionName, options);\n  return executeOperation(this.s.topology, indexInformationOperation, callback);\n};\n/**\n * The callback format for results\n * @callback Collection~countCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {number} result The count of documents that matched the query.\n */\n\n/**\n * An estimated count of matching documents in the db to a query.\n *\n * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments countDocuments}.\n * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount estimatedDocumentCount}.\n *\n * @method\n * @param {object} [query={}] The query for the count.\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {boolean} [options.limit] The limit of documents to count.\n * @param {boolean} [options.skip] The number of documents to skip for the count.\n * @param {string} [options.hint] An index name hint for the query.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~countCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use {@link Collection#countDocuments countDocuments} or {@link Collection#estimatedDocumentCount estimatedDocumentCount} instead\n */\n\n\nCollection.prototype.count = deprecate(function (query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  query = args.length ? args.shift() || {} : {};\n  options = args.length ? args.shift() || {} : {};\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeOperation(this.s.topology, new EstimatedDocumentCountOperation(this, query, options), callback);\n}, 'collection.count is deprecated, and will be removed in a future version.' + ' Use Collection.countDocuments or Collection.estimatedDocumentCount instead');\n/**\n * Gets an estimate of the count of documents in a collection using collection metadata.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.\n * @param {Collection~countCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed.\n */\n\nCollection.prototype.estimatedDocumentCount = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);\n  return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);\n};\n/**\n * Gets the number of documents matching the filter.\n * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount estimatedDocumentCount}.\n * **Note**: When migrating from {@link Collection#count count} to {@link Collection#countDocuments countDocuments}\n * the following query operators must be replaced:\n *\n * | Operator | Replacement |\n * | -------- | ----------- |\n * | `$where`   | [`$expr`][1] |\n * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n *\n * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n *\n * @param {object} [query] the query for the count\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specifies a collation.\n * @param {string|object} [options.hint] The index to use.\n * @param {number} [options.limit] The maximum number of document to count.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.\n * @param {number} [options.skip] The number of documents to skip before counting.\n * @param {Collection~countCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed.\n * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n */\n\n\nCollection.prototype.countDocuments = function (query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  query = args.length ? args.shift() || {} : {};\n  options = args.length ? args.shift() || {} : {};\n  const countDocumentsOperation = new CountDocumentsOperation(this, query, options);\n  return executeOperation(this.s.topology, countDocumentsOperation, callback);\n};\n/**\n * The distinct command returns a list of distinct values for the given key across a collection.\n * @method\n * @param {string} key Field of the document to find distinct values for.\n * @param {object} [query] The query for filtering the set of documents to which we apply the distinct filter.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.distinct = function (key, query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  const queryOption = args.length ? args.shift() || {} : {};\n  const optionsOption = args.length ? args.shift() || {} : {};\n  const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);\n  return executeOperation(this.s.topology, distinctOperation, callback);\n};\n/**\n * Retrieve all the indexes on the collection.\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.indexes = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  const indexesOperation = new IndexesOperation(this, options);\n  return executeOperation(this.s.topology, indexesOperation, callback);\n};\n/**\n * Get all the collection statistics.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.scale] Divide the returned sizes by scale value.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.stats = function (options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n  const statsOperation = new StatsOperation(this, options);\n  return executeOperation(this.s.topology, statsOperation, callback);\n};\n/**\n * @typedef {Object} Collection~findAndModifyWriteOpResult\n * @property {object} value Document returned from the `findAndModify` command. If no documents were found, `value` will be `null` by default (`returnOriginal: true`), even if a document was upserted; if `returnOriginal` was false, the upserted document will be returned in that case.\n * @property {object} lastErrorObject The raw lastErrorObject returned from the command. See {@link https://docs.mongodb.com/manual/reference/command/findAndModify/index.html#lasterrorobject|findAndModify command documentation}.\n * @property {Number} ok Is 1 if the command executed correctly.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~findAndModifyCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\n\n\nCollection.prototype.findOneAndDelete = function (filter, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new FindOneAndDeleteOperation(this, filter, options), callback);\n};\n/**\n * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to replace\n * @param {object} replacement The Document that replaces the matching document\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {string|object} [options.hint] An optional index to use for this operation\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\n\n\nCollection.prototype.findOneAndReplace = function (filter, replacement, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new FindOneAndReplaceOperation(this, filter, replacement, options), callback);\n};\n/**\n * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update Update operations to be performed on the document\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {string|object} [options.hint] An optional index to use for this operation\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] An ptional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\n\n\nCollection.prototype.findOneAndUpdate = function (filter, update, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Add ignoreUndefined\n\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(this.s.topology, new FindOneAndUpdateOperation(this, filter, update, options), callback);\n};\n/**\n * Find and update a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.remove=false] Set to true to remove the object before returning.\n * @param {boolean} [options.upsert=false] Perform an upsert operation.\n * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.\n * @param {object} [options.projection] Object containing the field projection for the result returned from the operation.\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\n\nCollection.prototype.findAndModify = deprecate(_findAndModify, 'collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.');\n/**\n * @ignore\n */\n\nCollection.prototype._findAndModify = _findAndModify;\n\nfunction _findAndModify(query, sort, doc, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  sort = args.length ? args.shift() || [] : [];\n  doc = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {}; // Clone options\n\n  options = Object.assign({}, options); // Force read preference primary\n\n  options.readPreference = ReadPreference.PRIMARY;\n  return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, doc, options), callback);\n}\n/**\n * Find and remove a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndDelete instead\n */\n\n\nCollection.prototype.findAndRemove = deprecate(function (query, sort, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  sort = args.length ? args.shift() || [] : [];\n  options = args.length ? args.shift() || {} : {}; // Add the remove option\n\n  options.remove = true;\n  return executeOperation(this.s.topology, new FindAndModifyOperation(this, query, sort, null, options), callback);\n}, 'collection.findAndRemove is deprecated. Use findOneAndDelete instead.');\n/**\n * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2\n * @method\n * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.\n * @param {number} [options.cursor.batchSize=1000] Deprecated. Use `options.batchSize`\n * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).\n * @param {number} [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {string} [options.comment] Add a comment to an aggregation command\n * @param {string|object} [options.hint] Add an index selection hint to an aggregation command\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~aggregationCallback} callback The command result callback\n * @return {(null|AggregationCursor)}\n */\n\nCollection.prototype.aggregate = function (pipeline, options, callback) {\n  if (Array.isArray(pipeline)) {\n    // Set up callback if one is provided\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // If we have no options or callback we are doing\n    // a cursor based aggregation\n\n\n    if (options == null && callback == null) {\n      options = {};\n    }\n  } else {\n    // Aggregation pipeline passed as arguments on the method\n    const args = Array.prototype.slice.call(arguments, 0); // Get the callback\n\n    callback = args.pop(); // Get the possible options object\n\n    const opts = args[args.length - 1]; // If it contains any of the admissible options pop it of the args\n\n    options = opts && (opts.readPreference || opts.explain || opts.cursor || opts.out || opts.maxTimeMS || opts.hint || opts.allowDiskUse) ? args.pop() : {}; // Left over arguments is the pipeline\n\n    pipeline = args;\n  }\n\n  const cursor = new AggregationCursor(this.s.topology, new AggregateOperation(this, pipeline, options), options); // TODO: remove this when NODE-2074 is resolved\n\n  if (typeof callback === 'function') {\n    callback(null, cursor);\n    return;\n  }\n\n  return cursor;\n};\n/**\n * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n * @method\n * @since 3.0.0\n * @param {Array} [pipeline] An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n * @param {object} [options] Optional settings\n * @param {string} [options.fullDocument='default'] Allowed values: default, updateLookup. When set to updateLookup, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @param {object} [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {ReadPreference} [options.readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n * @param {Timestamp} [options.startAtOperationTime] receive change events that occur after the specified timestamp\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {ChangeStream} a ChangeStream instance.\n */\n\n\nCollection.prototype.watch = function (pipeline, options) {\n  pipeline = pipeline || [];\n  options = options || {}; // Allow optionally not specifying a pipeline\n\n  if (!Array.isArray(pipeline)) {\n    options = pipeline;\n    pipeline = [];\n  }\n\n  return new ChangeStream(this, pipeline, options);\n};\n/**\n * The callback format for results\n * @callback Collection~parallelCollectionScanCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.\n */\n\n/**\n * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are\n * no ordering guarantees for returned results.\n * @method\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=1000] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)\n * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\n\n\nCollection.prototype.parallelCollectionScan = deprecate(function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {\n    numCursors: 1\n  }; // Set number of cursors to 1\n\n  options.numCursors = options.numCursors || 1;\n  options.batchSize = options.batchSize || 1000;\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = ReadPreference.resolve(this, options); // Add a promiseLibrary\n\n  options.promiseLibrary = this.s.promiseLibrary;\n\n  if (options.session) {\n    options.session = undefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, parallelCollectionScan, [this, options, callback], {\n    skipSessions: true\n  });\n}, 'parallelCollectionScan is deprecated in MongoDB v4.1');\n/**\n * Execute a geo search using a geo haystack index on a collection.\n *\n * @method\n * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxDistance] Include results up to maxDistance from the point.\n * @param {object} [options.search] Filter the results by a query.\n * @param {number} [options.limit=false] Max number of results to return.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated See {@link https://docs.mongodb.com/manual/geospatial-queries/|geospatial queries docs} for current geospatial support\n */\n\nCollection.prototype.geoHaystackSearch = deprecate(function (x, y, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n  const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);\n  return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);\n}, 'geoHaystackSearch is deprecated, and will be removed in a future version.');\n/**\n * Run a group command across a collection\n *\n * @method\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.\n */\n\nCollection.prototype.group = deprecate(function (keys, condition, initial, reduce, finalize, command, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 3);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  reduce = args.length ? args.shift() : null;\n  finalize = args.length ? args.shift() : null;\n  command = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {}; // Make sure we are backward compatible\n\n  if (!(typeof finalize === 'function')) {\n    command = finalize;\n    finalize = null;\n  }\n\n  if (!Array.isArray(keys) && keys instanceof Object && typeof keys !== 'function' && !(keys._bsontype === 'Code')) {\n    keys = Object.keys(keys);\n  }\n\n  if (typeof reduce === 'function') {\n    reduce = reduce.toString();\n  }\n\n  if (typeof finalize === 'function') {\n    finalize = finalize.toString();\n  } // Set up the command as default\n\n\n  command = command == null ? true : command;\n  return executeLegacyOperation(this.s.topology, group, [this, keys, condition, initial, reduce, finalize, command, options, callback]);\n}, 'MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.');\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @method\n * @param {(function|string)} map The mapping function.\n * @param {(function|string)} reduce The reduce function.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {object} [options.out] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*\n * @param {object} [options.query] Query filter object.\n * @param {object} [options.sort] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.\n * @param {number} [options.limit] Number of objects to return from collection.\n * @param {boolean} [options.keeptemp=false] Keep temporary data.\n * @param {(function|string)} [options.finalize] Finalize function.\n * @param {object} [options.scope] Can pass in variables that can be access from map/reduce/finalize.\n * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.\n * @param {boolean} [options.verbose=false] Provide statistics on job execution time.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\n\nCollection.prototype.mapReduce = function (map, reduce, options, callback) {\n  if ('function' === typeof options) callback = options, options = {}; // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)\n\n  if (null == options.out) {\n    throw new Error('the out option parameter must be defined, see mongodb docs for possible values');\n  }\n\n  if ('function' === typeof map) {\n    map = map.toString();\n  }\n\n  if ('function' === typeof reduce) {\n    reduce = reduce.toString();\n  }\n\n  if ('function' === typeof options.finalize) {\n    options.finalize = options.finalize.toString();\n  }\n\n  const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);\n  return executeOperation(this.s.topology, mapReduceOperation, callback);\n};\n/**\n * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {UnorderedBulkOperation}\n */\n\n\nCollection.prototype.initializeUnorderedBulkOp = function (options) {\n  options = options || {}; // Give function's options precedence over session options.\n\n  if (options.ignoreUndefined == null) {\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  options.promiseLibrary = this.s.promiseLibrary;\n  return unordered(this.s.topology, this, options);\n};\n/**\n * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {OrderedBulkOperation} callback The command result callback\n * @return {null}\n */\n\n\nCollection.prototype.initializeOrderedBulkOp = function (options) {\n  options = options || {}; // Give function's options precedence over session's options.\n\n  if (options.ignoreUndefined == null) {\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  options.promiseLibrary = this.s.promiseLibrary;\n  return ordered(this.s.topology, this, options);\n};\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\n\n\nCollection.prototype.getLogger = function () {\n  return this.s.db.s.logger;\n};\n\nmodule.exports = Collection;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb/lib/collection.js"],"names":["deprecate","require","deprecateOptions","emitWarningOnce","checkCollectionName","ObjectID","BSON","MongoError","normalizeHintField","decorateCommand","decorateWithCollation","decorateWithReadConcern","formattedOrderClause","ReadPreference","unordered","ordered","ChangeStream","executeLegacyOperation","WriteConcern","ReadConcern","MongoDBNamespace","AggregationCursor","CommandCursor","ensureIndex","group","parallelCollectionScan","removeDocuments","save","updateDocuments","AggregateOperation","BulkWriteOperation","CountDocumentsOperation","CreateIndexesOperation","DeleteManyOperation","DeleteOneOperation","DistinctOperation","DropCollectionOperation","DropIndexOperation","DropIndexesOperation","EstimatedDocumentCountOperation","FindOperation","FindOneOperation","FindAndModifyOperation","FindOneAndDeleteOperation","FindOneAndReplaceOperation","FindOneAndUpdateOperation","GeoHaystackSearchOperation","IndexesOperation","IndexExistsOperation","IndexInformationOperation","InsertManyOperation","InsertOneOperation","IsCappedOperation","ListIndexesOperation","MapReduceOperation","OptionsOperation","RenameOperation","ReIndexOperation","ReplaceOneOperation","StatsOperation","UpdateManyOperation","UpdateOneOperation","executeOperation","mergeKeys","Collection","db","topology","dbName","name","pkFactory","options","internalHint","slaveOk","serializeFunctions","s","raw","promoteLongs","promoteValues","promoteBuffers","collectionHint","namespace","promiseLibrary","Promise","readPreference","fromOptions","readConcern","writeConcern","Object","defineProperty","prototype","enumerable","get","collection","toString","set","v","DEPRECATED_FIND_OPTIONS","find","deprecatedOptions","optionsIndex","query","callback","selector","undefined","object","Buffer","isBuffer","object_size","length","error","Error","_bsontype","_id","projection","fields","Array","isArray","reduce","result","field","newOptions","assign","key","indexOf","skip","limit","hint","timeout","resolve","mode","create","message","driver","findCommand","allowDiskUse","awaitdata","awaitData","noCursorTimeout","sort","err","cursor","insertOne","doc","ignoreUndefined","insertOneOperation","insertMany","docs","insertManyOperation","bulkWrite","operations","bulkWriteOperation","insert","keepGoing","updateOne","filter","update","replaceOne","updateMany","deleteOne","deleteOneOperation","removeOne","deleteMany","deleteManyOperation","removeMany","remove","findOne","findOneOperation","rename","newName","PRIMARY","renameOperation","drop","dropCollectionOperation","collectionName","opts","optionsOperation","isCapped","isCappedOperation","createIndex","fieldOrSpec","createIndexesOperation","createIndexes","indexSpecs","maxTimeMS","dropIndex","indexName","args","slice","call","arguments","pop","shift","dropIndexOperation","dropIndexes","dropIndexesOperation","dropAllIndexes","reIndex","reIndexOperation","listIndexes","indexExists","indexes","indexExistsOperation","indexInformation","indexInformationOperation","count","estimatedDocumentCount","estimatedDocumentCountOperation","countDocuments","countDocumentsOperation","distinct","queryOption","optionsOption","distinctOperation","indexesOperation","stats","statsOperation","findOneAndDelete","findOneAndReplace","replacement","findOneAndUpdate","findAndModify","_findAndModify","findAndRemove","aggregate","pipeline","explain","out","watch","numCursors","batchSize","session","skipSessions","geoHaystackSearch","x","y","geoHaystackSearchOperation","keys","condition","initial","finalize","command","mapReduce","map","mapReduceOperation","initializeUnorderedBulkOp","initializeOrderedBulkOp","getLogger","logger","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst deprecate = require('util').deprecate;\nconst deprecateOptions = require('./utils').deprecateOptions;\nconst emitWarningOnce = require('./utils').emitWarningOnce;\nconst checkCollectionName = require('./utils').checkCollectionName;\nconst ObjectID = require('./core').BSON.ObjectID;\nconst MongoError = require('./core').MongoError;\nconst normalizeHintField = require('./utils').normalizeHintField;\nconst decorateCommand = require('./utils').decorateCommand;\nconst decorateWithCollation = require('./utils').decorateWithCollation;\nconst decorateWithReadConcern = require('./utils').decorateWithReadConcern;\nconst formattedOrderClause = require('./utils').formattedOrderClause;\nconst ReadPreference = require('./core').ReadPreference;\nconst unordered = require('./bulk/unordered');\nconst ordered = require('./bulk/ordered');\nconst ChangeStream = require('./change_stream');\nconst executeLegacyOperation = require('./utils').executeLegacyOperation;\nconst WriteConcern = require('./write_concern');\nconst ReadConcern = require('./read_concern');\nconst MongoDBNamespace = require('./utils').MongoDBNamespace;\nconst AggregationCursor = require('./aggregation_cursor');\nconst CommandCursor = require('./command_cursor');\n\n// Operations\nconst ensureIndex = require('./operations/collection_ops').ensureIndex;\nconst group = require('./operations/collection_ops').group;\nconst parallelCollectionScan = require('./operations/collection_ops').parallelCollectionScan;\nconst removeDocuments = require('./operations/common_functions').removeDocuments;\nconst save = require('./operations/collection_ops').save;\nconst updateDocuments = require('./operations/common_functions').updateDocuments;\n\nconst AggregateOperation = require('./operations/aggregate');\nconst BulkWriteOperation = require('./operations/bulk_write');\nconst CountDocumentsOperation = require('./operations/count_documents');\nconst CreateIndexesOperation = require('./operations/create_indexes');\nconst DeleteManyOperation = require('./operations/delete_many');\nconst DeleteOneOperation = require('./operations/delete_one');\nconst DistinctOperation = require('./operations/distinct');\nconst DropCollectionOperation = require('./operations/drop').DropCollectionOperation;\nconst DropIndexOperation = require('./operations/drop_index');\nconst DropIndexesOperation = require('./operations/drop_indexes');\nconst EstimatedDocumentCountOperation = require('./operations/estimated_document_count');\nconst FindOperation = require('./operations/find');\nconst FindOneOperation = require('./operations/find_one');\nconst FindAndModifyOperation = require('./operations/find_and_modify');\nconst FindOneAndDeleteOperation = require('./operations/find_one_and_delete');\nconst FindOneAndReplaceOperation = require('./operations/find_one_and_replace');\nconst FindOneAndUpdateOperation = require('./operations/find_one_and_update');\nconst GeoHaystackSearchOperation = require('./operations/geo_haystack_search');\nconst IndexesOperation = require('./operations/indexes');\nconst IndexExistsOperation = require('./operations/index_exists');\nconst IndexInformationOperation = require('./operations/index_information');\nconst InsertManyOperation = require('./operations/insert_many');\nconst InsertOneOperation = require('./operations/insert_one');\nconst IsCappedOperation = require('./operations/is_capped');\nconst ListIndexesOperation = require('./operations/list_indexes');\nconst MapReduceOperation = require('./operations/map_reduce');\nconst OptionsOperation = require('./operations/options_operation');\nconst RenameOperation = require('./operations/rename');\nconst ReIndexOperation = require('./operations/re_index');\nconst ReplaceOneOperation = require('./operations/replace_one');\nconst StatsOperation = require('./operations/stats');\nconst UpdateManyOperation = require('./operations/update_many');\nconst UpdateOneOperation = require('./operations/update_one');\n\nconst executeOperation = require('./operations/execute_operation');\n\n/**\n * @fileOverview The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @example\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     test.equal(null, err);\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n */\n\nconst mergeKeys = ['ignoreUndefined'];\n\n/**\n * Create a new Collection instance (INTERNAL TYPE, do not instantiate directly)\n * @class\n */\nfunction Collection(db, topology, dbName, name, pkFactory, options) {\n  checkCollectionName(name);\n\n  // Unpack variables\n  const internalHint = null;\n  const slaveOk = options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk;\n  const serializeFunctions =\n    options == null || options.serializeFunctions == null\n      ? db.s.options.serializeFunctions\n      : options.serializeFunctions;\n  const raw = options == null || options.raw == null ? db.s.options.raw : options.raw;\n  const promoteLongs =\n    options == null || options.promoteLongs == null\n      ? db.s.options.promoteLongs\n      : options.promoteLongs;\n  const promoteValues =\n    options == null || options.promoteValues == null\n      ? db.s.options.promoteValues\n      : options.promoteValues;\n  const promoteBuffers =\n    options == null || options.promoteBuffers == null\n      ? db.s.options.promoteBuffers\n      : options.promoteBuffers;\n  const collectionHint = null;\n\n  const namespace = new MongoDBNamespace(dbName, name);\n\n  // Get the promiseLibrary\n  const promiseLibrary = options.promiseLibrary || Promise;\n\n  // Set custom primary key factory if provided\n  pkFactory = pkFactory == null ? ObjectID : pkFactory;\n\n  // Internal state\n  this.s = {\n    // Set custom primary key factory if provided\n    pkFactory: pkFactory,\n    // Db\n    db: db,\n    // Topology\n    topology: topology,\n    // Options\n    options: options,\n    // Namespace\n    namespace: namespace,\n    // Read preference\n    readPreference: ReadPreference.fromOptions(options),\n    // SlaveOK\n    slaveOk: slaveOk,\n    // Serialize functions\n    serializeFunctions: serializeFunctions,\n    // Raw\n    raw: raw,\n    // promoteLongs\n    promoteLongs: promoteLongs,\n    // promoteValues\n    promoteValues: promoteValues,\n    // promoteBuffers\n    promoteBuffers: promoteBuffers,\n    // internalHint\n    internalHint: internalHint,\n    // collectionHint\n    collectionHint: collectionHint,\n    // Promise library\n    promiseLibrary: promiseLibrary,\n    // Read Concern\n    readConcern: ReadConcern.fromOptions(options),\n    // Write Concern\n    writeConcern: WriteConcern.fromOptions(options)\n  };\n}\n\n/**\n * The name of the database this collection belongs to\n * @member {string} dbName\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'dbName', {\n  enumerable: true,\n  get: function() {\n    return this.s.namespace.db;\n  }\n});\n\n/**\n * The name of this collection\n * @member {string} collectionName\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'collectionName', {\n  enumerable: true,\n  get: function() {\n    return this.s.namespace.collection;\n  }\n});\n\n/**\n * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n * @member {string} namespace\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'namespace', {\n  enumerable: true,\n  get: function() {\n    return this.s.namespace.toString();\n  }\n});\n\n/**\n * The current readConcern of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {ReadConcern} [readConcern]\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'readConcern', {\n  enumerable: true,\n  get: function() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n    return this.s.readConcern;\n  }\n});\n\n/**\n * The current readPreference of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {ReadPreference} [readPreference]\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'readPreference', {\n  enumerable: true,\n  get: function() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n});\n\n/**\n * The current writeConcern of the collection. If not explicitly defined for\n * this collection, will be inherited from the parent DB\n * @member {WriteConcern} [writeConcern]\n * @memberof Collection#\n * @readonly\n */\nObject.defineProperty(Collection.prototype, 'writeConcern', {\n  enumerable: true,\n  get: function() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n    return this.s.writeConcern;\n  }\n});\n\n/**\n * The current index hint for the collection\n * @member {object} [hint]\n * @memberof Collection#\n */\nObject.defineProperty(Collection.prototype, 'hint', {\n  enumerable: true,\n  get: function() {\n    return this.s.collectionHint;\n  },\n  set: function(v) {\n    this.s.collectionHint = normalizeHintField(v);\n  }\n});\n\nconst DEPRECATED_FIND_OPTIONS = ['maxScan', 'fields', 'snapshot', 'oplogReplay'];\n\n/**\n * Creates a cursor for a query that can be used to iterate over results from MongoDB\n * @method\n * @param {object} [query={}] The cursor query object.\n * @param {object} [options] Optional settings.\n * @param {number} [options.limit=0] Sets the limit of documents returned in the query.\n * @param {(array|object)} [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n * @param {object} [options.projection] The fields to return in the query. Object of fields to either include or exclude (one of, not both), {'a':1, 'b': 1} **or** {'a': 0, 'b': 0}\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).\n * @param {Object} [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n * @param {boolean} [options.snapshot=false] DEPRECATED: Snapshot query.\n * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.\n * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.\n * @param {boolean} [options.awaitData=false] Specify if the cursor is a a tailable-await cursor. Requires `tailable` to be true\n * @param {number} [options.batchSize=1000] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {boolean} [options.returnKey=false] Only return the index key.\n * @param {number} [options.maxScan] DEPRECATED: Limit the number of items to scan.\n * @param {number} [options.min] Set index bounds.\n * @param {number} [options.max] Set index bounds.\n * @param {boolean} [options.showDiskLoc=false] Show disk location of results.\n * @param {string} [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @param {boolean} [options.noCursorTimeout] The server normally times out idle cursors after an inactivity period (10 minutes) to prevent excess memory use. Set this option to prevent that.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {boolean} [options.allowDiskUse] Enables writing to temporary files on the server.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @throws {MongoError}\n * @return {Cursor}\n */\nCollection.prototype.find = deprecateOptions(\n  {\n    name: 'collection.find',\n    deprecatedOptions: DEPRECATED_FIND_OPTIONS,\n    optionsIndex: 1\n  },\n  function(query, options, callback) {\n    if (typeof callback === 'object') {\n      // TODO(MAJOR): throw in the future\n      emitWarningOnce('Third parameter to `find()` must be a callback or undefined');\n    }\n\n    let selector = query;\n    // figuring out arguments\n    if (typeof callback !== 'function') {\n      if (typeof options === 'function') {\n        callback = options;\n        options = undefined;\n      } else if (options == null) {\n        callback = typeof selector === 'function' ? selector : undefined;\n        selector = typeof selector === 'object' ? selector : undefined;\n      }\n    }\n\n    // Ensure selector is not null\n    selector = selector == null ? {} : selector;\n    // Validate correctness off the selector\n    const object = selector;\n    if (Buffer.isBuffer(object)) {\n      const object_size = object[0] | (object[1] << 8) | (object[2] << 16) | (object[3] << 24);\n      if (object_size !== object.length) {\n        const error = new Error(\n          'query selector raw message size does not match message header size [' +\n            object.length +\n            '] != [' +\n            object_size +\n            ']'\n        );\n        error.name = 'MongoError';\n        throw error;\n      }\n    }\n\n    // Check special case where we are using an objectId\n    if (selector != null && selector._bsontype === 'ObjectID') {\n      selector = { _id: selector };\n    }\n\n    if (!options) options = {};\n\n    let projection = options.projection || options.fields;\n\n    if (projection && !Buffer.isBuffer(projection) && Array.isArray(projection)) {\n      projection = projection.length\n        ? projection.reduce((result, field) => {\n            result[field] = 1;\n            return result;\n          }, {})\n        : { _id: 1 };\n    }\n\n    // Make a shallow copy of options\n    let newOptions = Object.assign({}, options);\n\n    // Make a shallow copy of the collection options\n    for (let key in this.s.options) {\n      if (mergeKeys.indexOf(key) !== -1) {\n        newOptions[key] = this.s.options[key];\n      }\n    }\n\n    // Unpack options\n    newOptions.skip = options.skip ? options.skip : 0;\n    newOptions.limit = options.limit ? options.limit : 0;\n    newOptions.raw = typeof options.raw === 'boolean' ? options.raw : this.s.raw;\n    newOptions.hint =\n      options.hint != null ? normalizeHintField(options.hint) : this.s.collectionHint;\n    newOptions.timeout = typeof options.timeout === 'undefined' ? undefined : options.timeout;\n    // // If we have overridden slaveOk otherwise use the default db setting\n    newOptions.slaveOk = options.slaveOk != null ? options.slaveOk : this.s.db.slaveOk;\n\n    // Add read preference if needed\n    newOptions.readPreference = ReadPreference.resolve(this, newOptions);\n\n    // Set slave ok to true if read preference different from primary\n    if (\n      newOptions.readPreference != null &&\n      (newOptions.readPreference !== 'primary' || newOptions.readPreference.mode !== 'primary')\n    ) {\n      newOptions.slaveOk = true;\n    }\n\n    // Ensure the query is an object\n    if (selector != null && typeof selector !== 'object') {\n      throw MongoError.create({ message: 'query selector must be an object', driver: true });\n    }\n\n    // Build the find command\n    const findCommand = {\n      find: this.s.namespace.toString(),\n      limit: newOptions.limit,\n      skip: newOptions.skip,\n      query: selector\n    };\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      findCommand.allowDiskUse = options.allowDiskUse;\n    }\n\n    // Ensure we use the right await data option\n    if (typeof newOptions.awaitdata === 'boolean') {\n      newOptions.awaitData = newOptions.awaitdata;\n    }\n\n    // Translate to new command option noCursorTimeout\n    if (typeof newOptions.timeout === 'boolean') newOptions.noCursorTimeout = !newOptions.timeout;\n\n    decorateCommand(findCommand, newOptions, ['session', 'collation']);\n\n    if (projection) findCommand.fields = projection;\n\n    // Add db object to the new options\n    newOptions.db = this.s.db;\n\n    // Add the promise library\n    newOptions.promiseLibrary = this.s.promiseLibrary;\n\n    // Set raw if available at collection level\n    if (newOptions.raw == null && typeof this.s.raw === 'boolean') newOptions.raw = this.s.raw;\n    // Set promoteLongs if available at collection level\n    if (newOptions.promoteLongs == null && typeof this.s.promoteLongs === 'boolean')\n      newOptions.promoteLongs = this.s.promoteLongs;\n    if (newOptions.promoteValues == null && typeof this.s.promoteValues === 'boolean')\n      newOptions.promoteValues = this.s.promoteValues;\n    if (newOptions.promoteBuffers == null && typeof this.s.promoteBuffers === 'boolean')\n      newOptions.promoteBuffers = this.s.promoteBuffers;\n\n    // Sort options\n    if (findCommand.sort) {\n      findCommand.sort = formattedOrderClause(findCommand.sort);\n    }\n\n    // Set the readConcern\n    decorateWithReadConcern(findCommand, this, options);\n\n    // Decorate find command with collation options\n    try {\n      decorateWithCollation(findCommand, this, options);\n    } catch (err) {\n      if (typeof callback === 'function') return callback(err, null);\n      throw err;\n    }\n\n    const cursor = this.s.topology.cursor(\n      new FindOperation(this, this.s.namespace, findCommand, newOptions),\n      newOptions\n    );\n\n    // TODO: remove this when NODE-2074 is resolved\n    if (typeof callback === 'function') {\n      callback(null, cursor);\n      return;\n    }\n\n    return cursor;\n  }\n);\n\n/**\n * Inserts a single document into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object} doc Document to insert.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=true] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertOneWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.insertOne = function(doc, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const insertOneOperation = new InsertOneOperation(this, doc, options);\n\n  return executeOperation(this.s.topology, insertOneOperation, callback);\n};\n\n/**\n * Inserts an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} docs Documents to insert.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.ordered=true] If true, when an insert fails, don't execute the remaining writes. If false, continue with remaining inserts when one fails.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=true] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.insertMany = function(docs, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options ? Object.assign({}, options) : { ordered: true };\n\n  const insertManyOperation = new InsertManyOperation(this, docs, options);\n\n  return executeOperation(this.s.topology, insertManyOperation, callback);\n};\n\n/**\n * @typedef {Object} Collection~BulkWriteOpResult\n * @property {number} insertedCount Number of documents inserted.\n * @property {number} matchedCount Number of documents matched for update.\n * @property {number} modifiedCount Number of documents modified.\n * @property {number} deletedCount Number of documents deleted.\n * @property {number} upsertedCount Number of documents upserted.\n * @property {object} insertedIds Inserted document generated Id's, hash key is the index of the originating operation\n * @property {object} upsertedIds Upserted document generated Id's, hash key is the index of the originating operation\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~bulkWriteOpCallback\n * @param {BulkWriteError} error An error instance representing the error during the execution.\n * @param {Collection~BulkWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Perform a bulkWrite operation without a fluent API\n *\n * Legal operation types are\n *\n *  { insertOne: { document: { a: 1 } } }\n *\n *  { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n *\n *  { updateMany: { filter: {}, update: {$set: {\"a.$[i].x\": 5}}, arrayFilters: [{ \"i.x\": 5 }]} }\n *\n *  { deleteOne: { filter: {c:1} } }\n *\n *  { deleteMany: { filter: {c:1} } }\n *\n *  { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}\n *\n * If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {object[]} operations Bulk operations to perform.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.ordered=true] Execute write operation in ordered or unordered fashion.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object[]} [options.arrayFilters] Determines which array elements to modify for update operation in MongoDB 3.6 or higher.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~bulkWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.bulkWrite = function(operations, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || { ordered: true };\n\n  if (!Array.isArray(operations)) {\n    throw MongoError.create({ message: 'operations must be an array of documents', driver: true });\n  }\n\n  const bulkWriteOperation = new BulkWriteOperation(this, operations, options);\n\n  return executeOperation(this.s.topology, bulkWriteOperation, callback);\n};\n\n/**\n * @typedef {Object} Collection~WriteOpResult\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The command result object.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~writeOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~WriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * @typedef {Object} Collection~insertWriteOpResult\n * @property {number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {Object.<Number, ObjectId>} insertedIds Map of the index of the inserted document to the id of the inserted document.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {number} result.ok Is 1 if the command executed correctly.\n * @property {number} result.n The total count of documents inserted.\n */\n\n/**\n * @typedef {Object} Collection~insertOneWriteOpResult\n * @property {number} insertedCount The total amount of documents inserted.\n * @property {object[]} ops All the documents inserted using insertOne/insertMany/replaceOne. Documents contain the _id field if forceServerObjectId == false for insertOne/insertMany\n * @property {ObjectId} insertedId The driver generated ObjectId for the insert operation.\n * @property {object} connection The connection object used for the operation.\n * @property {object} result The raw command result object returned from MongoDB (content might vary by server version).\n * @property {number} result.ok Is 1 if the command executed correctly.\n * @property {number} result.n The total count of documents inserted.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~insertOneWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~insertOneWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n * can be overridden by setting the **forceServerObjectId** flag.\n *\n * @method\n * @param {(object|object[])} docs Documents to insert.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.forceServerObjectId=false] Force server to assign _id values instead of driver.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~insertWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated Use insertOne, insertMany or bulkWrite\n */\nCollection.prototype.insert = deprecate(function(docs, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || { ordered: false };\n  docs = !Array.isArray(docs) ? [docs] : docs;\n\n  if (options.keepGoing === true) {\n    options.ordered = false;\n  }\n\n  return this.insertMany(docs, options, callback);\n}, 'collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n\n/**\n * @typedef {Object} Collection~updateWriteOpResult\n * @property {Object} result The raw result returned from MongoDB. Will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents scanned.\n * @property {Number} result.nModified The total count of documents modified.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} matchedCount The number of documents that matched the filter.\n * @property {Number} modifiedCount The number of documents that were modified.\n * @property {Number} upsertedCount The number of documents upserted.\n * @property {Object} upsertedId The upserted id.\n * @property {ObjectId} upsertedId._id The upserted _id returned from the server.\n * @property {Object} message The raw msg response wrapped in an internal class\n * @property {object[]} [ops] In a response to {@link Collection#replaceOne replaceOne}, contains the new value of the document on the server. This is the same document that was originally passed in, and is only here for legacy purposes.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~updateWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~updateWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Update a single document in a collection\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update The update operations to be applied to the document\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query..\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.updateOne = function(filter, update, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options);\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new UpdateOneOperation(this, filter, update, options),\n    callback\n  );\n};\n\n/**\n * Replace a document in a collection with another document\n * @method\n * @param {object} filter The Filter used to select the document to replace\n * @param {object} doc The Document that replaces the matching document\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise<Collection~updateWriteOpResult>} returns Promise if no callback passed\n */\nCollection.prototype.replaceOne = function(filter, doc, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options);\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new ReplaceOneOperation(this, filter, doc, options),\n    callback\n  );\n};\n\n/**\n * Update multiple documents in a collection\n * @method\n * @param {object} filter The Filter used to select the documents to update\n * @param {object} update The update operations to be applied to the documents\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {boolean} [options.upsert=false] When true, creates a new document if no document matches the query..\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~updateWriteOpCallback} [callback] The command result callback\n * @return {Promise<Collection~updateWriteOpResult>} returns Promise if no callback passed\n */\nCollection.prototype.updateMany = function(filter, update, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options);\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new UpdateManyOperation(this, filter, update, options),\n    callback\n  );\n};\n\n/**\n * Updates documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} update The update operations to be applied to the documents\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.upsert=false] Update operation is an upsert.\n * @param {boolean} [options.multi=false] Update one/all documents with operation.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use updateOne, updateMany or bulkWrite\n */\nCollection.prototype.update = deprecate(function(selector, update, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, updateDocuments, [\n    this,\n    selector,\n    update,\n    options,\n    callback\n  ]);\n}, 'collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n\n/**\n * @typedef {Object} Collection~deleteWriteOpResult\n * @property {Object} result The raw result returned from MongoDB. Will vary depending on server version.\n * @property {Number} result.ok Is 1 if the command executed correctly.\n * @property {Number} result.n The total count of documents deleted.\n * @property {Object} connection The connection object used for the operation.\n * @property {Number} deletedCount The number of documents deleted.\n */\n\n/**\n * The callback format for deletes\n * @callback Collection~deleteWriteOpCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~deleteWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Delete a document from a collection\n * @method\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {string|object} [options.hint] optional index hint for optimizing the filter query\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.deleteOne = function(filter, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options);\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const deleteOneOperation = new DeleteOneOperation(this, filter, options);\n\n  return executeOperation(this.s.topology, deleteOneOperation, callback);\n};\n\nCollection.prototype.removeOne = Collection.prototype.deleteOne;\n\n/**\n * Delete multiple documents from a collection\n * @method\n * @param {object} filter The Filter used to select the documents to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {string|object} [options.hint] optional index hint for optimizing the filter query\n * @param {Collection~deleteWriteOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.deleteMany = function(filter, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options);\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  const deleteManyOperation = new DeleteManyOperation(this, filter, options);\n\n  return executeOperation(this.s.topology, deleteManyOperation, callback);\n};\n\nCollection.prototype.removeMany = Collection.prototype.deleteMany;\n\n/**\n * Remove documents.\n * @method\n * @param {object} selector The selector for the update operation.\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.single=false] Removes the first document found.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use deleteOne, deleteMany or bulkWrite\n */\nCollection.prototype.remove = deprecate(function(selector, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, removeDocuments, [\n    this,\n    selector,\n    options,\n    callback\n  ]);\n}, 'collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n\n/**\n * Save a document. Simple full document replacement function. Not recommended for efficiency, use atomic\n * operators and update instead for more efficient operations.\n * @method\n * @param {object} doc Document to save\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~writeOpCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use insertOne, insertMany, updateOne or updateMany\n */\nCollection.prototype.save = deprecate(function(doc, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeLegacyOperation(this.s.topology, save, [this, doc, options, callback]);\n}, 'collection.save is deprecated. Use insertOne, insertMany, updateOne, or updateMany instead.');\n\n/**\n * The callback format for results\n * @callback Collection~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {object} result The result object if the command was executed successfully.\n */\n\n/**\n * The callback format for an aggregation call\n * @callback Collection~aggregationCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {AggregationCursor} cursor The cursor if the aggregation command was executed successfully.\n */\n\n/**\n * Fetches the first document that matches the query\n * @method\n * @param {object} query Query for find Operation\n * @param {object} [options] Optional settings.\n * @param {number} [options.limit=0] Sets the limit of documents returned in the query.\n * @param {(array|object)} [options.sort] Set to sort the documents coming back from the query. Array of indexes, [['a', 1]] etc.\n * @param {object} [options.projection] The fields to return in the query. Object of fields to include or exclude (not both), {'a':1}\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {number} [options.skip=0] Set to skip N documents ahead in your query (useful for pagination).\n * @param {Object} [options.hint] Tell the query to use specific indexes in the query. Object of indexes to use, {'_id':1}\n * @param {boolean} [options.snapshot=false] DEPRECATED: Snapshot query.\n * @param {boolean} [options.timeout=false] Specify if the cursor can timeout.\n * @param {boolean} [options.tailable=false] Specify if the cursor is tailable.\n * @param {number} [options.batchSize=1] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {boolean} [options.returnKey=false] Only return the index key.\n * @param {number} [options.maxScan] DEPRECATED: Limit the number of items to scan.\n * @param {number} [options.min] Set index bounds.\n * @param {number} [options.max] Set index bounds.\n * @param {boolean} [options.showDiskLoc=false] Show disk location of results.\n * @param {string} [options.comment] You can put a $comment field on a query to make looking in the profiler logs simpler.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {boolean} [options.partial=false] Specify if the cursor should return partial results when querying against a sharded system\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.findOne = deprecateOptions(\n  {\n    name: 'collection.find',\n    deprecatedOptions: DEPRECATED_FIND_OPTIONS,\n    optionsIndex: 1\n  },\n  function(query, options, callback) {\n    if (typeof callback === 'object') {\n      // TODO(MAJOR): throw in the future\n      emitWarningOnce('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof query === 'function') (callback = query), (query = {}), (options = {});\n    if (typeof options === 'function') (callback = options), (options = {});\n    query = query || {};\n    options = options || {};\n\n    const findOneOperation = new FindOneOperation(this, query, options);\n\n    return executeOperation(this.s.topology, findOneOperation, callback);\n  }\n);\n\n/**\n * The callback format for the collection method, must be used if strict is specified\n * @callback Collection~collectionResultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection} collection The collection instance.\n */\n\n/**\n * Rename the collection.\n *\n * @method\n * @param {string} newName New name of of the collection.\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.dropTarget=false] Drop the target name collection if it previously exists.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~collectionResultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.rename = function(newName, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = Object.assign({}, options, { readPreference: ReadPreference.PRIMARY });\n\n  const renameOperation = new RenameOperation(this, newName, options);\n\n  return executeOperation(this.s.topology, renameOperation, callback);\n};\n\n/**\n * Drop the collection from the database, removing it permanently. New accesses will create a new collection.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.drop = function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const dropCollectionOperation = new DropCollectionOperation(\n    this.s.db,\n    this.collectionName,\n    options\n  );\n\n  return executeOperation(this.s.topology, dropCollectionOperation, callback);\n};\n\n/**\n * Returns the options of the collection.\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.options = function(opts, callback) {\n  if (typeof opts === 'function') (callback = opts), (opts = {});\n  opts = opts || {};\n\n  const optionsOperation = new OptionsOperation(this, opts);\n\n  return executeOperation(this.s.topology, optionsOperation, callback);\n};\n\n/**\n * Returns if the collection is a capped collection\n *\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The results callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.isCapped = function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const isCappedOperation = new IsCappedOperation(this, options);\n\n  return executeOperation(this.s.topology, isCappedOperation, callback);\n};\n\n/**\n * Creates an index on the db and collection collection.\n * @method\n * @param {(string|array|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {string} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.partialFilterExpression] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {(number|string)} [options.commitQuorum] (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @example\n * const collection = client.db('foo').collection('bar');\n *\n * await collection.createIndex({ a: 1, b: -1 });\n *\n * // Alternate syntax for { c: 1, d: -1 } that ensures order of indexes\n * await collection.createIndex([ [c, 1], [d, -1] ]);\n *\n * // Equivalent to { e: 1 }\n * await collection.createIndex('e');\n *\n * // Equivalent to { f: 1, g: 1 }\n * await collection.createIndex(['f', 'g'])\n *\n * // Equivalent to { h: 1, i: -1 }\n * await collection.createIndex([ { h: 1 }, { i: -1 } ]);\n *\n * // Equivalent to { j: 1, k: -1, l: 2d }\n * await collection.createIndex(['j', ['k', -1], { l: '2d' }])\n */\nCollection.prototype.createIndex = function(fieldOrSpec, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const createIndexesOperation = new CreateIndexesOperation(\n    this,\n    this.collectionName,\n    fieldOrSpec,\n    options\n  );\n\n  return executeOperation(this.s.topology, createIndexesOperation, callback);\n};\n\n/**\n * @typedef {object} Collection~IndexDefinition\n * @description A definition for an index. Used by the createIndex command.\n * @see https://docs.mongodb.com/manual/reference/command/createIndexes/\n */\n\n/**\n * Creates multiple indexes in the collection, this method is only supported for\n * MongoDB 2.6 or higher. Earlier version of MongoDB will throw a command not supported\n * error.\n *\n * **Note**: Unlike {@link Collection#createIndex createIndex}, this function takes in raw index specifications.\n * Index specifications are defined {@link http://docs.mongodb.org/manual/reference/command/createIndexes/ here}.\n *\n * @method\n * @param {Collection~IndexDefinition[]} indexSpecs An array of index specifications to be created\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {(number|string)} [options.commitQuorum] (MongoDB 4.4. or higher) Specifies how many data-bearing members of a replica set, including the primary, must complete the index builds successfully before the primary marks the indexes as ready. This option accepts the same values for the \"w\" field in a write concern plus \"votingMembers\", which indicates all voting data-bearing nodes.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @example\n * const collection = client.db('foo').collection('bar');\n * await collection.createIndexes([\n *   // Simple index on field fizz\n *   {\n *     key: { fizz: 1 },\n *   }\n *   // wildcard index\n *   {\n *     key: { '$**': 1 }\n *   },\n *   // named index on darmok and jalad\n *   {\n *     key: { darmok: 1, jalad: -1 }\n *     name: 'tanagra'\n *   }\n * ]);\n */\nCollection.prototype.createIndexes = function(indexSpecs, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n\n  options = options ? Object.assign({}, options) : {};\n\n  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n\n  const createIndexesOperation = new CreateIndexesOperation(\n    this,\n    this.collectionName,\n    indexSpecs,\n    options\n  );\n\n  return executeOperation(this.s.topology, createIndexesOperation, callback);\n};\n\n/**\n * Drops an index from this collection.\n * @method\n * @param {string} indexName Name of the index to drop.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.dropIndex = function(indexName, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n\n  options = args.length ? args.shift() || {} : {};\n  // Run only against primary\n  options.readPreference = ReadPreference.PRIMARY;\n\n  const dropIndexOperation = new DropIndexOperation(this, indexName, options);\n\n  return executeOperation(this.s.topology, dropIndexOperation, callback);\n};\n\n/**\n * Drops all indexes from this collection.\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.dropIndexes = function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options ? Object.assign({}, options) : {};\n\n  if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n\n  const dropIndexesOperation = new DropIndexesOperation(this, options);\n\n  return executeOperation(this.s.topology, dropIndexesOperation, callback);\n};\n\n/**\n * Drops all indexes from this collection.\n * @method\n * @deprecated use dropIndexes\n * @param {Collection~resultCallback} callback The command result callback\n * @return {Promise} returns Promise if no [callback] passed\n */\nCollection.prototype.dropAllIndexes = deprecate(\n  Collection.prototype.dropIndexes,\n  'collection.dropAllIndexes is deprecated. Use dropIndexes instead.'\n);\n\n/**\n * Reindex all indexes on the collection\n * Warning: reIndex is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n * @method\n * @deprecated use db.command instead\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.reIndex = deprecate(function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const reIndexOperation = new ReIndexOperation(this, options);\n\n  return executeOperation(this.s.topology, reIndexOperation, callback);\n}, 'collection.reIndex is deprecated. Use db.command instead.');\n\n/**\n * Get the list of all indexes information for the collection.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.batchSize=1000] The batchSize for the returned command cursor or if pre 2.8 the systems batch collection\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {CommandCursor}\n */\nCollection.prototype.listIndexes = function(options) {\n  const cursor = new CommandCursor(\n    this.s.topology,\n    new ListIndexesOperation(this, options),\n    options\n  );\n\n  return cursor;\n};\n\n/**\n * Ensures that an index exists, if it does not it creates it\n * @method\n * @deprecated use createIndexes instead\n * @param {(string|object)} fieldOrSpec Defines the index.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.unique=false] Creates an unique index.\n * @param {boolean} [options.sparse=false] Creates a sparse index.\n * @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.\n * @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n * @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.\n * @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.\n * @param {number} [options.v] Specify the format version of the indexes.\n * @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n * @param {number} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.ensureIndex = deprecate(function(fieldOrSpec, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  return executeLegacyOperation(this.s.topology, ensureIndex, [\n    this,\n    fieldOrSpec,\n    options,\n    callback\n  ]);\n}, 'collection.ensureIndex is deprecated. Use createIndexes instead.');\n\n/**\n * Checks if one or more indexes exist on the collection, fails on first non-existing index\n * @method\n * @param {(string|array)} indexes One or more index names to check.\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.indexExists = function(indexes, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const indexExistsOperation = new IndexExistsOperation(this, indexes, options);\n\n  return executeOperation(this.s.topology, indexExistsOperation, callback);\n};\n\n/**\n * Retrieves this collections index info.\n * @method\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.full=false] Returns the full raw index information.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.indexInformation = function(options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n\n  const indexInformationOperation = new IndexInformationOperation(\n    this.s.db,\n    this.collectionName,\n    options\n  );\n\n  return executeOperation(this.s.topology, indexInformationOperation, callback);\n};\n\n/**\n * The callback format for results\n * @callback Collection~countCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {number} result The count of documents that matched the query.\n */\n\n/**\n * An estimated count of matching documents in the db to a query.\n *\n * **NOTE:** This method has been deprecated, since it does not provide an accurate count of the documents\n * in a collection. To obtain an accurate count of documents in the collection, use {@link Collection#countDocuments countDocuments}.\n * To obtain an estimated count of all documents in the collection, use {@link Collection#estimatedDocumentCount estimatedDocumentCount}.\n *\n * @method\n * @param {object} [query={}] The query for the count.\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {boolean} [options.limit] The limit of documents to count.\n * @param {boolean} [options.skip] The number of documents to skip for the count.\n * @param {string} [options.hint] An index name hint for the query.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~countCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use {@link Collection#countDocuments countDocuments} or {@link Collection#estimatedDocumentCount estimatedDocumentCount} instead\n */\nCollection.prototype.count = deprecate(function(query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  query = args.length ? args.shift() || {} : {};\n  options = args.length ? args.shift() || {} : {};\n\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  return executeOperation(\n    this.s.topology,\n    new EstimatedDocumentCountOperation(this, query, options),\n    callback\n  );\n}, 'collection.count is deprecated, and will be removed in a future version.' +\n  ' Use Collection.countDocuments or Collection.estimatedDocumentCount instead');\n\n/**\n * Gets an estimate of the count of documents in a collection using collection metadata.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.\n * @param {Collection~countCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed.\n */\nCollection.prototype.estimatedDocumentCount = function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const estimatedDocumentCountOperation = new EstimatedDocumentCountOperation(this, options);\n\n  return executeOperation(this.s.topology, estimatedDocumentCountOperation, callback);\n};\n\n/**\n * Gets the number of documents matching the filter.\n * For a fast count of the total documents in a collection see {@link Collection#estimatedDocumentCount estimatedDocumentCount}.\n * **Note**: When migrating from {@link Collection#count count} to {@link Collection#countDocuments countDocuments}\n * the following query operators must be replaced:\n *\n * | Operator | Replacement |\n * | -------- | ----------- |\n * | `$where`   | [`$expr`][1] |\n * | `$near`    | [`$geoWithin`][2] with [`$center`][3] |\n * | `$nearSphere` | [`$geoWithin`][2] with [`$centerSphere`][4] |\n *\n * [1]: https://docs.mongodb.com/manual/reference/operator/query/expr/\n * [2]: https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n * [3]: https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n * [4]: https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n *\n * @param {object} [query] the query for the count\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specifies a collation.\n * @param {string|object} [options.hint] The index to use.\n * @param {number} [options.limit] The maximum number of document to count.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the operation to run.\n * @param {number} [options.skip] The number of documents to skip before counting.\n * @param {Collection~countCallback} [callback] The command result callback.\n * @return {Promise} returns Promise if no callback passed.\n * @see https://docs.mongodb.com/manual/reference/operator/query/expr/\n * @see https://docs.mongodb.com/manual/reference/operator/query/geoWithin/\n * @see https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center\n * @see https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere\n */\n\nCollection.prototype.countDocuments = function(query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  query = args.length ? args.shift() || {} : {};\n  options = args.length ? args.shift() || {} : {};\n\n  const countDocumentsOperation = new CountDocumentsOperation(this, query, options);\n\n  return executeOperation(this.s.topology, countDocumentsOperation, callback);\n};\n\n/**\n * The distinct command returns a list of distinct values for the given key across a collection.\n * @method\n * @param {string} key Field of the document to find distinct values for.\n * @param {object} [query] The query for filtering the set of documents to which we apply the distinct filter.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxTimeMS] Number of milliseconds to wait before aborting the query.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.distinct = function(key, query, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  const queryOption = args.length ? args.shift() || {} : {};\n  const optionsOption = args.length ? args.shift() || {} : {};\n\n  const distinctOperation = new DistinctOperation(this, key, queryOption, optionsOption);\n\n  return executeOperation(this.s.topology, distinctOperation, callback);\n};\n\n/**\n * Retrieve all the indexes on the collection.\n * @method\n * @param {Object} [options] Optional settings\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.indexes = function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  const indexesOperation = new IndexesOperation(this, options);\n\n  return executeOperation(this.s.topology, indexesOperation, callback);\n};\n\n/**\n * Get all the collection statistics.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {number} [options.scale] Divide the returned sizes by scale value.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The collection result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.stats = function(options, callback) {\n  const args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n\n  const statsOperation = new StatsOperation(this, options);\n\n  return executeOperation(this.s.topology, statsOperation, callback);\n};\n\n/**\n * @typedef {Object} Collection~findAndModifyWriteOpResult\n * @property {object} value Document returned from the `findAndModify` command. If no documents were found, `value` will be `null` by default (`returnOriginal: true`), even if a document was upserted; if `returnOriginal` was false, the upserted document will be returned in that case.\n * @property {object} lastErrorObject The raw lastErrorObject returned from the command. See {@link https://docs.mongodb.com/manual/reference/command/findAndModify/index.html#lasterrorobject|findAndModify command documentation}.\n * @property {Number} ok Is 1 if the command executed correctly.\n */\n\n/**\n * The callback format for inserts\n * @callback Collection~findAndModifyCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Collection~findAndModifyWriteOpResult} result The result object if the command was executed successfully.\n */\n\n/**\n * Find a document and delete it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to remove\n * @param {object} [options] Optional settings.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\nCollection.prototype.findOneAndDelete = function(filter, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new FindOneAndDeleteOperation(this, filter, options),\n    callback\n  );\n};\n\n/**\n * Find a document and replace it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to replace\n * @param {object} replacement The Document that replaces the matching document\n * @param {object} [options] Optional settings.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {string|object} [options.hint] An optional index to use for this operation\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\nCollection.prototype.findOneAndReplace = function(filter, replacement, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new FindOneAndReplaceOperation(this, filter, replacement, options),\n    callback\n  );\n};\n\n/**\n * Find a document and update it in one atomic operation. Requires a write lock for the duration of the operation.\n *\n * @method\n * @param {object} filter The Filter used to select the document to update\n * @param {object} update Update operations to be performed on the document\n * @param {object} [options] Optional settings.\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).\n * @param {string|object} [options.hint] An optional index to use for this operation\n * @param {number} [options.maxTimeMS] The maximum amount of time to allow the query to run.\n * @param {object} [options.projection] Limits the fields to return for all matching documents.\n * @param {object} [options.sort] Determines which document the operation modifies if the query selects multiple documents.\n * @param {boolean} [options.upsert=false] Upsert the document if it does not exist.\n * @param {boolean} [options.returnOriginal=true] When false, returns the updated document rather than the original. The default is true.\n * @param {boolean} [options.checkKeys=false] If true, will throw if bson documents start with `$` or include a `.` in any key value\n * @param {boolean} [options.serializeFunctions=false] Serialize functions on any object.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] An ptional session to use for this operation\n * @param {Collection~findAndModifyCallback} [callback] The collection result callback\n * @return {Promise<Collection~findAndModifyWriteOpResultObject>} returns Promise if no callback passed\n */\nCollection.prototype.findOneAndUpdate = function(filter, update, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n\n  // Add ignoreUndefined\n  if (this.s.options.ignoreUndefined) {\n    options = Object.assign({}, options);\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  return executeOperation(\n    this.s.topology,\n    new FindOneAndUpdateOperation(this, filter, update, options),\n    callback\n  );\n};\n\n/**\n * Find and update a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.remove=false] Set to true to remove the object before returning.\n * @param {boolean} [options.upsert=false] Perform an upsert operation.\n * @param {boolean} [options.new=false] Set to true if you want to return the modified object rather than the original. Ignored for remove.\n * @param {object} [options.projection] Object containing the field projection for the result returned from the operation.\n * @param {object} [options.fields] **Deprecated** Use `options.projection` instead\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Array} [options.arrayFilters] optional list of array filters referenced in filtered positional operators\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\nCollection.prototype.findAndModify = deprecate(\n  _findAndModify,\n  'collection.findAndModify is deprecated. Use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead.'\n);\n\n/**\n * @ignore\n */\n\nCollection.prototype._findAndModify = _findAndModify;\n\nfunction _findAndModify(query, sort, doc, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  sort = args.length ? args.shift() || [] : [];\n  doc = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {};\n\n  // Clone options\n  options = Object.assign({}, options);\n  // Force read preference primary\n  options.readPreference = ReadPreference.PRIMARY;\n\n  return executeOperation(\n    this.s.topology,\n    new FindAndModifyOperation(this, query, sort, doc, options),\n    callback\n  );\n}\n\n/**\n * Find and remove a document.\n * @method\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated use findOneAndDelete instead\n */\nCollection.prototype.findAndRemove = deprecate(function(query, sort, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  sort = args.length ? args.shift() || [] : [];\n  options = args.length ? args.shift() || {} : {};\n\n  // Add the remove option\n  options.remove = true;\n\n  return executeOperation(\n    this.s.topology,\n    new FindAndModifyOperation(this, query, sort, null, options),\n    callback\n  );\n}, 'collection.findAndRemove is deprecated. Use findOneAndDelete instead.');\n\n/**\n * Execute an aggregation framework pipeline against the collection, needs MongoDB >= 2.2\n * @method\n * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.cursor] Return the query as cursor, on 2.6 > it returns as a real cursor on pre 2.6 it returns as an emulated cursor.\n * @param {number} [options.cursor.batchSize=1000] Deprecated. Use `options.batchSize`\n * @param {boolean} [options.allowDiskUse=false] allowDiskUse lets the server know if it can use disk to store temporary results for the aggregation (requires mongodb 2.6 >).\n * @param {number} [options.maxTimeMS] maxTimeMS specifies a cumulative time limit in milliseconds for processing operations on the cursor. MongoDB interrupts the operation at the earliest following interrupt point.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {boolean} [options.raw=false] Return document results as raw BSON buffers.\n * @param {boolean} [options.promoteLongs=true] Promotes Long values to number if they fit inside the 53 bits resolution.\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {string} [options.comment] Add a comment to an aggregation command\n * @param {string|object} [options.hint] Add an index selection hint to an aggregation command\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~aggregationCallback} callback The command result callback\n * @return {(null|AggregationCursor)}\n */\nCollection.prototype.aggregate = function(pipeline, options, callback) {\n  if (Array.isArray(pipeline)) {\n    // Set up callback if one is provided\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    // If we have no options or callback we are doing\n    // a cursor based aggregation\n    if (options == null && callback == null) {\n      options = {};\n    }\n  } else {\n    // Aggregation pipeline passed as arguments on the method\n    const args = Array.prototype.slice.call(arguments, 0);\n    // Get the callback\n    callback = args.pop();\n    // Get the possible options object\n    const opts = args[args.length - 1];\n    // If it contains any of the admissible options pop it of the args\n    options =\n      opts &&\n      (opts.readPreference ||\n        opts.explain ||\n        opts.cursor ||\n        opts.out ||\n        opts.maxTimeMS ||\n        opts.hint ||\n        opts.allowDiskUse)\n        ? args.pop()\n        : {};\n    // Left over arguments is the pipeline\n    pipeline = args;\n  }\n\n  const cursor = new AggregationCursor(\n    this.s.topology,\n    new AggregateOperation(this, pipeline, options),\n    options\n  );\n\n  // TODO: remove this when NODE-2074 is resolved\n  if (typeof callback === 'function') {\n    callback(null, cursor);\n    return;\n  }\n\n  return cursor;\n};\n\n/**\n * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n * @method\n * @since 3.0.0\n * @param {Array} [pipeline] An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n * @param {object} [options] Optional settings\n * @param {string} [options.fullDocument='default'] Allowed values: default, updateLookup. When set to updateLookup, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @param {object} [options.resumeAfter] Specifies the logical starting point for the new change stream. This should be the _id field from a previously returned change stream document.\n * @param {number} [options.maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {object} [options.collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @param {ReadPreference} [options.readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n * @param {Timestamp} [options.startAtOperationTime] receive change events that occur after the specified timestamp\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {ChangeStream} a ChangeStream instance.\n */\nCollection.prototype.watch = function(pipeline, options) {\n  pipeline = pipeline || [];\n  options = options || {};\n\n  // Allow optionally not specifying a pipeline\n  if (!Array.isArray(pipeline)) {\n    options = pipeline;\n    pipeline = [];\n  }\n\n  return new ChangeStream(this, pipeline, options);\n};\n\n/**\n * The callback format for results\n * @callback Collection~parallelCollectionScanCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {Cursor[]} cursors A list of cursors returned allowing for parallel reading of collection.\n */\n\n/**\n * Return N number of parallel cursors for a collection allowing parallel reading of entire collection. There are\n * no ordering guarantees for returned results.\n * @method\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.batchSize=1000] Set the batchSize for the getMoreCommand when iterating over the query results.\n * @param {number} [options.numCursors=1] The maximum number of parallel command cursors to return (the number of returned cursors will be in the range 1:numCursors)\n * @param {boolean} [options.raw=false] Return all BSON documents as Raw Buffer documents.\n * @param {Collection~parallelCollectionScanCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.parallelCollectionScan = deprecate(function(options, callback) {\n  if (typeof options === 'function') (callback = options), (options = { numCursors: 1 });\n  // Set number of cursors to 1\n  options.numCursors = options.numCursors || 1;\n  options.batchSize = options.batchSize || 1000;\n\n  options = Object.assign({}, options);\n  // Ensure we have the right read preference inheritance\n  options.readPreference = ReadPreference.resolve(this, options);\n\n  // Add a promiseLibrary\n  options.promiseLibrary = this.s.promiseLibrary;\n\n  if (options.session) {\n    options.session = undefined;\n  }\n\n  return executeLegacyOperation(\n    this.s.topology,\n    parallelCollectionScan,\n    [this, options, callback],\n    { skipSessions: true }\n  );\n}, 'parallelCollectionScan is deprecated in MongoDB v4.1');\n\n/**\n * Execute a geo search using a geo haystack index on a collection.\n *\n * @method\n * @param {number} x Point to search on the x axis, ensure the indexes are ordered in the same order.\n * @param {number} y Point to search on the y axis, ensure the indexes are ordered in the same order.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {number} [options.maxDistance] Include results up to maxDistance from the point.\n * @param {object} [options.search] Filter the results by a query.\n * @param {number} [options.limit=false] Max number of results to return.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated See {@link https://docs.mongodb.com/manual/geospatial-queries/|geospatial queries docs} for current geospatial support\n */\nCollection.prototype.geoHaystackSearch = deprecate(function(x, y, options, callback) {\n  const args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() || {} : {};\n\n  const geoHaystackSearchOperation = new GeoHaystackSearchOperation(this, x, y, options);\n\n  return executeOperation(this.s.topology, geoHaystackSearchOperation, callback);\n}, 'geoHaystackSearch is deprecated, and will be removed in a future version.');\n\n/**\n * Run a group command across a collection\n *\n * @method\n * @param {(object|array|function|code)} keys An object, array or function expressing the keys to group by.\n * @param {object} condition An optional condition that must be true for a row to be considered.\n * @param {object} initial Initial value of the aggregation counter object.\n * @param {(function|Code)} reduce The reduce function aggregates (reduces) the objects iterated\n * @param {(function|Code)} finalize An optional function to be run on each item in the result set just before the item is returned.\n * @param {boolean} command Specify if you wish to run using the internal group command or using eval, default is true.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @return {Promise} returns Promise if no callback passed\n * @deprecated MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.\n */\nCollection.prototype.group = deprecate(function(\n  keys,\n  condition,\n  initial,\n  reduce,\n  finalize,\n  command,\n  options,\n  callback\n) {\n  const args = Array.prototype.slice.call(arguments, 3);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  reduce = args.length ? args.shift() : null;\n  finalize = args.length ? args.shift() : null;\n  command = args.length ? args.shift() : null;\n  options = args.length ? args.shift() || {} : {};\n\n  // Make sure we are backward compatible\n  if (!(typeof finalize === 'function')) {\n    command = finalize;\n    finalize = null;\n  }\n\n  if (\n    !Array.isArray(keys) &&\n    keys instanceof Object &&\n    typeof keys !== 'function' &&\n    !(keys._bsontype === 'Code')\n  ) {\n    keys = Object.keys(keys);\n  }\n\n  if (typeof reduce === 'function') {\n    reduce = reduce.toString();\n  }\n\n  if (typeof finalize === 'function') {\n    finalize = finalize.toString();\n  }\n\n  // Set up the command as default\n  command = command == null ? true : command;\n\n  return executeLegacyOperation(this.s.topology, group, [\n    this,\n    keys,\n    condition,\n    initial,\n    reduce,\n    finalize,\n    command,\n    options,\n    callback\n  ]);\n},\n'MongoDB 3.6 or higher no longer supports the group command. We recommend rewriting using the aggregation framework.');\n\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n *\n * @method\n * @param {(function|string)} map The mapping function.\n * @param {(function|string)} reduce The reduce function.\n * @param {object} [options] Optional settings.\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\n * @param {object} [options.out] Sets the output target for the map reduce job. *{inline:1} | {replace:'collectionName'} | {merge:'collectionName'} | {reduce:'collectionName'}*\n * @param {object} [options.query] Query filter object.\n * @param {object} [options.sort] Sorts the input objects using this key. Useful for optimization, like sorting by the emit key for fewer reduces.\n * @param {number} [options.limit] Number of objects to return from collection.\n * @param {boolean} [options.keeptemp=false] Keep temporary data.\n * @param {(function|string)} [options.finalize] Finalize function.\n * @param {object} [options.scope] Can pass in variables that can be access from map/reduce/finalize.\n * @param {boolean} [options.jsMode=false] It is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X.\n * @param {boolean} [options.verbose=false] Provide statistics on job execution time.\n * @param {boolean} [options.bypassDocumentValidation=false] Allow driver to bypass schema validation in MongoDB 3.2 or higher.\n * @param {'queryPlanner'|'queryPlannerExtended'|'executionStats'|'allPlansExecution'|boolean} [options.explain] The verbosity mode for the explain output.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {Collection~resultCallback} [callback] The command result callback\n * @throws {MongoError}\n * @return {Promise} returns Promise if no callback passed\n */\nCollection.prototype.mapReduce = function(map, reduce, options, callback) {\n  if ('function' === typeof options) (callback = options), (options = {});\n  // Out must allways be defined (make sure we don't break weirdly on pre 1.8+ servers)\n  if (null == options.out) {\n    throw new Error(\n      'the out option parameter must be defined, see mongodb docs for possible values'\n    );\n  }\n\n  if ('function' === typeof map) {\n    map = map.toString();\n  }\n\n  if ('function' === typeof reduce) {\n    reduce = reduce.toString();\n  }\n\n  if ('function' === typeof options.finalize) {\n    options.finalize = options.finalize.toString();\n  }\n  const mapReduceOperation = new MapReduceOperation(this, map, reduce, options);\n\n  return executeOperation(this.s.topology, mapReduceOperation, callback);\n};\n\n/**\n * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @return {UnorderedBulkOperation}\n */\nCollection.prototype.initializeUnorderedBulkOp = function(options) {\n  options = options || {};\n  // Give function's options precedence over session options.\n  if (options.ignoreUndefined == null) {\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n\n  options.promiseLibrary = this.s.promiseLibrary;\n  return unordered(this.s.topology, this, options);\n};\n\n/**\n * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n *\n * @method\n * @param {object} [options] Optional settings.\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\n * @param {ClientSession} [options.session] optional session to use for this operation\n * @param {boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {OrderedBulkOperation} callback The command result callback\n * @return {null}\n */\nCollection.prototype.initializeOrderedBulkOp = function(options) {\n  options = options || {};\n  // Give function's options precedence over session's options.\n  if (options.ignoreUndefined == null) {\n    options.ignoreUndefined = this.s.options.ignoreUndefined;\n  }\n  options.promiseLibrary = this.s.promiseLibrary;\n  return ordered(this.s.topology, this, options);\n};\n\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\nCollection.prototype.getLogger = function() {\n  return this.s.db.s.logger;\n};\n\nmodule.exports = Collection;\n"]},"metadata":{},"sourceType":"script"}