{"ast":null,"code":"'use strict';\n\nmodule.exports = function (modules) {\n  const mc = require('bindings')('mongocrypt');\n\n  const common = require('./common');\n\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const promiseOrCallback = common.promiseOrCallback;\n  const StateMachine = modules.stateMachine.StateMachine;\n\n  const cryptoCallbacks = require('./cryptoCallbacks');\n\n  function sanitizeDataKeyOptions(bson, options) {\n    options = Object.assign({}, options); // To avoid using libbson inside the bindings, we pre-serialize\n    // any keyAltNames here.\n\n    if (options.keyAltNames) {\n      if (!Array.isArray(options.keyAltNames)) {\n        throw new TypeError(`Option \"keyAltNames\" must be an array of string, but was of type ${typeof options.keyAltNames}.`);\n      }\n\n      const serializedKeyAltNames = [];\n\n      for (let i = 0; i < options.keyAltNames.length; i += 1) {\n        const item = options.keyAltNames[i];\n        const itemType = typeof item;\n\n        if (itemType !== 'string') {\n          throw new TypeError(`Option \"keyAltNames\" must be an array of string, but item at index ${i} was of type ${itemType} `);\n        }\n\n        serializedKeyAltNames.push(bson.serialize({\n          keyAltName: item\n        }));\n      }\n\n      options.keyAltNames = serializedKeyAltNames;\n    } else if (options.keyAltNames == null) {\n      // If keyAltNames is null or undefined, we can assume the intent of\n      // the user is to not pass in the value. B/c Nan::Has will still\n      // register a value of null or undefined as present as long\n      // as the key is present, we delete it off of the options\n      // object here.\n      delete options.keyAltNames;\n    }\n\n    return options;\n  }\n  /**\n   * @typedef {object} KMSProviders\n   * @description Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [aws] Configuration options for using 'aws' as your KMS provider\n   * @property {string} [aws.accessKeyId] The access key used for the AWS KMS provider\n   * @property {string} [aws.secretAccessKey] The secret access key used for the AWS KMS provider\n   * @property {object} [local] Configuration options for using 'local' as your KMS provider\n   * @property {Buffer} [local.key] The master key used to encrypt/decrypt data keys. A 96-byte long Buffer.\n   * @property {object} [azure] Configuration options for using 'azure' as your KMS provider\n   * @property {string} [azure.tenantId] The tenant ID identifies the organization for the account\n   * @property {string} [azure.clientId] The client ID to authenticate a registered application\n   * @property {string} [azure.clientSecret] The client secret to authenticate a registered application\n   * @property {string} [azure.identityPlatformEndpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". This is optional, and only needed if customer is using a non-commercial Azure instance (e.g. a government or China account, which use different URLs). Defaults to  \"login.microsoftonline.com\"\n   * @property {object} [gcp] Configuration options for using 'gcp' as your KMS provider\n   * @property {string} [gcp.email] The service account email to authenticate\n   * @property {string|Binary} [gcp.privateKey] A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n   * @property {string} [gcp.endpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". Defaults to \"oauth2.googleapis.com\"\n   */\n\n  /**\n   * The public interface for explicit client side encryption\n   */\n\n\n  class ClientEncryption {\n    /**\n     * Create a new encryption instance\n     *\n     * @param {MongoClient} client The client used for encryption\n     * @param {object} options Additional settings\n     * @param {string} options.keyVaultNamespace The namespace of the key vault, used to store encryption keys\n     * @param {MongoClient} [options.keyVaultClient] A `MongoClient` used to fetch keys from a key vault. Defaults to `client`\n     * @param {KMSProviders} [options.kmsProviders] options for specific KMS providers to use\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     local: {\n     *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n     *     }\n     *   }\n     * });\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     aws: {\n     *       accessKeyId: AWS_ACCESS_KEY,\n     *       secretAccessKey: AWS_SECRET_KEY\n     *     }\n     *   }\n     * });\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n\n      if (options.keyVaultNamespace == null) {\n        throw new TypeError('Missing required option `keyVaultNamespace`');\n      }\n\n      Object.assign(options, {\n        cryptoCallbacks\n      }); // kmsProviders will be parsed by libmongocrypt, must be provided as BSON binary data\n\n      if (options.kmsProviders && !Buffer.isBuffer(options.kmsProviders)) {\n        options.kmsProviders = this._bson.serialize(options.kmsProviders);\n      }\n\n      this._keyVaultNamespace = options.keyVaultNamespace;\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._mongoCrypt = new mc.MongoCrypt(options);\n    }\n    /**\n     * @typedef {Binary} ClientEncryption~dataKeyId\n     * @description The id of an existing dataKey. Is a bson Binary value.\n     * Can be used for {@link ClientEncryption.encrypt}, and can be used to directly\n     * query for the data key itself against the key vault namespace.\n     */\n\n    /**\n     * @callback ClientEncryption~createDataKeyCallback\n     * @param {Error} [error] If present, indicates an error that occurred in the creation of the data key\n     * @param {ClientEncryption~dataKeyId} [dataKeyId] If present, returns the id of the created data key\n     */\n\n    /**\n     * @typedef {object} AWSEncryptionKeyOptions\n     * @description Configuration options for making an AWS encryption key\n     * @property {string} region The AWS region of the KMS\n     * @property {string} key The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n     * @property {string} [endpoint] An alternate host to send KMS requests to. May include port number\n     */\n\n    /**\n     * @typedef {object} GCPEncryptionKeyOptions\n     * @description Configuration options for making a GCP encryption key\n     * @property {string} projectId GCP project id\n     * @property {string} location Location name (e.g. \"global\")\n     * @property {string} keyRing Key ring name\n     * @property {string} keyName Key name\n     * @property {string} [keyVersion] Key version\n     * @property {string} [endpoint] KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n     */\n\n    /**\n     * @typedef {object} AzureEncryptionKeyOptions\n     * @description Configuration options for making an Azure encryption key\n     * @property {string} keyName Key name\n     * @property {string} keyVaultEndpoint Key vault URL, typically `<name>.vault.azure.net`\n     * @property {string} [keyVersion] Key version\n     */\n\n    /**\n     * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n     *\n     * @param {string} provider The KMS provider used for this data key. Must be `'aws'`, `'azure'`, `'gcp'`, or `'local'`\n     * @param {object} [options] Options for creating the data key\n     * @param {AWSEncryptionKeyOptions|AzureEncryptionKeyOptions|GCPEncryptionKeyOptions} [options.masterKey] Idenfities a new KMS-specific key used to encrypt the new data key\n     * @param {string[]} [options.keyAltNames] An optional list of string alternate names used to reference a key. If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n     * @param {ClientEncryption~createDataKeyCallback} [callback] Optional callback to invoke when key is created\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with {@link ClientEncryption~dataKeyId the id of the created data key}, or rejects with an error. If a callback is provided, returns nothing.\n     * @example\n     * // Using callbacks to create a local key\n     * clientEncryption.createDataKey('local', (err, dataKey) => {\n     *   if (err) {\n     *     // This means creating the key failed.\n     *   } else {\n     *     // key creation succeeded\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create a local key\n     * const dataKeyId = await clientEncryption.createDataKey('local');\n     *\n     * @example\n     * // Using async/await to create an aws key\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create an aws key with a keyAltName\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   },\n     *   keyAltNames: [ 'mySpecialKey' ]\n     * });\n     */\n\n\n    createDataKey(provider, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      const bson = this._bson;\n      options = sanitizeDataKeyOptions(bson, options);\n      const dataKeyBson = bson.serialize(Object.assign({\n        provider\n      }, options.masterKey));\n\n      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson);\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, dataKey) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          const dbName = databaseNamespace(this._keyVaultNamespace);\n          const collectionName = collectionNamespace(this._keyVaultNamespace);\n\n          this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {\n            w: 'majority'\n          }, (err, result) => {\n            if (err) {\n              cb(err, null);\n              return;\n            }\n\n            cb(null, result.insertedId);\n          });\n        });\n      });\n    }\n    /**\n     * @callback ClientEncryption~encryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of encryption\n     * @param {Buffer} [result] If present, is the encrypted result\n     */\n\n    /**\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param {*} value The value that you wish to serialize. Must be of a type that can be serialized into BSON\n     * @param {object} options\n     * @param {ClientEncryption~dataKeyId} [options.keyId] The id of the Binary dataKey to use for encryption\n     * @param {string} [options.keyAltName] A unique string name corresponding to an already existing dataKey.\n     * @param {} options.algorithm The algorithm to use for encryption. Must be either `'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'` or `AEAD_AES_256_CBC_HMAC_SHA_512-Random'`\n     * @param {ClientEncryption~encryptCallback} [callback] Optional callback to invoke when value is encrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the encrypted value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Encryption with callback API\n     * function encryptMyData(value, callback) {\n     *   clientEncryption.createDataKey('local', (err, keyId) => {\n     *     if (err) {\n     *       return callback(err);\n     *     }\n     *     clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' }, callback);\n     *   });\n     * }\n     *\n     * @example\n     * // Encryption with async/await api\n     * async function encryptMyData(value) {\n     *   const keyId = await clientEncryption.createDataKey('local');\n     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     *\n     * @example\n     * // Encryption using a keyAltName\n     * async function encryptMyData(value) {\n     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     */\n\n\n    encrypt(value, options, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({\n        v: value\n      });\n      const contextOptions = Object.assign({}, options);\n\n      if (options.keyId) {\n        contextOptions.keyId = options.keyId.buffer;\n      }\n\n      if (options.keyAltName) {\n        const keyAltName = options.keyAltName;\n\n        if (options.keyId) {\n          throw new TypeError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n        }\n\n        const keyAltNameType = typeof keyAltName;\n\n        if (keyAltNameType !== 'string') {\n          throw new TypeError(`\"options.keyAltName\" must be of type string, but was of type ${keyAltNameType}`);\n        }\n\n        contextOptions.keyAltName = bson.serialize({\n          keyAltName\n        });\n      }\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n\n      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n    /**\n     * @callback ClientEncryption~decryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of decryption\n     * @param {object} [result] If present, is the decrypted result\n     */\n\n    /**\n     * Explicitly decrypt a provided encrypted value\n     *\n     * @param {Buffer} value An encrypted value\n     * @param {ClientEncryption~decryptCallback} callback Optional callback to invoke when value is decrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the decryped value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Decrypting value with callback API\n     * function decryptMyValue(value, callback) {\n     *   clientEncryption.decrypt(value, callback);\n     * }\n     *\n     * @example\n     * // Decrypting value with async/await API\n     * async function decryptMyValue(value) {\n     *   return clientEncryption.decrypt(value);\n     * }\n     */\n\n\n    decrypt(value, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({\n        v: value\n      });\n\n      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n      const stateMachine = new StateMachine({\n        bson\n      });\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n\n  }\n\n  return {\n    ClientEncryption\n  };\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb-client-encryption/lib/clientEncryption.js"],"names":["module","exports","modules","mc","require","common","databaseNamespace","collectionNamespace","promiseOrCallback","StateMachine","stateMachine","cryptoCallbacks","sanitizeDataKeyOptions","bson","options","Object","assign","keyAltNames","Array","isArray","TypeError","serializedKeyAltNames","i","length","item","itemType","push","serialize","keyAltName","ClientEncryption","constructor","client","_client","_bson","topology","keyVaultNamespace","kmsProviders","Buffer","isBuffer","_keyVaultNamespace","_keyVaultClient","keyVaultClient","_mongoCrypt","MongoCrypt","createDataKey","provider","callback","dataKeyBson","masterKey","context","makeDataKeyContext","cb","execute","err","dataKey","dbName","collectionName","db","collection","insertOne","w","result","insertedId","encrypt","value","valueBuffer","v","contextOptions","keyId","buffer","keyAltNameType","makeExplicitEncryptionContext","decrypt","makeExplicitDecryptionContext"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AACjC,QAAMC,EAAE,GAAGC,OAAO,CAAC,UAAD,CAAP,CAAoB,YAApB,CAAX;;AACA,QAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,QAAME,iBAAiB,GAAGD,MAAM,CAACC,iBAAjC;AACA,QAAMC,mBAAmB,GAAGF,MAAM,CAACE,mBAAnC;AACA,QAAMC,iBAAiB,GAAGH,MAAM,CAACG,iBAAjC;AACA,QAAMC,YAAY,GAAGP,OAAO,CAACQ,YAAR,CAAqBD,YAA1C;;AACA,QAAME,eAAe,GAAGP,OAAO,CAAC,mBAAD,CAA/B;;AAEA,WAASQ,sBAAT,CAAgCC,IAAhC,EAAsCC,OAAtC,EAA+C;AAC7CA,IAAAA,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAV,CAD6C,CAG7C;AACA;;AACA,QAAIA,OAAO,CAACG,WAAZ,EAAyB;AACvB,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,OAAO,CAACG,WAAtB,CAAL,EAAyC;AACvC,cAAM,IAAIG,SAAJ,CACH,oEAAmE,OAAON,OAAO,CAACG,WAAY,GAD3F,CAAN;AAGD;;AACD,YAAMI,qBAAqB,GAAG,EAA9B;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,OAAO,CAACG,WAAR,CAAoBM,MAAxC,EAAgDD,CAAC,IAAI,CAArD,EAAwD;AACtD,cAAME,IAAI,GAAGV,OAAO,CAACG,WAAR,CAAoBK,CAApB,CAAb;AACA,cAAMG,QAAQ,GAAG,OAAOD,IAAxB;;AACA,YAAIC,QAAQ,KAAK,QAAjB,EAA2B;AACzB,gBAAM,IAAIL,SAAJ,CACH,sEAAqEE,CAAE,gBAAeG,QAAS,GAD5F,CAAN;AAGD;;AAEDJ,QAAAA,qBAAqB,CAACK,IAAtB,CAA2Bb,IAAI,CAACc,SAAL,CAAe;AAAEC,UAAAA,UAAU,EAAEJ;AAAd,SAAf,CAA3B;AACD;;AAEDV,MAAAA,OAAO,CAACG,WAAR,GAAsBI,qBAAtB;AACD,KApBD,MAoBO,IAAIP,OAAO,CAACG,WAAR,IAAuB,IAA3B,EAAiC;AACtC;AACA;AACA;AACA;AACA;AACA,aAAOH,OAAO,CAACG,WAAf;AACD;;AAED,WAAOH,OAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;;;AACE,QAAMe,gBAAN,CAAuB;AACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,IAAAA,WAAW,CAACC,MAAD,EAASjB,OAAT,EAAkB;AAC3B,WAAKkB,OAAL,GAAeD,MAAf;AACA,WAAKE,KAAL,GAAanB,OAAO,CAACD,IAAR,IAAgBkB,MAAM,CAACG,QAAP,CAAgBrB,IAA7C;;AAEA,UAAIC,OAAO,CAACqB,iBAAR,IAA6B,IAAjC,EAAuC;AACrC,cAAM,IAAIf,SAAJ,CAAc,6CAAd,CAAN;AACD;;AAEDL,MAAAA,MAAM,CAACC,MAAP,CAAcF,OAAd,EAAuB;AAAEH,QAAAA;AAAF,OAAvB,EAR2B,CAU3B;;AACA,UAAIG,OAAO,CAACsB,YAAR,IAAwB,CAACC,MAAM,CAACC,QAAP,CAAgBxB,OAAO,CAACsB,YAAxB,CAA7B,EAAoE;AAClEtB,QAAAA,OAAO,CAACsB,YAAR,GAAuB,KAAKH,KAAL,CAAWN,SAAX,CAAqBb,OAAO,CAACsB,YAA7B,CAAvB;AACD;;AAED,WAAKG,kBAAL,GAA0BzB,OAAO,CAACqB,iBAAlC;AACA,WAAKK,eAAL,GAAuB1B,OAAO,CAAC2B,cAAR,IAA0BV,MAAjD;AACA,WAAKW,WAAL,GAAmB,IAAIvC,EAAE,CAACwC,UAAP,CAAkB7B,OAAlB,CAAnB;AACD;AAED;AACJ;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI8B,IAAAA,aAAa,CAACC,QAAD,EAAW/B,OAAX,EAAoBgC,QAApB,EAA8B;AACzC,UAAI,OAAOhC,OAAP,KAAmB,UAAvB,EAAoCgC,QAAQ,GAAGhC,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;AAEnC,YAAMD,IAAI,GAAG,KAAKoB,KAAlB;AACAnB,MAAAA,OAAO,GAAGF,sBAAsB,CAACC,IAAD,EAAOC,OAAP,CAAhC;AACA,YAAMiC,WAAW,GAAGlC,IAAI,CAACc,SAAL,CAAeZ,MAAM,CAACC,MAAP,CAAc;AAAE6B,QAAAA;AAAF,OAAd,EAA4B/B,OAAO,CAACkC,SAApC,CAAf,CAApB;;AACA,YAAMC,OAAO,GAAG,KAAKP,WAAL,CAAiBQ,kBAAjB,CAAoCH,WAApC,CAAhB;;AACA,YAAMrC,YAAY,GAAG,IAAID,YAAJ,CAAiB;AAAEI,QAAAA;AAAF,OAAjB,CAArB;AAEA,aAAOL,iBAAiB,CAACsC,QAAD,EAAWK,EAAE,IAAI;AACvCzC,QAAAA,YAAY,CAAC0C,OAAb,CAAqB,IAArB,EAA2BH,OAA3B,EAAoC,CAACI,GAAD,EAAMC,OAAN,KAAkB;AACpD,cAAID,GAAJ,EAAS;AACPF,YAAAA,EAAE,CAACE,GAAD,EAAM,IAAN,CAAF;AACA;AACD;;AAED,gBAAME,MAAM,GAAGjD,iBAAiB,CAAC,KAAKiC,kBAAN,CAAhC;AACA,gBAAMiB,cAAc,GAAGjD,mBAAmB,CAAC,KAAKgC,kBAAN,CAA1C;;AAEA,eAAKC,eAAL,CACGiB,EADH,CACMF,MADN,EAEGG,UAFH,CAEcF,cAFd,EAGGG,SAHH,CAGaL,OAHb,EAGsB;AAAEM,YAAAA,CAAC,EAAE;AAAL,WAHtB,EAGyC,CAACP,GAAD,EAAMQ,MAAN,KAAiB;AACtD,gBAAIR,GAAJ,EAAS;AACPF,cAAAA,EAAE,CAACE,GAAD,EAAM,IAAN,CAAF;AACA;AACD;;AAEDF,YAAAA,EAAE,CAAC,IAAD,EAAOU,MAAM,CAACC,UAAd,CAAF;AACD,WAVH;AAWD,SApBD;AAqBD,OAtBuB,CAAxB;AAuBD;AAED;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,IAAAA,OAAO,CAACC,KAAD,EAAQlD,OAAR,EAAiBgC,QAAjB,EAA2B;AAChC,YAAMjC,IAAI,GAAG,KAAKoB,KAAlB;AACA,YAAMgC,WAAW,GAAGpD,IAAI,CAACc,SAAL,CAAe;AAAEuC,QAAAA,CAAC,EAAEF;AAAL,OAAf,CAApB;AACA,YAAMG,cAAc,GAAGpD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAvB;;AACA,UAAIA,OAAO,CAACsD,KAAZ,EAAmB;AACjBD,QAAAA,cAAc,CAACC,KAAf,GAAuBtD,OAAO,CAACsD,KAAR,CAAcC,MAArC;AACD;;AACD,UAAIvD,OAAO,CAACc,UAAZ,EAAwB;AACtB,cAAMA,UAAU,GAAGd,OAAO,CAACc,UAA3B;;AACA,YAAId,OAAO,CAACsD,KAAZ,EAAmB;AACjB,gBAAM,IAAIhD,SAAJ,CAAe,wDAAf,CAAN;AACD;;AACD,cAAMkD,cAAc,GAAG,OAAO1C,UAA9B;;AACA,YAAI0C,cAAc,KAAK,QAAvB,EAAiC;AAC/B,gBAAM,IAAIlD,SAAJ,CACH,gEAA+DkD,cAAe,EAD3E,CAAN;AAGD;;AAEDH,QAAAA,cAAc,CAACvC,UAAf,GAA4Bf,IAAI,CAACc,SAAL,CAAe;AAAEC,UAAAA;AAAF,SAAf,CAA5B;AACD;;AAED,YAAMlB,YAAY,GAAG,IAAID,YAAJ,CAAiB;AAAEI,QAAAA;AAAF,OAAjB,CAArB;;AACA,YAAMoC,OAAO,GAAG,KAAKP,WAAL,CAAiB6B,6BAAjB,CAA+CN,WAA/C,EAA4DE,cAA5D,CAAhB;;AAEA,aAAO3D,iBAAiB,CAACsC,QAAD,EAAWK,EAAE,IAAI;AACvCzC,QAAAA,YAAY,CAAC0C,OAAb,CAAqB,IAArB,EAA2BH,OAA3B,EAAoC,CAACI,GAAD,EAAMQ,MAAN,KAAiB;AACnD,cAAIR,GAAJ,EAAS;AACPF,YAAAA,EAAE,CAACE,GAAD,EAAM,IAAN,CAAF;AACA;AACD;;AAEDF,UAAAA,EAAE,CAAC,IAAD,EAAOU,MAAM,CAACK,CAAd,CAAF;AACD,SAPD;AAQD,OATuB,CAAxB;AAUD;AAED;AACJ;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIM,IAAAA,OAAO,CAACR,KAAD,EAAQlB,QAAR,EAAkB;AACvB,YAAMjC,IAAI,GAAG,KAAKoB,KAAlB;AACA,YAAMgC,WAAW,GAAGpD,IAAI,CAACc,SAAL,CAAe;AAAEuC,QAAAA,CAAC,EAAEF;AAAL,OAAf,CAApB;;AACA,YAAMf,OAAO,GAAG,KAAKP,WAAL,CAAiB+B,6BAAjB,CAA+CR,WAA/C,CAAhB;;AAEA,YAAMvD,YAAY,GAAG,IAAID,YAAJ,CAAiB;AAAEI,QAAAA;AAAF,OAAjB,CAArB;AAEA,aAAOL,iBAAiB,CAACsC,QAAD,EAAWK,EAAE,IAAI;AACvCzC,QAAAA,YAAY,CAAC0C,OAAb,CAAqB,IAArB,EAA2BH,OAA3B,EAAoC,CAACI,GAAD,EAAMQ,MAAN,KAAiB;AACnD,cAAIR,GAAJ,EAAS;AACPF,YAAAA,EAAE,CAACE,GAAD,EAAM,IAAN,CAAF;AACA;AACD;;AAEDF,UAAAA,EAAE,CAAC,IAAD,EAAOU,MAAM,CAACK,CAAd,CAAF;AACD,SAPD;AAQD,OATuB,CAAxB;AAUD;;AAjSoB;;AAoSvB,SAAO;AAAErC,IAAAA;AAAF,GAAP;AACD,CAzWD","sourcesContent":["'use strict';\n\nmodule.exports = function(modules) {\n  const mc = require('bindings')('mongocrypt');\n  const common = require('./common');\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const promiseOrCallback = common.promiseOrCallback;\n  const StateMachine = modules.stateMachine.StateMachine;\n  const cryptoCallbacks = require('./cryptoCallbacks');\n\n  function sanitizeDataKeyOptions(bson, options) {\n    options = Object.assign({}, options);\n\n    // To avoid using libbson inside the bindings, we pre-serialize\n    // any keyAltNames here.\n    if (options.keyAltNames) {\n      if (!Array.isArray(options.keyAltNames)) {\n        throw new TypeError(\n          `Option \"keyAltNames\" must be an array of string, but was of type ${typeof options.keyAltNames}.`\n        );\n      }\n      const serializedKeyAltNames = [];\n      for (let i = 0; i < options.keyAltNames.length; i += 1) {\n        const item = options.keyAltNames[i];\n        const itemType = typeof item;\n        if (itemType !== 'string') {\n          throw new TypeError(\n            `Option \"keyAltNames\" must be an array of string, but item at index ${i} was of type ${itemType} `\n          );\n        }\n\n        serializedKeyAltNames.push(bson.serialize({ keyAltName: item }));\n      }\n\n      options.keyAltNames = serializedKeyAltNames;\n    } else if (options.keyAltNames == null) {\n      // If keyAltNames is null or undefined, we can assume the intent of\n      // the user is to not pass in the value. B/c Nan::Has will still\n      // register a value of null or undefined as present as long\n      // as the key is present, we delete it off of the options\n      // object here.\n      delete options.keyAltNames;\n    }\n\n    return options;\n  }\n\n  /**\n   * @typedef {object} KMSProviders\n   * @description Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [aws] Configuration options for using 'aws' as your KMS provider\n   * @property {string} [aws.accessKeyId] The access key used for the AWS KMS provider\n   * @property {string} [aws.secretAccessKey] The secret access key used for the AWS KMS provider\n   * @property {object} [local] Configuration options for using 'local' as your KMS provider\n   * @property {Buffer} [local.key] The master key used to encrypt/decrypt data keys. A 96-byte long Buffer.\n   * @property {object} [azure] Configuration options for using 'azure' as your KMS provider\n   * @property {string} [azure.tenantId] The tenant ID identifies the organization for the account\n   * @property {string} [azure.clientId] The client ID to authenticate a registered application\n   * @property {string} [azure.clientSecret] The client secret to authenticate a registered application\n   * @property {string} [azure.identityPlatformEndpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". This is optional, and only needed if customer is using a non-commercial Azure instance (e.g. a government or China account, which use different URLs). Defaults to  \"login.microsoftonline.com\"\n   * @property {object} [gcp] Configuration options for using 'gcp' as your KMS provider\n   * @property {string} [gcp.email] The service account email to authenticate\n   * @property {string|Binary} [gcp.privateKey] A PKCS#8 encrypted key. This can either be a base64 string or a binary representation\n   * @property {string} [gcp.endpoint] If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\". Defaults to \"oauth2.googleapis.com\"\n   */\n\n  /**\n   * The public interface for explicit client side encryption\n   */\n  class ClientEncryption {\n    /**\n     * Create a new encryption instance\n     *\n     * @param {MongoClient} client The client used for encryption\n     * @param {object} options Additional settings\n     * @param {string} options.keyVaultNamespace The namespace of the key vault, used to store encryption keys\n     * @param {MongoClient} [options.keyVaultClient] A `MongoClient` used to fetch keys from a key vault. Defaults to `client`\n     * @param {KMSProviders} [options.kmsProviders] options for specific KMS providers to use\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     local: {\n     *       key: masterKey // The master key used for encryption/decryption. A 96-byte long Buffer\n     *     }\n     *   }\n     * });\n     *\n     * @example\n     * new ClientEncryption(mongoClient, {\n     *   keyVaultNamespace: 'client.encryption',\n     *   kmsProviders: {\n     *     aws: {\n     *       accessKeyId: AWS_ACCESS_KEY,\n     *       secretAccessKey: AWS_SECRET_KEY\n     *     }\n     *   }\n     * });\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n\n      if (options.keyVaultNamespace == null) {\n        throw new TypeError('Missing required option `keyVaultNamespace`');\n      }\n\n      Object.assign(options, { cryptoCallbacks });\n\n      // kmsProviders will be parsed by libmongocrypt, must be provided as BSON binary data\n      if (options.kmsProviders && !Buffer.isBuffer(options.kmsProviders)) {\n        options.kmsProviders = this._bson.serialize(options.kmsProviders);\n      }\n\n      this._keyVaultNamespace = options.keyVaultNamespace;\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._mongoCrypt = new mc.MongoCrypt(options);\n    }\n\n    /**\n     * @typedef {Binary} ClientEncryption~dataKeyId\n     * @description The id of an existing dataKey. Is a bson Binary value.\n     * Can be used for {@link ClientEncryption.encrypt}, and can be used to directly\n     * query for the data key itself against the key vault namespace.\n     */\n\n    /**\n     * @callback ClientEncryption~createDataKeyCallback\n     * @param {Error} [error] If present, indicates an error that occurred in the creation of the data key\n     * @param {ClientEncryption~dataKeyId} [dataKeyId] If present, returns the id of the created data key\n     */\n\n    /**\n     * @typedef {object} AWSEncryptionKeyOptions\n     * @description Configuration options for making an AWS encryption key\n     * @property {string} region The AWS region of the KMS\n     * @property {string} key The Amazon Resource Name (ARN) to the AWS customer master key (CMK)\n     * @property {string} [endpoint] An alternate host to send KMS requests to. May include port number\n     */\n\n    /**\n     * @typedef {object} GCPEncryptionKeyOptions\n     * @description Configuration options for making a GCP encryption key\n     * @property {string} projectId GCP project id\n     * @property {string} location Location name (e.g. \"global\")\n     * @property {string} keyRing Key ring name\n     * @property {string} keyName Key name\n     * @property {string} [keyVersion] Key version\n     * @property {string} [endpoint] KMS URL, defaults to `https://www.googleapis.com/auth/cloudkms`\n     */\n\n    /**\n     * @typedef {object} AzureEncryptionKeyOptions\n     * @description Configuration options for making an Azure encryption key\n     * @property {string} keyName Key name\n     * @property {string} keyVaultEndpoint Key vault URL, typically `<name>.vault.azure.net`\n     * @property {string} [keyVersion] Key version\n     */\n\n    /**\n     * Creates a data key used for explicit encryption and inserts it into the key vault namespace\n     *\n     * @param {string} provider The KMS provider used for this data key. Must be `'aws'`, `'azure'`, `'gcp'`, or `'local'`\n     * @param {object} [options] Options for creating the data key\n     * @param {AWSEncryptionKeyOptions|AzureEncryptionKeyOptions|GCPEncryptionKeyOptions} [options.masterKey] Idenfities a new KMS-specific key used to encrypt the new data key\n     * @param {string[]} [options.keyAltNames] An optional list of string alternate names used to reference a key. If a key is created with alternate names, then encryption may refer to the key by the unique alternate name instead of by _id.\n     * @param {ClientEncryption~createDataKeyCallback} [callback] Optional callback to invoke when key is created\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with {@link ClientEncryption~dataKeyId the id of the created data key}, or rejects with an error. If a callback is provided, returns nothing.\n     * @example\n     * // Using callbacks to create a local key\n     * clientEncryption.createDataKey('local', (err, dataKey) => {\n     *   if (err) {\n     *     // This means creating the key failed.\n     *   } else {\n     *     // key creation succeeded\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create a local key\n     * const dataKeyId = await clientEncryption.createDataKey('local');\n     *\n     * @example\n     * // Using async/await to create an aws key\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   }\n     * });\n     *\n     * @example\n     * // Using async/await to create an aws key with a keyAltName\n     * const dataKeyId = await clientEncryption.createDataKey('aws', {\n     *   masterKey: {\n     *     region: 'us-east-1',\n     *     key: 'xxxxxxxxxxxxxx' // CMK ARN here\n     *   },\n     *   keyAltNames: [ 'mySpecialKey' ]\n     * });\n     */\n    createDataKey(provider, options, callback) {\n      if (typeof options === 'function') (callback = options), (options = {});\n\n      const bson = this._bson;\n      options = sanitizeDataKeyOptions(bson, options);\n      const dataKeyBson = bson.serialize(Object.assign({ provider }, options.masterKey));\n      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson);\n      const stateMachine = new StateMachine({ bson });\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, dataKey) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          const dbName = databaseNamespace(this._keyVaultNamespace);\n          const collectionName = collectionNamespace(this._keyVaultNamespace);\n\n          this._keyVaultClient\n            .db(dbName)\n            .collection(collectionName)\n            .insertOne(dataKey, { w: 'majority' }, (err, result) => {\n              if (err) {\n                cb(err, null);\n                return;\n              }\n\n              cb(null, result.insertedId);\n            });\n        });\n      });\n    }\n\n    /**\n     * @callback ClientEncryption~encryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of encryption\n     * @param {Buffer} [result] If present, is the encrypted result\n     */\n\n    /**\n     * Explicitly encrypt a provided value. Note that either `options.keyId` or `options.keyAltName` must\n     * be specified. Specifying both `options.keyId` and `options.keyAltName` is considered an error.\n     *\n     * @param {*} value The value that you wish to serialize. Must be of a type that can be serialized into BSON\n     * @param {object} options\n     * @param {ClientEncryption~dataKeyId} [options.keyId] The id of the Binary dataKey to use for encryption\n     * @param {string} [options.keyAltName] A unique string name corresponding to an already existing dataKey.\n     * @param {} options.algorithm The algorithm to use for encryption. Must be either `'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'` or `AEAD_AES_256_CBC_HMAC_SHA_512-Random'`\n     * @param {ClientEncryption~encryptCallback} [callback] Optional callback to invoke when value is encrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the encrypted value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Encryption with callback API\n     * function encryptMyData(value, callback) {\n     *   clientEncryption.createDataKey('local', (err, keyId) => {\n     *     if (err) {\n     *       return callback(err);\n     *     }\n     *     clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' }, callback);\n     *   });\n     * }\n     *\n     * @example\n     * // Encryption with async/await api\n     * async function encryptMyData(value) {\n     *   const keyId = await clientEncryption.createDataKey('local');\n     *   return clientEncryption.encrypt(value, { keyId, algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     *\n     * @example\n     * // Encryption using a keyAltName\n     * async function encryptMyData(value) {\n     *   await clientEncryption.createDataKey('local', { keyAltNames: 'mySpecialKey' });\n     *   return clientEncryption.encrypt(value, { keyAltName: 'mySpecialKey', algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic' });\n     * }\n     */\n    encrypt(value, options, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({ v: value });\n      const contextOptions = Object.assign({}, options);\n      if (options.keyId) {\n        contextOptions.keyId = options.keyId.buffer;\n      }\n      if (options.keyAltName) {\n        const keyAltName = options.keyAltName;\n        if (options.keyId) {\n          throw new TypeError(`\"options\" cannot contain both \"keyId\" and \"keyAltName\"`);\n        }\n        const keyAltNameType = typeof keyAltName;\n        if (keyAltNameType !== 'string') {\n          throw new TypeError(\n            `\"options.keyAltName\" must be of type string, but was of type ${keyAltNameType}`\n          );\n        }\n\n        contextOptions.keyAltName = bson.serialize({ keyAltName });\n      }\n\n      const stateMachine = new StateMachine({ bson });\n      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n\n    /**\n     * @callback ClientEncryption~decryptCallback\n     * @param {Error} [err] If present, indicates an error that occurred in the process of decryption\n     * @param {object} [result] If present, is the decrypted result\n     */\n\n    /**\n     * Explicitly decrypt a provided encrypted value\n     *\n     * @param {Buffer} value An encrypted value\n     * @param {ClientEncryption~decryptCallback} callback Optional callback to invoke when value is decrypted\n     * @returns {Promise|void} If no callback is provided, returns a Promise that either resolves with the decryped value, or rejects with an error. If a callback is provided, returns nothing.\n     *\n     * @example\n     * // Decrypting value with callback API\n     * function decryptMyValue(value, callback) {\n     *   clientEncryption.decrypt(value, callback);\n     * }\n     *\n     * @example\n     * // Decrypting value with async/await API\n     * async function decryptMyValue(value) {\n     *   return clientEncryption.decrypt(value);\n     * }\n     */\n    decrypt(value, callback) {\n      const bson = this._bson;\n      const valueBuffer = bson.serialize({ v: value });\n      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);\n\n      const stateMachine = new StateMachine({ bson });\n\n      return promiseOrCallback(callback, cb => {\n        stateMachine.execute(this, context, (err, result) => {\n          if (err) {\n            cb(err, null);\n            return;\n          }\n\n          cb(null, result.v);\n        });\n      });\n    }\n  }\n\n  return { ClientEncryption };\n};\n"]},"metadata":{},"sourceType":"script"}