{"ast":null,"code":"'use strict';\n\nconst common = require('./common');\n\nconst BulkOperationBase = common.BulkOperationBase;\nconst Batch = common.Batch;\nconst bson = common.bson;\n\nconst utils = require('../utils');\n\nconst toError = utils.toError;\n/**\r\n * Add to internal list of Operations\r\n *\r\n * @ignore\r\n * @param {UnorderedBulkOperation} bulkOperation\r\n * @param {number} docType number indicating the document type\r\n * @param {object} document\r\n * @return {UnorderedBulkOperation}\r\n */\n\nfunction addToOperationsList(bulkOperation, docType, document) {\n  // Get the bsonSize\n  const bsonSize = bson.calculateObjectSize(document, {\n    checkKeys: false,\n    // Since we don't know what the user selected for BSON options here,\n    // err on the safe side, and check the size with ignoreUndefined: false.\n    ignoreUndefined: false\n  }); // Throw error if the doc is bigger than the max BSON size\n\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize) throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize); // Holds the current batch\n\n  bulkOperation.s.currentBatch = null; // Get the right type of batch\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\n  }\n\n  const maxKeySize = bulkOperation.s.maxKeySize; // Create a new batch object if we don't have a current one\n\n  if (bulkOperation.s.currentBatch == null) bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex); // Check if we need to create a new batch\n\n  if ( // New batch if we exceed the max batch op size\n  bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize || // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\n  // since we can't sent an empty batch\n  bulkOperation.s.currentBatch.size > 0 && bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= bulkOperation.s.maxBatchSizeBytes || // New batch if the new op does not have the same op type as the current batch\n  bulkOperation.s.currentBatch.batchType !== docType) {\n    // Save the batch to the execution stack\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch); // Create a new batch\n\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\n  } // We have an array of documents\n\n\n  if (Array.isArray(document)) {\n    throw toError('operation passed in cannot be an Array');\n  }\n\n  bulkOperation.s.currentBatch.operations.push(document);\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\n  bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1; // Save back the current Batch to the right type\n\n  if (docType === common.INSERT) {\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\n    bulkOperation.s.bulkResult.insertedIds.push({\n      index: bulkOperation.s.bulkResult.insertedIds.length,\n      _id: document._id\n    });\n  } else if (docType === common.UPDATE) {\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\n  } else if (docType === common.REMOVE) {\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\n  } // Update current batch size\n\n\n  bulkOperation.s.currentBatch.size += 1;\n  bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize; // Return bulkOperation\n\n  return bulkOperation;\n}\n/**\r\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\r\n * @class\r\n * @extends BulkOperationBase\r\n * @property {number} length Get the number of operations in the bulk.\r\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\r\n */\n\n\nclass UnorderedBulkOperation extends BulkOperationBase {\n  constructor(topology, collection, options) {\n    options = options || {};\n    options = Object.assign(options, {\n      addToOperationsList\n    });\n    super(topology, collection, options, false);\n  }\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.batches.length) {\n      return false;\n    }\n\n    return super.handleWriteError(callback, writeResult);\n  }\n\n}\n/**\r\n * Returns an unordered batch object\r\n * @ignore\r\n */\n\n\nfunction initializeUnorderedBulkOp(topology, collection, options) {\n  return new UnorderedBulkOperation(topology, collection, options);\n}\n\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\nmodule.exports = initializeUnorderedBulkOp;\nmodule.exports.Bulk = UnorderedBulkOperation;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/bulk/unordered.js"],"names":["common","require","BulkOperationBase","Batch","bson","utils","toError","addToOperationsList","bulkOperation","docType","document","bsonSize","calculateObjectSize","checkKeys","ignoreUndefined","s","maxBsonObjectSize","currentBatch","INSERT","currentInsertBatch","UPDATE","currentUpdateBatch","REMOVE","currentRemoveBatch","maxKeySize","currentIndex","size","maxWriteBatchSize","sizeBytes","maxBatchSizeBytes","batchType","batches","push","Array","isArray","operations","originalIndexes","bulkResult","insertedIds","index","length","_id","UnorderedBulkOperation","constructor","topology","collection","options","Object","assign","handleWriteError","callback","writeResult","initializeUnorderedBulkOp","module","exports","Bulk"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst common = require('./common');\r\nconst BulkOperationBase = common.BulkOperationBase;\r\nconst Batch = common.Batch;\r\nconst bson = common.bson;\r\nconst utils = require('../utils');\r\nconst toError = utils.toError;\r\n\r\n/**\r\n * Add to internal list of Operations\r\n *\r\n * @ignore\r\n * @param {UnorderedBulkOperation} bulkOperation\r\n * @param {number} docType number indicating the document type\r\n * @param {object} document\r\n * @return {UnorderedBulkOperation}\r\n */\r\nfunction addToOperationsList(bulkOperation, docType, document) {\r\n  // Get the bsonSize\r\n  const bsonSize = bson.calculateObjectSize(document, {\r\n    checkKeys: false,\r\n\r\n    // Since we don't know what the user selected for BSON options here,\r\n    // err on the safe side, and check the size with ignoreUndefined: false.\r\n    ignoreUndefined: false\r\n  });\r\n  // Throw error if the doc is bigger than the max BSON size\r\n  if (bsonSize >= bulkOperation.s.maxBsonObjectSize)\r\n    throw toError('document is larger than the maximum size ' + bulkOperation.s.maxBsonObjectSize);\r\n  // Holds the current batch\r\n  bulkOperation.s.currentBatch = null;\r\n  // Get the right type of batch\r\n  if (docType === common.INSERT) {\r\n    bulkOperation.s.currentBatch = bulkOperation.s.currentInsertBatch;\r\n  } else if (docType === common.UPDATE) {\r\n    bulkOperation.s.currentBatch = bulkOperation.s.currentUpdateBatch;\r\n  } else if (docType === common.REMOVE) {\r\n    bulkOperation.s.currentBatch = bulkOperation.s.currentRemoveBatch;\r\n  }\r\n\r\n  const maxKeySize = bulkOperation.s.maxKeySize;\r\n\r\n  // Create a new batch object if we don't have a current one\r\n  if (bulkOperation.s.currentBatch == null)\r\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\r\n\r\n  // Check if we need to create a new batch\r\n  if (\r\n    // New batch if we exceed the max batch op size\r\n    bulkOperation.s.currentBatch.size + 1 >= bulkOperation.s.maxWriteBatchSize ||\r\n    // New batch if we exceed the maxBatchSizeBytes. Only matters if batch already has a doc,\r\n    // since we can't sent an empty batch\r\n    (bulkOperation.s.currentBatch.size > 0 &&\r\n      bulkOperation.s.currentBatch.sizeBytes + maxKeySize + bsonSize >=\r\n        bulkOperation.s.maxBatchSizeBytes) ||\r\n    // New batch if the new op does not have the same op type as the current batch\r\n    bulkOperation.s.currentBatch.batchType !== docType\r\n  ) {\r\n    // Save the batch to the execution stack\r\n    bulkOperation.s.batches.push(bulkOperation.s.currentBatch);\r\n\r\n    // Create a new batch\r\n    bulkOperation.s.currentBatch = new Batch(docType, bulkOperation.s.currentIndex);\r\n  }\r\n\r\n  // We have an array of documents\r\n  if (Array.isArray(document)) {\r\n    throw toError('operation passed in cannot be an Array');\r\n  }\r\n\r\n  bulkOperation.s.currentBatch.operations.push(document);\r\n  bulkOperation.s.currentBatch.originalIndexes.push(bulkOperation.s.currentIndex);\r\n  bulkOperation.s.currentIndex = bulkOperation.s.currentIndex + 1;\r\n\r\n  // Save back the current Batch to the right type\r\n  if (docType === common.INSERT) {\r\n    bulkOperation.s.currentInsertBatch = bulkOperation.s.currentBatch;\r\n    bulkOperation.s.bulkResult.insertedIds.push({\r\n      index: bulkOperation.s.bulkResult.insertedIds.length,\r\n      _id: document._id\r\n    });\r\n  } else if (docType === common.UPDATE) {\r\n    bulkOperation.s.currentUpdateBatch = bulkOperation.s.currentBatch;\r\n  } else if (docType === common.REMOVE) {\r\n    bulkOperation.s.currentRemoveBatch = bulkOperation.s.currentBatch;\r\n  }\r\n\r\n  // Update current batch size\r\n  bulkOperation.s.currentBatch.size += 1;\r\n  bulkOperation.s.currentBatch.sizeBytes += maxKeySize + bsonSize;\r\n\r\n  // Return bulkOperation\r\n  return bulkOperation;\r\n}\r\n\r\n/**\r\n * Create a new UnorderedBulkOperation instance (INTERNAL TYPE, do not instantiate directly)\r\n * @class\r\n * @extends BulkOperationBase\r\n * @property {number} length Get the number of operations in the bulk.\r\n * @return {UnorderedBulkOperation} a UnorderedBulkOperation instance.\r\n */\r\nclass UnorderedBulkOperation extends BulkOperationBase {\r\n  constructor(topology, collection, options) {\r\n    options = options || {};\r\n    options = Object.assign(options, { addToOperationsList });\r\n\r\n    super(topology, collection, options, false);\r\n  }\r\n\r\n  handleWriteError(callback, writeResult) {\r\n    if (this.s.batches.length) {\r\n      return false;\r\n    }\r\n\r\n    return super.handleWriteError(callback, writeResult);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an unordered batch object\r\n * @ignore\r\n */\r\nfunction initializeUnorderedBulkOp(topology, collection, options) {\r\n  return new UnorderedBulkOperation(topology, collection, options);\r\n}\r\n\r\ninitializeUnorderedBulkOp.UnorderedBulkOperation = UnorderedBulkOperation;\r\nmodule.exports = initializeUnorderedBulkOp;\r\nmodule.exports.Bulk = UnorderedBulkOperation;\r\n"]},"metadata":{},"sourceType":"script"}