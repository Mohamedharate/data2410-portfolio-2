{"ast":null,"code":"'use strict';\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst Code = require('../core').BSON.Code;\n\nconst debugOptions = require('../utils').debugOptions;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst parseIndexOptions = require('../utils').parseIndexOptions;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CONSTANTS = require('../constants');\n\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst debugFields = ['authSource', 'w', 'wtimeout', 'j', 'native_parser', 'forceServerObjectId', 'serializeFunctions', 'raw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bufferMaxEntries', 'numberOfRetries', 'retryMiliSeconds', 'readPreference', 'pkFactory', 'parentDb', 'promiseLibrary', 'noListener'];\n/**\r\n * Creates an index on the db and collection.\r\n * @method\r\n * @param {Db} db The Db instance on which to create an index.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  let finalOptions = Object.assign({}, {\n    readPreference: ReadPreference.PRIMARY\n  }, options);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db\n  }, options); // Ensure we have a callback\n\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\n    throw MongoError.create({\n      message: 'Cannot use a writeConcern without a provided callback',\n      driver: true\n    });\n  } // Did the user destroy the topology\n\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Attempt to run using createIndexes command\n\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\n    if (err == null) return handleCallback(callback, err, result);\n    /**\r\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\r\n     * 67 = 'CannotCreateIndex' (malformed index options)\r\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\r\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\r\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\r\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\r\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\r\n     */\n\n    if (err.code === 67 || err.code === 11000 || err.code === 85 || err.code === 86 || err.code === 11600 || err.code === 197) {\n      return handleCallback(callback, err, result);\n    } // Create command\n\n\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options); // Set no key checking\n\n    finalOptions.checkKeys = false; // Insert document\n\n    db.s.topology.insert(db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION), doc, finalOptions, (err, result) => {\n      if (callback == null) return;\n      if (err) return handleCallback(callback, err);\n      if (result == null) return handleCallback(callback, null, null);\n      if (result.result.writeErrors) return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\n      handleCallback(callback, null, doc.name);\n    });\n  });\n} // Add listeners to topology\n\n\nfunction createListener(db, e, object) {\n  function listener(err) {\n    if (object.listeners(e).length > 0) {\n      object.emit(e, err, db); // Emit on all associated db's if available\n\n      for (let i = 0; i < db.s.children.length; i++) {\n        db.s.children[i].emit(e, err, db.s.children[i]);\n      }\n    }\n  }\n\n  return listener;\n}\n/**\r\n * Ensures that an index exists. If it does not, creates it.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to ensure the index.\r\n * @param {string} name The index name\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\n  // Get the write concern options\n  const finalOptions = applyWriteConcern({}, {\n    db\n  }, options); // Create command\n\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\n  const index_name = selector.name; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Merge primary readPreference\n\n  finalOptions.readPreference = ReadPreference.PRIMARY; // Check if the index already exists\n\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null); // If the index does not exist, create it\n\n    if (indexInformation == null || !indexInformation[index_name]) {\n      createIndex(db, name, fieldOrSpec, options, callback);\n    } else {\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\n    }\n  });\n}\n/**\r\n * Evaluate JavaScript on the server\r\n *\r\n * @method\r\n * @param {Db} db The Db instance.\r\n * @param {Code} code JavaScript to execute on server.\r\n * @param {(object|array)} parameters The parameters for the call.\r\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\r\n */\n\n\nfunction evaluate(db, code, parameters, options, callback) {\n  let finalCode = code;\n  let finalParameters = []; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // If not a code object translate to one\n\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode); // Ensure the parameters are correct\n\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = [parameters];\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\n    finalParameters = parameters;\n  } // Create execution selector\n\n\n  let cmd = {\n    $eval: finalCode,\n    args: finalParameters\n  }; // Check if the nolock parameter is passed in\n\n  if (options['nolock']) {\n    cmd['nolock'] = options['nolock'];\n  } // Set primary read preference\n\n\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY); // Execute the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\n    if (result) return handleCallback(callback, MongoError.create({\n      message: `eval failed: ${result.errmsg}`,\n      driver: true\n    }), null);\n    handleCallback(callback, err, result);\n  });\n}\n/**\r\n * Execute a command\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeCommand(db, command, options, callback) {\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Get the db name we are executing against\n\n  const dbName = options.dbName || options.authdb || db.databaseName; // Convert the readPreference if its not a write\n\n  options.readPreference = ReadPreference.resolve(db, options); // Debug information\n\n  if (db.s.logger.isDebug()) db.s.logger.debug(`executing command ${JSON.stringify(command)} against ${dbName}.$cmd with options [${JSON.stringify(debugOptions(debugFields, options))}]`); // Execute command\n\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\n    if (err) return handleCallback(callback, err);\n    if (options.full) return handleCallback(callback, null, result);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\r\n * Runs a command on the database as admin.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction executeDbAdminCommand(db, command, options, callback) {\n  const namespace = new MongoDBNamespace('admin', '$cmd');\n  db.s.topology.command(namespace, command, options, (err, result) => {\n    // Did the user destroy the topology\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\n      return callback(new MongoError('topology was destroyed'));\n    }\n\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, result.result);\n  });\n}\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n/**\r\n * Retrieve the current profiling information for MongoDB\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the profiling info.\r\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n * @deprecated Query the system.profile collection directly.\r\n */\n\n\nfunction profilingInfo(db, options, callback) {\n  try {\n    db.collection('system.profile').find({}, options).toArray(callback);\n  } catch (err) {\n    return callback(err, null);\n  }\n} // Validate the database name\n\n\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw MongoError.create({\n    message: 'database name must be a string',\n    driver: true\n  });\n  if (databaseName.length === 0) throw MongoError.create({\n    message: 'database name cannot be the empty string',\n    driver: true\n  });\n  if (databaseName === '$external') return;\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\n\n  for (let i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw MongoError.create({\n      message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\n      driver: true\n    });\n  }\n}\n/**\r\n * Create the command object for Db.prototype.createIndex.\r\n *\r\n * @param {Db} db The Db instance on which to create the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @return {Object} The insert command object.\r\n */\n\n\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\n  const indexParameters = parseIndexOptions(fieldOrSpec);\n  const fieldHash = indexParameters.fieldHash; // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\n  const selector = {\n    ns: db.s.namespace.withCollection(name).toString(),\n    key: fieldHash,\n    name: indexName\n  }; // Ensure we have a correct finalUnique\n\n  const finalUnique = options == null || 'object' === typeof options ? false : options; // Set up options\n\n  options = options == null || typeof options === 'boolean' ? {} : options; // Add all the options\n\n  const keysToOmit = Object.keys(selector);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      selector[optionName] = options[optionName];\n    }\n  }\n\n  if (selector['unique'] == null) selector['unique'] = finalUnique; // Remove any write concern operations\n\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\n\n  for (let i = 0; i < removeKeys.length; i++) {\n    delete selector[removeKeys[i]];\n  } // Return the command creation selector\n\n\n  return selector;\n}\n/**\r\n * Create index using the createIndexes command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n */\n\n\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\n  // Build the index\n  const indexParameters = parseIndexOptions(fieldOrSpec); // Generate the index name\n\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name; // Set up the index\n\n  const indexes = [{\n    name: indexName,\n    key: indexParameters.fieldHash\n  }]; // merge all the options\n\n  const keysToOmit = Object.keys(indexes[0]).concat(['writeConcern', 'w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session']);\n\n  for (let optionName in options) {\n    if (keysToOmit.indexOf(optionName) === -1) {\n      indexes[0][optionName] = options[optionName];\n    }\n  } // Get capabilities\n\n\n  const capabilities = db.s.topology.capabilities(); // Did the user pass in a collation, check if our write server supports it\n\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\n    // Create a new error\n    const error = new MongoError('server/primary/mongos does not support collation');\n    error.code = 67; // Return the error\n\n    return callback(error);\n  } // Create command, apply write concern to command\n\n\n  const cmd = applyWriteConcern({\n    createIndexes: name,\n    indexes\n  }, {\n    db\n  }, options); // ReadPreference primary\n\n  options.readPreference = ReadPreference.PRIMARY; // Build the command\n\n  executeCommand(db, cmd, options, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    if (result.ok === 0) return handleCallback(callback, toError(result), null); // Return the indexName for backward compatibility\n\n    handleCallback(callback, null, indexName);\n  });\n}\n\nmodule.exports = {\n  createListener,\n  createIndex,\n  ensureIndex,\n  evaluate,\n  executeCommand,\n  executeDbAdminCommand,\n  indexInformation,\n  profilingInfo,\n  validateDatabaseName\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/operations/db_ops.js"],"names":["applyWriteConcern","require","Code","BSON","debugOptions","handleCallback","MongoError","parseIndexOptions","ReadPreference","toError","CONSTANTS","MongoDBNamespace","debugFields","createIndex","db","name","fieldOrSpec","options","callback","finalOptions","Object","assign","readPreference","PRIMARY","writeConcern","create","message","driver","serverConfig","isDestroyed","createIndexUsingCreateIndexes","err","result","code","doc","createCreateIndexCommand","checkKeys","s","topology","insert","namespace","withCollection","SYSTEM_INDEX_COLLECTION","writeErrors","createListener","e","object","listener","listeners","length","emit","i","children","ensureIndex","selector","index_name","indexInformation","evaluate","parameters","finalCode","finalParameters","_bsontype","Array","isArray","cmd","$eval","args","executeCommand","ok","retval","errmsg","command","dbName","authdb","databaseName","resolve","logger","isDebug","debug","JSON","stringify","full","executeDbAdminCommand","processResults","indexes","info","index","key","push","collection","listIndexes","toArray","profilingInfo","find","validateDatabaseName","invalidChars","indexOf","indexParameters","fieldHash","indexName","ns","toString","finalUnique","keysToOmit","keys","optionName","removeKeys","concat","capabilities","collation","commandsTakeCollation","error","createIndexes","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,iBAAiB,GAAGC,OAAO,CAAC,UAAD,CAAP,CAAoBD,iBAA9C;;AACA,MAAME,IAAI,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBE,IAAnB,CAAwBD,IAArC;;AACA,MAAME,YAAY,GAAGH,OAAO,CAAC,UAAD,CAAP,CAAoBG,YAAzC;;AACA,MAAMC,cAAc,GAAGJ,OAAO,CAAC,UAAD,CAAP,CAAoBI,cAA3C;;AACA,MAAMC,UAAU,GAAGL,OAAO,CAAC,SAAD,CAAP,CAAmBK,UAAtC;;AACA,MAAMC,iBAAiB,GAAGN,OAAO,CAAC,UAAD,CAAP,CAAoBM,iBAA9C;;AACA,MAAMC,cAAc,GAAGP,OAAO,CAAC,SAAD,CAAP,CAAmBO,cAA1C;;AACA,MAAMC,OAAO,GAAGR,OAAO,CAAC,UAAD,CAAP,CAAoBQ,OAApC;;AACA,MAAMC,SAAS,GAAGT,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMU,gBAAgB,GAAGV,OAAO,CAAC,UAAD,CAAP,CAAoBU,gBAA7C;;AAEA,MAAMC,WAAW,GAAG,CAClB,YADkB,EAElB,GAFkB,EAGlB,UAHkB,EAIlB,GAJkB,EAKlB,eALkB,EAMlB,qBANkB,EAOlB,oBAPkB,EAQlB,KARkB,EASlB,cATkB,EAUlB,eAVkB,EAWlB,gBAXkB,EAYlB,kBAZkB,EAalB,iBAbkB,EAclB,kBAdkB,EAelB,gBAfkB,EAgBlB,WAhBkB,EAiBlB,UAjBkB,EAkBlB,gBAlBkB,EAmBlB,YAnBkB,CAApB;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,EAArB,EAAyBC,IAAzB,EAA+BC,WAA/B,EAA4CC,OAA5C,EAAqDC,QAArD,EAA+D;AAC7D;AACA,MAAIC,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAEC,IAAAA,cAAc,EAAEd,cAAc,CAACe;AAAjC,GAAlB,EAA8DN,OAA9D,CAAnB;AACAE,EAAAA,YAAY,GAAGnB,iBAAiB,CAACmB,YAAD,EAAe;AAAEL,IAAAA;AAAF,GAAf,EAAuBG,OAAvB,CAAhC,CAH6D,CAK7D;;AACA,MAAIE,YAAY,CAACK,YAAb,IAA6B,OAAON,QAAP,KAAoB,UAArD,EAAiE;AAC/D,UAAMZ,UAAU,CAACmB,MAAX,CAAkB;AACtBC,MAAAA,OAAO,EAAE,uDADa;AAEtBC,MAAAA,MAAM,EAAE;AAFc,KAAlB,CAAN;AAID,GAX4D,CAa7D;;;AACA,MAAIb,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EACE,OAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf,CAf2D,CAiB7D;;AACAwB,EAAAA,6BAA6B,CAAChB,EAAD,EAAKC,IAAL,EAAWC,WAAX,EAAwBG,YAAxB,EAAsC,CAACY,GAAD,EAAMC,MAAN,KAAiB;AAClF,QAAID,GAAG,IAAI,IAAX,EAAiB,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgBC,MAAhB,CAArB;AAEjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI,QACED,GAAG,CAACE,IAAJ,KAAa,EAAb,IACAF,GAAG,CAACE,IAAJ,KAAa,KADb,IAEAF,GAAG,CAACE,IAAJ,KAAa,EAFb,IAGAF,GAAG,CAACE,IAAJ,KAAa,EAHb,IAIAF,GAAG,CAACE,IAAJ,KAAa,KAJb,IAKAF,GAAG,CAACE,IAAJ,KAAa,GANf,EAOE;AACA,aAAO5B,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgBC,MAAhB,CAArB;AACD,KArBiF,CAuBlF;;;AACA,UAAME,GAAG,GAAGC,wBAAwB,CAACrB,EAAD,EAAKC,IAAL,EAAWC,WAAX,EAAwBC,OAAxB,CAApC,CAxBkF,CAyBlF;;AACAE,IAAAA,YAAY,CAACiB,SAAb,GAAyB,KAAzB,CA1BkF,CA2BlF;;AACAtB,IAAAA,EAAE,CAACuB,CAAH,CAAKC,QAAL,CAAcC,MAAd,CACEzB,EAAE,CAACuB,CAAH,CAAKG,SAAL,CAAeC,cAAf,CAA8B/B,SAAS,CAACgC,uBAAxC,CADF,EAEER,GAFF,EAGEf,YAHF,EAIE,CAACY,GAAD,EAAMC,MAAN,KAAiB;AACf,UAAId,QAAQ,IAAI,IAAhB,EAAsB;AACtB,UAAIa,GAAJ,EAAS,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,CAArB;AACT,UAAIC,MAAM,IAAI,IAAd,EAAoB,OAAO3B,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiB,IAAjB,CAArB;AACpB,UAAIc,MAAM,CAACA,MAAP,CAAcW,WAAlB,EACE,OAAOtC,cAAc,CAACa,QAAD,EAAWZ,UAAU,CAACmB,MAAX,CAAkBO,MAAM,CAACA,MAAP,CAAcW,WAAd,CAA0B,CAA1B,CAAlB,CAAX,EAA4D,IAA5D,CAArB;AACFtC,MAAAA,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBgB,GAAG,CAACnB,IAArB,CAAd;AACD,KAXH;AAaD,GAzC4B,CAA7B;AA0CD,C,CAED;;;AACA,SAAS6B,cAAT,CAAwB9B,EAAxB,EAA4B+B,CAA5B,EAA+BC,MAA/B,EAAuC;AACrC,WAASC,QAAT,CAAkBhB,GAAlB,EAAuB;AACrB,QAAIe,MAAM,CAACE,SAAP,CAAiBH,CAAjB,EAAoBI,MAApB,GAA6B,CAAjC,EAAoC;AAClCH,MAAAA,MAAM,CAACI,IAAP,CAAYL,CAAZ,EAAed,GAAf,EAAoBjB,EAApB,EADkC,CAGlC;;AACA,WAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrC,EAAE,CAACuB,CAAH,CAAKe,QAAL,CAAcH,MAAlC,EAA0CE,CAAC,EAA3C,EAA+C;AAC7CrC,QAAAA,EAAE,CAACuB,CAAH,CAAKe,QAAL,CAAcD,CAAd,EAAiBD,IAAjB,CAAsBL,CAAtB,EAAyBd,GAAzB,EAA8BjB,EAAE,CAACuB,CAAH,CAAKe,QAAL,CAAcD,CAAd,CAA9B;AACD;AACF;AACF;;AACD,SAAOJ,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,WAAT,CAAqBvC,EAArB,EAAyBC,IAAzB,EAA+BC,WAA/B,EAA4CC,OAA5C,EAAqDC,QAArD,EAA+D;AAC7D;AACA,QAAMC,YAAY,GAAGnB,iBAAiB,CAAC,EAAD,EAAK;AAAEc,IAAAA;AAAF,GAAL,EAAaG,OAAb,CAAtC,CAF6D,CAG7D;;AACA,QAAMqC,QAAQ,GAAGnB,wBAAwB,CAACrB,EAAD,EAAKC,IAAL,EAAWC,WAAX,EAAwBC,OAAxB,CAAzC;AACA,QAAMsC,UAAU,GAAGD,QAAQ,CAACvC,IAA5B,CAL6D,CAO7D;;AACA,MAAID,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EACE,OAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf,CAT2D,CAW7D;;AACAa,EAAAA,YAAY,CAACG,cAAb,GAA8Bd,cAAc,CAACe,OAA7C,CAZ6D,CAc7D;;AACAiC,EAAAA,gBAAgB,CAAC1C,EAAD,EAAKC,IAAL,EAAWI,YAAX,EAAyB,CAACY,GAAD,EAAMyB,gBAAN,KAA2B;AAClE,QAAIzB,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACE,IAAJ,KAAa,EAAhC,EAAoC,OAAO5B,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgB,IAAhB,CAArB,CAD8B,CAElE;;AACA,QAAIyB,gBAAgB,IAAI,IAApB,IAA4B,CAACA,gBAAgB,CAACD,UAAD,CAAjD,EAA+D;AAC7D1C,MAAAA,WAAW,CAACC,EAAD,EAAKC,IAAL,EAAWC,WAAX,EAAwBC,OAAxB,EAAiCC,QAAjC,CAAX;AACD,KAFD,MAEO;AACL,UAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC,OAAOb,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBqC,UAAjB,CAArB;AACrC;AACF,GARe,CAAhB;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,QAAT,CAAkB3C,EAAlB,EAAsBmB,IAAtB,EAA4ByB,UAA5B,EAAwCzC,OAAxC,EAAiDC,QAAjD,EAA2D;AACzD,MAAIyC,SAAS,GAAG1B,IAAhB;AACA,MAAI2B,eAAe,GAAG,EAAtB,CAFyD,CAIzD;;AACA,MAAI9C,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EACE,OAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf,CANuD,CAQzD;;AACA,MAAI,EAAEqD,SAAS,IAAIA,SAAS,CAACE,SAAV,KAAwB,MAAvC,CAAJ,EAAoDF,SAAS,GAAG,IAAIzD,IAAJ,CAASyD,SAAT,CAAZ,CATK,CAUzD;;AACA,MAAID,UAAU,IAAI,IAAd,IAAsB,CAACI,KAAK,CAACC,OAAN,CAAcL,UAAd,CAAvB,IAAoD,OAAOA,UAAP,KAAsB,UAA9E,EAA0F;AACxFE,IAAAA,eAAe,GAAG,CAACF,UAAD,CAAlB;AACD,GAFD,MAEO,IAAIA,UAAU,IAAI,IAAd,IAAsBI,KAAK,CAACC,OAAN,CAAcL,UAAd,CAAtB,IAAmD,OAAOA,UAAP,KAAsB,UAA7E,EAAyF;AAC9FE,IAAAA,eAAe,GAAGF,UAAlB;AACD,GAfwD,CAiBzD;;;AACA,MAAIM,GAAG,GAAG;AAAEC,IAAAA,KAAK,EAAEN,SAAT;AAAoBO,IAAAA,IAAI,EAAEN;AAA1B,GAAV,CAlByD,CAmBzD;;AACA,MAAI3C,OAAO,CAAC,QAAD,CAAX,EAAuB;AACrB+C,IAAAA,GAAG,CAAC,QAAD,CAAH,GAAgB/C,OAAO,CAAC,QAAD,CAAvB;AACD,GAtBwD,CAwBzD;;;AACAA,EAAAA,OAAO,CAACK,cAAR,GAAyB,IAAId,cAAJ,CAAmBA,cAAc,CAACe,OAAlC,CAAzB,CAzByD,CA2BzD;;AACA4C,EAAAA,cAAc,CAACrD,EAAD,EAAKkD,GAAL,EAAU/C,OAAV,EAAmB,CAACc,GAAD,EAAMC,MAAN,KAAiB;AAChD,QAAID,GAAJ,EAAS,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgB,IAAhB,CAArB;AACT,QAAIC,MAAM,IAAIA,MAAM,CAACoC,EAAP,KAAc,CAA5B,EAA+B,OAAO/D,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBc,MAAM,CAACqC,MAAxB,CAArB;AAC/B,QAAIrC,MAAJ,EACE,OAAO3B,cAAc,CACnBa,QADmB,EAEnBZ,UAAU,CAACmB,MAAX,CAAkB;AAAEC,MAAAA,OAAO,EAAG,gBAAeM,MAAM,CAACsC,MAAO,EAAzC;AAA4C3C,MAAAA,MAAM,EAAE;AAApD,KAAlB,CAFmB,EAGnB,IAHmB,CAArB;AAKFtB,IAAAA,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgBC,MAAhB,CAAd;AACD,GAVa,CAAd;AAWD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASmC,cAAT,CAAwBrD,EAAxB,EAA4ByD,OAA5B,EAAqCtD,OAArC,EAA8CC,QAA9C,EAAwD;AACtD;AACA,MAAIJ,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EACE,OAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf,CAHoD,CAItD;;AACA,QAAMkE,MAAM,GAAGvD,OAAO,CAACuD,MAAR,IAAkBvD,OAAO,CAACwD,MAA1B,IAAoC3D,EAAE,CAAC4D,YAAtD,CALsD,CAOtD;;AACAzD,EAAAA,OAAO,CAACK,cAAR,GAAyBd,cAAc,CAACmE,OAAf,CAAuB7D,EAAvB,EAA2BG,OAA3B,CAAzB,CARsD,CAUtD;;AACA,MAAIH,EAAE,CAACuB,CAAH,CAAKuC,MAAL,CAAYC,OAAZ,EAAJ,EACE/D,EAAE,CAACuB,CAAH,CAAKuC,MAAL,CAAYE,KAAZ,CACG,qBAAoBC,IAAI,CAACC,SAAL,CACnBT,OADmB,CAEnB,YAAWC,MAAO,uBAAsBO,IAAI,CAACC,SAAL,CACxC5E,YAAY,CAACQ,WAAD,EAAcK,OAAd,CAD4B,CAExC,GALJ,EAZoD,CAoBtD;;AACAH,EAAAA,EAAE,CAACuB,CAAH,CAAKC,QAAL,CAAciC,OAAd,CAAsBzD,EAAE,CAACuB,CAAH,CAAKG,SAAL,CAAeC,cAAf,CAA8B,MAA9B,CAAtB,EAA6D8B,OAA7D,EAAsEtD,OAAtE,EAA+E,CAACc,GAAD,EAAMC,MAAN,KAAiB;AAC9F,QAAID,GAAJ,EAAS,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,CAArB;AACT,QAAId,OAAO,CAACgE,IAAZ,EAAkB,OAAO5E,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBc,MAAjB,CAArB;AAClB3B,IAAAA,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBc,MAAM,CAACA,MAAxB,CAAd;AACD,GAJD;AAKD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkD,qBAAT,CAA+BpE,EAA/B,EAAmCyD,OAAnC,EAA4CtD,OAA5C,EAAqDC,QAArD,EAA+D;AAC7D,QAAMsB,SAAS,GAAG,IAAI7B,gBAAJ,CAAqB,OAArB,EAA8B,MAA9B,CAAlB;AAEAG,EAAAA,EAAE,CAACuB,CAAH,CAAKC,QAAL,CAAciC,OAAd,CAAsB/B,SAAtB,EAAiC+B,OAAjC,EAA0CtD,OAA1C,EAAmD,CAACc,GAAD,EAAMC,MAAN,KAAiB;AAClE;AACA,QAAIlB,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EAAsD;AACpD,aAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf;AACD;;AAED,QAAIyB,GAAJ,EAAS,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,CAArB;AACT1B,IAAAA,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBc,MAAM,CAACA,MAAxB,CAAd;AACD,GARD;AASD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwB,gBAAT,CAA0B1C,EAA1B,EAA8BC,IAA9B,EAAoCE,OAApC,EAA6CC,QAA7C,EAAuD;AACrD;AACA,QAAM+D,IAAI,GAAGhE,OAAO,CAAC,MAAD,CAAP,IAAmB,IAAnB,GAA0B,KAA1B,GAAkCA,OAAO,CAAC,MAAD,CAAtD,CAFqD,CAIrD;;AACA,MAAIH,EAAE,CAACc,YAAH,IAAmBd,EAAE,CAACc,YAAH,CAAgBC,WAAhB,EAAvB,EACE,OAAOX,QAAQ,CAAC,IAAIZ,UAAJ,CAAe,wBAAf,CAAD,CAAf,CANmD,CAOrD;;AACA,WAAS6E,cAAT,CAAwBC,OAAxB,EAAiC;AAC/B;AACA,QAAIC,IAAI,GAAG,EAAX,CAF+B,CAG/B;;AACA,SAAK,IAAIlC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiC,OAAO,CAACnC,MAA5B,EAAoCE,CAAC,EAArC,EAAyC;AACvC,YAAMmC,KAAK,GAAGF,OAAO,CAACjC,CAAD,CAArB,CADuC,CAEvC;;AACAkC,MAAAA,IAAI,CAACC,KAAK,CAACvE,IAAP,CAAJ,GAAmB,EAAnB;;AACA,WAAK,IAAIA,IAAT,IAAiBuE,KAAK,CAACC,GAAvB,EAA4B;AAC1BF,QAAAA,IAAI,CAACC,KAAK,CAACvE,IAAP,CAAJ,CAAiByE,IAAjB,CAAsB,CAACzE,IAAD,EAAOuE,KAAK,CAACC,GAAN,CAAUxE,IAAV,CAAP,CAAtB;AACD;AACF;;AAED,WAAOsE,IAAP;AACD,GAtBoD,CAwBrD;;;AACAvE,EAAAA,EAAE,CAAC2E,UAAH,CAAc1E,IAAd,EACG2E,WADH,CACezE,OADf,EAEG0E,OAFH,CAEW,CAAC5D,GAAD,EAAMqD,OAAN,KAAkB;AACzB,QAAIrD,GAAJ,EAAS,OAAOb,QAAQ,CAACT,OAAO,CAACsB,GAAD,CAAR,CAAf;AACT,QAAI,CAAC+B,KAAK,CAACC,OAAN,CAAcqB,OAAd,CAAL,EAA6B,OAAO/E,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiB,EAAjB,CAArB;AAC7B,QAAI+D,IAAJ,EAAU,OAAO5E,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBkE,OAAjB,CAArB;AACV/E,IAAAA,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBiE,cAAc,CAACC,OAAD,CAA/B,CAAd;AACD,GAPH;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,aAAT,CAAuB9E,EAAvB,EAA2BG,OAA3B,EAAoCC,QAApC,EAA8C;AAC5C,MAAI;AACFJ,IAAAA,EAAE,CAAC2E,UAAH,CAAc,gBAAd,EACGI,IADH,CACQ,EADR,EACY5E,OADZ,EAEG0E,OAFH,CAEWzE,QAFX;AAGD,GAJD,CAIE,OAAOa,GAAP,EAAY;AACZ,WAAOb,QAAQ,CAACa,GAAD,EAAM,IAAN,CAAf;AACD;AACF,C,CAED;;;AACA,SAAS+D,oBAAT,CAA8BpB,YAA9B,EAA4C;AAC1C,MAAI,OAAOA,YAAP,KAAwB,QAA5B,EACE,MAAMpE,UAAU,CAACmB,MAAX,CAAkB;AAAEC,IAAAA,OAAO,EAAE,gCAAX;AAA6CC,IAAAA,MAAM,EAAE;AAArD,GAAlB,CAAN;AACF,MAAI+C,YAAY,CAACzB,MAAb,KAAwB,CAA5B,EACE,MAAM3C,UAAU,CAACmB,MAAX,CAAkB;AAAEC,IAAAA,OAAO,EAAE,0CAAX;AAAuDC,IAAAA,MAAM,EAAE;AAA/D,GAAlB,CAAN;AACF,MAAI+C,YAAY,KAAK,WAArB,EAAkC;AAElC,QAAMqB,YAAY,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,IAArB,CAArB;;AACA,OAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4C,YAAY,CAAC9C,MAAjC,EAAyCE,CAAC,EAA1C,EAA8C;AAC5C,QAAIuB,YAAY,CAACsB,OAAb,CAAqBD,YAAY,CAAC5C,CAAD,CAAjC,MAA0C,CAAC,CAA/C,EACE,MAAM7C,UAAU,CAACmB,MAAX,CAAkB;AACtBC,MAAAA,OAAO,EAAE,kDAAkDqE,YAAY,CAAC5C,CAAD,CAA9D,GAAoE,GADvD;AAEtBxB,MAAAA,MAAM,EAAE;AAFc,KAAlB,CAAN;AAIH;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,wBAAT,CAAkCrB,EAAlC,EAAsCC,IAAtC,EAA4CC,WAA5C,EAAyDC,OAAzD,EAAkE;AAChE,QAAMgF,eAAe,GAAG1F,iBAAiB,CAACS,WAAD,CAAzC;AACA,QAAMkF,SAAS,GAAGD,eAAe,CAACC,SAAlC,CAFgE,CAIhE;;AACA,QAAMC,SAAS,GAAG,OAAOlF,OAAO,CAACF,IAAf,KAAwB,QAAxB,GAAmCE,OAAO,CAACF,IAA3C,GAAkDkF,eAAe,CAAClF,IAApF;AACA,QAAMuC,QAAQ,GAAG;AACf8C,IAAAA,EAAE,EAAEtF,EAAE,CAACuB,CAAH,CAAKG,SAAL,CAAeC,cAAf,CAA8B1B,IAA9B,EAAoCsF,QAApC,EADW;AAEfd,IAAAA,GAAG,EAAEW,SAFU;AAGfnF,IAAAA,IAAI,EAAEoF;AAHS,GAAjB,CANgE,CAYhE;;AACA,QAAMG,WAAW,GAAGrF,OAAO,IAAI,IAAX,IAAmB,aAAa,OAAOA,OAAvC,GAAiD,KAAjD,GAAyDA,OAA7E,CAbgE,CAchE;;AACAA,EAAAA,OAAO,GAAGA,OAAO,IAAI,IAAX,IAAmB,OAAOA,OAAP,KAAmB,SAAtC,GAAkD,EAAlD,GAAuDA,OAAjE,CAfgE,CAiBhE;;AACA,QAAMsF,UAAU,GAAGnF,MAAM,CAACoF,IAAP,CAAYlD,QAAZ,CAAnB;;AACA,OAAK,IAAImD,UAAT,IAAuBxF,OAAvB,EAAgC;AAC9B,QAAIsF,UAAU,CAACP,OAAX,CAAmBS,UAAnB,MAAmC,CAAC,CAAxC,EAA2C;AACzCnD,MAAAA,QAAQ,CAACmD,UAAD,CAAR,GAAuBxF,OAAO,CAACwF,UAAD,CAA9B;AACD;AACF;;AAED,MAAInD,QAAQ,CAAC,QAAD,CAAR,IAAsB,IAA1B,EAAgCA,QAAQ,CAAC,QAAD,CAAR,GAAqBgD,WAArB,CAzBgC,CA2BhE;;AACA,QAAMI,UAAU,GAAG,CAAC,GAAD,EAAM,UAAN,EAAkB,GAAlB,EAAuB,OAAvB,EAAgC,gBAAhC,EAAkD,SAAlD,CAAnB;;AACA,OAAK,IAAIvD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuD,UAAU,CAACzD,MAA/B,EAAuCE,CAAC,EAAxC,EAA4C;AAC1C,WAAOG,QAAQ,CAACoD,UAAU,CAACvD,CAAD,CAAX,CAAf;AACD,GA/B+D,CAiChE;;;AACA,SAAOG,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASxB,6BAAT,CAAuChB,EAAvC,EAA2CC,IAA3C,EAAiDC,WAAjD,EAA8DC,OAA9D,EAAuEC,QAAvE,EAAiF;AAC/E;AACA,QAAM+E,eAAe,GAAG1F,iBAAiB,CAACS,WAAD,CAAzC,CAF+E,CAG/E;;AACA,QAAMmF,SAAS,GAAG,OAAOlF,OAAO,CAACF,IAAf,KAAwB,QAAxB,GAAmCE,OAAO,CAACF,IAA3C,GAAkDkF,eAAe,CAAClF,IAApF,CAJ+E,CAK/E;;AACA,QAAMqE,OAAO,GAAG,CAAC;AAAErE,IAAAA,IAAI,EAAEoF,SAAR;AAAmBZ,IAAAA,GAAG,EAAEU,eAAe,CAACC;AAAxC,GAAD,CAAhB,CAN+E,CAO/E;;AACA,QAAMK,UAAU,GAAGnF,MAAM,CAACoF,IAAP,CAAYpB,OAAO,CAAC,CAAD,CAAnB,EAAwBuB,MAAxB,CAA+B,CAChD,cADgD,EAEhD,GAFgD,EAGhD,UAHgD,EAIhD,GAJgD,EAKhD,OALgD,EAMhD,gBANgD,EAOhD,SAPgD,CAA/B,CAAnB;;AAUA,OAAK,IAAIF,UAAT,IAAuBxF,OAAvB,EAAgC;AAC9B,QAAIsF,UAAU,CAACP,OAAX,CAAmBS,UAAnB,MAAmC,CAAC,CAAxC,EAA2C;AACzCrB,MAAAA,OAAO,CAAC,CAAD,CAAP,CAAWqB,UAAX,IAAyBxF,OAAO,CAACwF,UAAD,CAAhC;AACD;AACF,GAtB8E,CAwB/E;;;AACA,QAAMG,YAAY,GAAG9F,EAAE,CAACuB,CAAH,CAAKC,QAAL,CAAcsE,YAAd,EAArB,CAzB+E,CA2B/E;;AACA,MAAIxB,OAAO,CAAC,CAAD,CAAP,CAAWyB,SAAX,IAAwBD,YAAxB,IAAwC,CAACA,YAAY,CAACE,qBAA1D,EAAiF;AAC/E;AACA,UAAMC,KAAK,GAAG,IAAIzG,UAAJ,CAAe,kDAAf,CAAd;AACAyG,IAAAA,KAAK,CAAC9E,IAAN,GAAa,EAAb,CAH+E,CAI/E;;AACA,WAAOf,QAAQ,CAAC6F,KAAD,CAAf;AACD,GAlC8E,CAoC/E;;;AACA,QAAM/C,GAAG,GAAGhE,iBAAiB,CAAC;AAAEgH,IAAAA,aAAa,EAAEjG,IAAjB;AAAuBqE,IAAAA;AAAvB,GAAD,EAAmC;AAAEtE,IAAAA;AAAF,GAAnC,EAA2CG,OAA3C,CAA7B,CArC+E,CAuC/E;;AACAA,EAAAA,OAAO,CAACK,cAAR,GAAyBd,cAAc,CAACe,OAAxC,CAxC+E,CA0C/E;;AACA4C,EAAAA,cAAc,CAACrD,EAAD,EAAKkD,GAAL,EAAU/C,OAAV,EAAmB,CAACc,GAAD,EAAMC,MAAN,KAAiB;AAChD,QAAID,GAAJ,EAAS,OAAO1B,cAAc,CAACa,QAAD,EAAWa,GAAX,EAAgB,IAAhB,CAArB;AACT,QAAIC,MAAM,CAACoC,EAAP,KAAc,CAAlB,EAAqB,OAAO/D,cAAc,CAACa,QAAD,EAAWT,OAAO,CAACuB,MAAD,CAAlB,EAA4B,IAA5B,CAArB,CAF2B,CAGhD;;AACA3B,IAAAA,cAAc,CAACa,QAAD,EAAW,IAAX,EAAiBiF,SAAjB,CAAd;AACD,GALa,CAAd;AAMD;;AAEDc,MAAM,CAACC,OAAP,GAAiB;AACftE,EAAAA,cADe;AAEf/B,EAAAA,WAFe;AAGfwC,EAAAA,WAHe;AAIfI,EAAAA,QAJe;AAKfU,EAAAA,cALe;AAMfe,EAAAA,qBANe;AAOf1B,EAAAA,gBAPe;AAQfoC,EAAAA,aARe;AASfE,EAAAA;AATe,CAAjB","sourcesContent":["'use strict';\r\n\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst Code = require('../core').BSON.Code;\r\nconst debugOptions = require('../utils').debugOptions;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst MongoError = require('../core').MongoError;\r\nconst parseIndexOptions = require('../utils').parseIndexOptions;\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst toError = require('../utils').toError;\r\nconst CONSTANTS = require('../constants');\r\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\r\n\r\nconst debugFields = [\r\n  'authSource',\r\n  'w',\r\n  'wtimeout',\r\n  'j',\r\n  'native_parser',\r\n  'forceServerObjectId',\r\n  'serializeFunctions',\r\n  'raw',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'bufferMaxEntries',\r\n  'numberOfRetries',\r\n  'retryMiliSeconds',\r\n  'readPreference',\r\n  'pkFactory',\r\n  'parentDb',\r\n  'promiseLibrary',\r\n  'noListener'\r\n];\r\n\r\n/**\r\n * Creates an index on the db and collection.\r\n * @method\r\n * @param {Db} db The Db instance on which to create an index.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction createIndex(db, name, fieldOrSpec, options, callback) {\r\n  // Get the write concern options\r\n  let finalOptions = Object.assign({}, { readPreference: ReadPreference.PRIMARY }, options);\r\n  finalOptions = applyWriteConcern(finalOptions, { db }, options);\r\n\r\n  // Ensure we have a callback\r\n  if (finalOptions.writeConcern && typeof callback !== 'function') {\r\n    throw MongoError.create({\r\n      message: 'Cannot use a writeConcern without a provided callback',\r\n      driver: true\r\n    });\r\n  }\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // Attempt to run using createIndexes command\r\n  createIndexUsingCreateIndexes(db, name, fieldOrSpec, finalOptions, (err, result) => {\r\n    if (err == null) return handleCallback(callback, err, result);\r\n\r\n    /**\r\n     * The following errors mean that the server recognized `createIndex` as a command so we don't need to fallback to an insert:\r\n     * 67 = 'CannotCreateIndex' (malformed index options)\r\n     * 85 = 'IndexOptionsConflict' (index already exists with different options)\r\n     * 86 = 'IndexKeySpecsConflict' (index already exists with the same name)\r\n     * 11000 = 'DuplicateKey' (couldn't build unique index because of dupes)\r\n     * 11600 = 'InterruptedAtShutdown' (interrupted at shutdown)\r\n     * 197 = 'InvalidIndexSpecificationOption' (`_id` with `background: true`)\r\n     */\r\n    if (\r\n      err.code === 67 ||\r\n      err.code === 11000 ||\r\n      err.code === 85 ||\r\n      err.code === 86 ||\r\n      err.code === 11600 ||\r\n      err.code === 197\r\n    ) {\r\n      return handleCallback(callback, err, result);\r\n    }\r\n\r\n    // Create command\r\n    const doc = createCreateIndexCommand(db, name, fieldOrSpec, options);\r\n    // Set no key checking\r\n    finalOptions.checkKeys = false;\r\n    // Insert document\r\n    db.s.topology.insert(\r\n      db.s.namespace.withCollection(CONSTANTS.SYSTEM_INDEX_COLLECTION),\r\n      doc,\r\n      finalOptions,\r\n      (err, result) => {\r\n        if (callback == null) return;\r\n        if (err) return handleCallback(callback, err);\r\n        if (result == null) return handleCallback(callback, null, null);\r\n        if (result.result.writeErrors)\r\n          return handleCallback(callback, MongoError.create(result.result.writeErrors[0]), null);\r\n        handleCallback(callback, null, doc.name);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// Add listeners to topology\r\nfunction createListener(db, e, object) {\r\n  function listener(err) {\r\n    if (object.listeners(e).length > 0) {\r\n      object.emit(e, err, db);\r\n\r\n      // Emit on all associated db's if available\r\n      for (let i = 0; i < db.s.children.length; i++) {\r\n        db.s.children[i].emit(e, err, db.s.children[i]);\r\n      }\r\n    }\r\n  }\r\n  return listener;\r\n}\r\n\r\n/**\r\n * Ensures that an index exists. If it does not, creates it.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to ensure the index.\r\n * @param {string} name The index name\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {object} [options] Optional settings. See Db.prototype.ensureIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction ensureIndex(db, name, fieldOrSpec, options, callback) {\r\n  // Get the write concern options\r\n  const finalOptions = applyWriteConcern({}, { db }, options);\r\n  // Create command\r\n  const selector = createCreateIndexCommand(db, name, fieldOrSpec, options);\r\n  const index_name = selector.name;\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // Merge primary readPreference\r\n  finalOptions.readPreference = ReadPreference.PRIMARY;\r\n\r\n  // Check if the index already exists\r\n  indexInformation(db, name, finalOptions, (err, indexInformation) => {\r\n    if (err != null && err.code !== 26) return handleCallback(callback, err, null);\r\n    // If the index does not exist, create it\r\n    if (indexInformation == null || !indexInformation[index_name]) {\r\n      createIndex(db, name, fieldOrSpec, options, callback);\r\n    } else {\r\n      if (typeof callback === 'function') return handleCallback(callback, null, index_name);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Evaluate JavaScript on the server\r\n *\r\n * @method\r\n * @param {Db} db The Db instance.\r\n * @param {Code} code JavaScript to execute on server.\r\n * @param {(object|array)} parameters The parameters for the call.\r\n * @param {object} [options] Optional settings. See Db.prototype.eval for a list of options.\r\n * @param {Db~resultCallback} [callback] The results callback\r\n * @deprecated Eval is deprecated on MongoDB 3.2 and forward\r\n */\r\nfunction evaluate(db, code, parameters, options, callback) {\r\n  let finalCode = code;\r\n  let finalParameters = [];\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n\r\n  // If not a code object translate to one\r\n  if (!(finalCode && finalCode._bsontype === 'Code')) finalCode = new Code(finalCode);\r\n  // Ensure the parameters are correct\r\n  if (parameters != null && !Array.isArray(parameters) && typeof parameters !== 'function') {\r\n    finalParameters = [parameters];\r\n  } else if (parameters != null && Array.isArray(parameters) && typeof parameters !== 'function') {\r\n    finalParameters = parameters;\r\n  }\r\n\r\n  // Create execution selector\r\n  let cmd = { $eval: finalCode, args: finalParameters };\r\n  // Check if the nolock parameter is passed in\r\n  if (options['nolock']) {\r\n    cmd['nolock'] = options['nolock'];\r\n  }\r\n\r\n  // Set primary read preference\r\n  options.readPreference = new ReadPreference(ReadPreference.PRIMARY);\r\n\r\n  // Execute the command\r\n  executeCommand(db, cmd, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result && result.ok === 1) return handleCallback(callback, null, result.retval);\r\n    if (result)\r\n      return handleCallback(\r\n        callback,\r\n        MongoError.create({ message: `eval failed: ${result.errmsg}`, driver: true }),\r\n        null\r\n      );\r\n    handleCallback(callback, err, result);\r\n  });\r\n}\r\n\r\n/**\r\n * Execute a command\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.command for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeCommand(db, command, options, callback) {\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Get the db name we are executing against\r\n  const dbName = options.dbName || options.authdb || db.databaseName;\r\n\r\n  // Convert the readPreference if its not a write\r\n  options.readPreference = ReadPreference.resolve(db, options);\r\n\r\n  // Debug information\r\n  if (db.s.logger.isDebug())\r\n    db.s.logger.debug(\r\n      `executing command ${JSON.stringify(\r\n        command\r\n      )} against ${dbName}.$cmd with options [${JSON.stringify(\r\n        debugOptions(debugFields, options)\r\n      )}]`\r\n    );\r\n\r\n  // Execute command\r\n  db.s.topology.command(db.s.namespace.withCollection('$cmd'), command, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err);\r\n    if (options.full) return handleCallback(callback, null, result);\r\n    handleCallback(callback, null, result.result);\r\n  });\r\n}\r\n\r\n/**\r\n * Runs a command on the database as admin.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {object} command The command hash\r\n * @param {object} [options] Optional settings. See Db.prototype.executeDbAdminCommand for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction executeDbAdminCommand(db, command, options, callback) {\r\n  const namespace = new MongoDBNamespace('admin', '$cmd');\r\n\r\n  db.s.topology.command(namespace, command, options, (err, result) => {\r\n    // Did the user destroy the topology\r\n    if (db.serverConfig && db.serverConfig.isDestroyed()) {\r\n      return callback(new MongoError('topology was destroyed'));\r\n    }\r\n\r\n    if (err) return handleCallback(callback, err);\r\n    handleCallback(callback, null, result.result);\r\n  });\r\n}\r\n\r\n/**\r\n * Retrieves this collections index info.\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the index info.\r\n * @param {string} name The name of the collection.\r\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback\r\n */\r\nfunction indexInformation(db, name, options, callback) {\r\n  // If we specified full information\r\n  const full = options['full'] == null ? false : options['full'];\r\n\r\n  // Did the user destroy the topology\r\n  if (db.serverConfig && db.serverConfig.isDestroyed())\r\n    return callback(new MongoError('topology was destroyed'));\r\n  // Process all the results from the index command and collection\r\n  function processResults(indexes) {\r\n    // Contains all the information\r\n    let info = {};\r\n    // Process all the indexes\r\n    for (let i = 0; i < indexes.length; i++) {\r\n      const index = indexes[i];\r\n      // Let's unpack the object\r\n      info[index.name] = [];\r\n      for (let name in index.key) {\r\n        info[index.name].push([name, index.key[name]]);\r\n      }\r\n    }\r\n\r\n    return info;\r\n  }\r\n\r\n  // Get the list of indexes of the specified collection\r\n  db.collection(name)\r\n    .listIndexes(options)\r\n    .toArray((err, indexes) => {\r\n      if (err) return callback(toError(err));\r\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\r\n      if (full) return handleCallback(callback, null, indexes);\r\n      handleCallback(callback, null, processResults(indexes));\r\n    });\r\n}\r\n\r\n/**\r\n * Retrieve the current profiling information for MongoDB\r\n *\r\n * @method\r\n * @param {Db} db The Db instance on which to retrieve the profiling info.\r\n * @param {Object} [options] Optional settings. See Db.protoype.profilingInfo for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n * @deprecated Query the system.profile collection directly.\r\n */\r\nfunction profilingInfo(db, options, callback) {\r\n  try {\r\n    db.collection('system.profile')\r\n      .find({}, options)\r\n      .toArray(callback);\r\n  } catch (err) {\r\n    return callback(err, null);\r\n  }\r\n}\r\n\r\n// Validate the database name\r\nfunction validateDatabaseName(databaseName) {\r\n  if (typeof databaseName !== 'string')\r\n    throw MongoError.create({ message: 'database name must be a string', driver: true });\r\n  if (databaseName.length === 0)\r\n    throw MongoError.create({ message: 'database name cannot be the empty string', driver: true });\r\n  if (databaseName === '$external') return;\r\n\r\n  const invalidChars = [' ', '.', '$', '/', '\\\\'];\r\n  for (let i = 0; i < invalidChars.length; i++) {\r\n    if (databaseName.indexOf(invalidChars[i]) !== -1)\r\n      throw MongoError.create({\r\n        message: \"database names cannot contain the character '\" + invalidChars[i] + \"'\",\r\n        driver: true\r\n      });\r\n  }\r\n}\r\n\r\n/**\r\n * Create the command object for Db.prototype.createIndex.\r\n *\r\n * @param {Db} db The Db instance on which to create the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @return {Object} The insert command object.\r\n */\r\nfunction createCreateIndexCommand(db, name, fieldOrSpec, options) {\r\n  const indexParameters = parseIndexOptions(fieldOrSpec);\r\n  const fieldHash = indexParameters.fieldHash;\r\n\r\n  // Generate the index name\r\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\r\n  const selector = {\r\n    ns: db.s.namespace.withCollection(name).toString(),\r\n    key: fieldHash,\r\n    name: indexName\r\n  };\r\n\r\n  // Ensure we have a correct finalUnique\r\n  const finalUnique = options == null || 'object' === typeof options ? false : options;\r\n  // Set up options\r\n  options = options == null || typeof options === 'boolean' ? {} : options;\r\n\r\n  // Add all the options\r\n  const keysToOmit = Object.keys(selector);\r\n  for (let optionName in options) {\r\n    if (keysToOmit.indexOf(optionName) === -1) {\r\n      selector[optionName] = options[optionName];\r\n    }\r\n  }\r\n\r\n  if (selector['unique'] == null) selector['unique'] = finalUnique;\r\n\r\n  // Remove any write concern operations\r\n  const removeKeys = ['w', 'wtimeout', 'j', 'fsync', 'readPreference', 'session'];\r\n  for (let i = 0; i < removeKeys.length; i++) {\r\n    delete selector[removeKeys[i]];\r\n  }\r\n\r\n  // Return the command creation selector\r\n  return selector;\r\n}\r\n\r\n/**\r\n * Create index using the createIndexes command.\r\n *\r\n * @param {Db} db The Db instance on which to execute the command.\r\n * @param {string} name Name of the collection to create the index on.\r\n * @param {(string|object)} fieldOrSpec Defines the index.\r\n * @param {Object} [options] Optional settings. See Db.prototype.createIndex for a list of options.\r\n * @param {Db~resultCallback} [callback] The command result callback.\r\n */\r\nfunction createIndexUsingCreateIndexes(db, name, fieldOrSpec, options, callback) {\r\n  // Build the index\r\n  const indexParameters = parseIndexOptions(fieldOrSpec);\r\n  // Generate the index name\r\n  const indexName = typeof options.name === 'string' ? options.name : indexParameters.name;\r\n  // Set up the index\r\n  const indexes = [{ name: indexName, key: indexParameters.fieldHash }];\r\n  // merge all the options\r\n  const keysToOmit = Object.keys(indexes[0]).concat([\r\n    'writeConcern',\r\n    'w',\r\n    'wtimeout',\r\n    'j',\r\n    'fsync',\r\n    'readPreference',\r\n    'session'\r\n  ]);\r\n\r\n  for (let optionName in options) {\r\n    if (keysToOmit.indexOf(optionName) === -1) {\r\n      indexes[0][optionName] = options[optionName];\r\n    }\r\n  }\r\n\r\n  // Get capabilities\r\n  const capabilities = db.s.topology.capabilities();\r\n\r\n  // Did the user pass in a collation, check if our write server supports it\r\n  if (indexes[0].collation && capabilities && !capabilities.commandsTakeCollation) {\r\n    // Create a new error\r\n    const error = new MongoError('server/primary/mongos does not support collation');\r\n    error.code = 67;\r\n    // Return the error\r\n    return callback(error);\r\n  }\r\n\r\n  // Create command, apply write concern to command\r\n  const cmd = applyWriteConcern({ createIndexes: name, indexes }, { db }, options);\r\n\r\n  // ReadPreference primary\r\n  options.readPreference = ReadPreference.PRIMARY;\r\n\r\n  // Build the command\r\n  executeCommand(db, cmd, options, (err, result) => {\r\n    if (err) return handleCallback(callback, err, null);\r\n    if (result.ok === 0) return handleCallback(callback, toError(result), null);\r\n    // Return the indexName for backward compatibility\r\n    handleCallback(callback, null, indexName);\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  createListener,\r\n  createIndex,\r\n  ensureIndex,\r\n  evaluate,\r\n  executeCommand,\r\n  executeDbAdminCommand,\r\n  indexInformation,\r\n  profilingInfo,\r\n  validateDatabaseName\r\n};\r\n"]},"metadata":{},"sourceType":"script"}