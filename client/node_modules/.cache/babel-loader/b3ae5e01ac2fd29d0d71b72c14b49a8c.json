{"ast":null,"code":"'use strict';\n\nconst deprecate = require('util').deprecate;\n\nconst Logger = require('../core').Logger;\n\nconst MongoCredentials = require('../core').MongoCredentials;\n\nconst MongoError = require('../core').MongoError;\n\nconst Mongos = require('../topologies/mongos');\n\nconst NativeTopology = require('../topologies/native_topology');\n\nconst parse = require('../core').parseConnectionString;\n\nconst ReadConcern = require('../read_concern');\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst ReplSet = require('../topologies/replset');\n\nconst Server = require('../topologies/server');\n\nconst ServerSessionPool = require('../core').Sessions.ServerSessionPool;\n\nconst emitDeprecationWarning = require('../utils').emitDeprecationWarning;\n\nconst emitWarningOnce = require('../utils').emitWarningOnce;\n\nconst fs = require('fs');\n\nconst WriteConcern = require('../write_concern');\n\nconst CMAP_EVENT_NAMES = require('../cmap/events').CMAP_EVENT_NAMES;\n\nlet client;\n\nfunction loadClient() {\n  if (!client) {\n    client = require('../mongo_client');\n  }\n\n  return client;\n}\n\nconst legacyParse = deprecate(require('../url_parser'), 'current URL string parser is deprecated, and will be removed in a future version. ' + 'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.');\nconst AUTH_MECHANISM_INTERNAL_MAP = {\n  DEFAULT: 'default',\n  PLAIN: 'plain',\n  GSSAPI: 'gssapi',\n  'MONGODB-CR': 'mongocr',\n  'MONGODB-X509': 'x509',\n  'MONGODB-AWS': 'mongodb-aws',\n  'SCRAM-SHA-1': 'scram-sha-1',\n  'SCRAM-SHA-256': 'scram-sha-256'\n};\nconst monitoringEvents = ['timeout', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open'];\nconst VALID_AUTH_MECHANISMS = new Set(['DEFAULT', 'PLAIN', 'GSSAPI', 'MONGODB-CR', 'MONGODB-X509', 'MONGODB-AWS', 'SCRAM-SHA-1', 'SCRAM-SHA-256']);\nconst validOptionNames = ['poolSize', 'ssl', 'sslValidate', 'sslCA', 'sslCert', 'sslKey', 'sslPass', 'sslCRL', 'autoReconnect', 'noDelay', 'keepAlive', 'keepAliveInitialDelay', 'connectTimeoutMS', 'family', 'socketTimeoutMS', 'reconnectTries', 'reconnectInterval', 'ha', 'haInterval', 'replicaSet', 'secondaryAcceptableLatencyMS', 'acceptableLatencyMS', 'connectWithNoPrimary', 'authSource', 'w', 'wtimeout', 'j', 'writeConcern', 'forceServerObjectId', 'serializeFunctions', 'ignoreUndefined', 'raw', 'bufferMaxEntries', 'readPreference', 'pkFactory', 'promiseLibrary', 'readConcern', 'maxStalenessSeconds', 'loggerLevel', 'logger', 'promoteValues', 'promoteBuffers', 'promoteLongs', 'domainsEnabled', 'checkServerIdentity', 'validateOptions', 'appname', 'auth', 'user', 'password', 'authMechanism', 'compression', 'fsync', 'readPreferenceTags', 'numberOfRetries', 'auto_reconnect', 'minSize', 'monitorCommands', 'retryWrites', 'retryReads', 'useNewUrlParser', 'useUnifiedTopology', 'serverSelectionTimeoutMS', 'useRecoveryToken', 'autoEncryption', 'driverInfo', 'tls', 'tlsInsecure', 'tlsinsecure', 'tlsAllowInvalidCertificates', 'tlsAllowInvalidHostnames', 'tlsCAFile', 'tlsCertificateFile', 'tlsCertificateKeyFile', 'tlsCertificateKeyFilePassword', 'minHeartbeatFrequencyMS', 'heartbeatFrequencyMS', 'directConnection', 'appName', // CMAP options\n'maxPoolSize', 'minPoolSize', 'maxIdleTimeMS', 'waitQueueTimeoutMS'];\nconst ignoreOptionNames = ['native_parser'];\nconst legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db']; // Validate options object\n\nfunction validOptions(options) {\n  const _validOptions = validOptionNames.concat(legacyOptionNames);\n\n  for (const name in options) {\n    if (ignoreOptionNames.indexOf(name) !== -1) {\n      continue;\n    }\n\n    if (_validOptions.indexOf(name) === -1) {\n      if (options.validateOptions) {\n        return new MongoError(`option ${name} is not supported`);\n      } else {\n        emitWarningOnce(`the options [${name}] is not supported`);\n      }\n    }\n\n    if (legacyOptionNames.indexOf(name) !== -1) {\n      emitWarningOnce(`the server/replset/mongos/db options are deprecated, ` + `all their options are supported at the top level of the options object [${validOptionNames}]`);\n    }\n  }\n}\n\nconst LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {\n  obj[name.toLowerCase()] = name;\n  return obj;\n}, {});\n\nfunction addListeners(mongoClient, topology) {\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\n  topology.on('error', createListener(mongoClient, 'error'));\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\n  topology.on('close', createListener(mongoClient, 'close'));\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\n  topology.once('open', createListener(mongoClient, 'open'));\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\n  topology.once('all', createListener(mongoClient, 'all'));\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\n}\n\nfunction assignTopology(client, topology) {\n  client.topology = topology;\n\n  if (!(topology instanceof NativeTopology)) {\n    topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);\n  }\n} // Clear out all events\n\n\nfunction clearAllEvents(topology) {\n  monitoringEvents.forEach(event => topology.removeAllListeners(event));\n} // Collect all events in order from SDAM\n\n\nfunction collectEvents(mongoClient, topology) {\n  let MongoClient = loadClient();\n  const collectedEvents = [];\n\n  if (mongoClient instanceof MongoClient) {\n    monitoringEvents.forEach(event => {\n      topology.on(event, (object1, object2) => {\n        if (event === 'open') {\n          collectedEvents.push({\n            event: event,\n            object1: mongoClient\n          });\n        } else {\n          collectedEvents.push({\n            event: event,\n            object1: object1,\n            object2: object2\n          });\n        }\n      });\n    });\n  }\n\n  return collectedEvents;\n}\n\nfunction resolveTLSOptions(options) {\n  if (options.tls == null) {\n    return;\n  }\n\n  ['sslCA', 'sslKey', 'sslCert'].forEach(optionName => {\n    if (options[optionName]) {\n      options[optionName] = fs.readFileSync(options[optionName]);\n    }\n  });\n}\n\nfunction connect(mongoClient, url, options, callback) {\n  options = Object.assign({}, options); // If callback is null throw an exception\n\n  if (callback == null) {\n    throw new Error('no callback function provided');\n  }\n\n  let didRequestAuthentication = false;\n  const logger = Logger('MongoClient', options); // Did we pass in a Server/ReplSet/Mongos\n\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\n    return connectWithUrl(mongoClient, url, options, connectCallback);\n  }\n\n  const useNewUrlParser = options.useNewUrlParser !== false;\n  const parseFn = useNewUrlParser ? parse : legacyParse;\n  const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\n  parseFn(url, options, (err, _object) => {\n    // Do not attempt to connect if parsing error\n    if (err) return callback(err); // Flatten\n\n    const object = transform(_object); // Parse the string\n\n    const _finalOptions = createUnifiedOptions(object, options); // Check if we have connection and socket timeout set\n\n\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 0;\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 10000;\n    if (_finalOptions.retryWrites == null) _finalOptions.retryWrites = true;\n    if (_finalOptions.useRecoveryToken == null) _finalOptions.useRecoveryToken = true;\n    if (_finalOptions.readPreference == null) _finalOptions.readPreference = 'primary';\n\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\n      delete _finalOptions.db_options.auth;\n    } // resolve tls options if needed\n\n\n    resolveTLSOptions(_finalOptions); // Store the merged options object\n\n    mongoClient.s.options = _finalOptions; // Apply read and write concern from parsed url\n\n    mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);\n    mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions); // Failure modes\n\n    if (object.servers.length === 0) {\n      return callback(new Error('connection string must contain at least one seed host'));\n    }\n\n    if (_finalOptions.auth && !_finalOptions.credentials) {\n      try {\n        didRequestAuthentication = true;\n        _finalOptions.credentials = generateCredentials(mongoClient, _finalOptions.auth.user, _finalOptions.auth.password, _finalOptions);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    if (_finalOptions.useUnifiedTopology) {\n      return createTopology(mongoClient, 'unified', _finalOptions, connectCallback);\n    }\n\n    emitWarningOnce('Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.'); // Do we have a replicaset then skip discovery and go straight to connectivity\n\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectCallback);\n    } else if (object.servers.length > 1) {\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectCallback);\n    } else {\n      return createServer(mongoClient, _finalOptions, connectCallback);\n    }\n  });\n\n  function connectCallback(err, topology) {\n    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;\n\n    if (err && err.message === 'no mongos proxies found in seed list') {\n      if (logger.isWarn()) {\n        logger.warn(warningMessage);\n      } // Return a more specific error message for MongoClient.connect\n\n\n      return callback(new MongoError(warningMessage));\n    }\n\n    if (didRequestAuthentication) {\n      mongoClient.emit('authenticated', null, true);\n    } // Return the error and db instance\n\n\n    callback(err, topology);\n  }\n}\n\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\n  // Set the topology\n  assignTopology(mongoClient, url); // Add listeners\n\n  addListeners(mongoClient, url); // Propagate the events to the client\n\n  relayEvents(mongoClient, url);\n  let finalOptions = Object.assign({}, options); // If we have a readPreference passed in by the db options, convert it from a string\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    finalOptions.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  }\n\n  const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;\n\n  if (isDoingAuth && !finalOptions.credentials) {\n    try {\n      finalOptions.credentials = generateCredentials(mongoClient, finalOptions.user, finalOptions.password, finalOptions);\n    } catch (err) {\n      return connectCallback(err, url);\n    }\n  }\n\n  return url.connect(finalOptions, connectCallback);\n}\n\nfunction createListener(mongoClient, event) {\n  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\n  return (v1, v2) => {\n    if (eventSet.has(event)) {\n      return mongoClient.emit(event, mongoClient);\n    }\n\n    mongoClient.emit(event, v1, v2);\n  };\n}\n\nfunction createServer(mongoClient, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary; // Set default options\n\n  const servers = translateOptions(options);\n  const server = servers[0]; // Propagate the events to the client\n\n  const collectedEvents = collectEvents(mongoClient, server); // Connect to topology\n\n  server.connect(options, (err, topology) => {\n    if (err) {\n      server.close(true);\n      return callback(err);\n    } // Clear out all the collected event listeners\n\n\n    clearAllEvents(server); // Relay all the events\n\n    relayEvents(mongoClient, server); // Add listeners\n\n    addListeners(mongoClient, server); // Check if we are really speaking to a mongos\n\n    const ismaster = topology.lastIsMaster(); // Set the topology\n\n    assignTopology(mongoClient, topology); // Do we actually have a mongos\n\n    if (ismaster && ismaster.msg === 'isdbgrid') {\n      // Destroy the current connection\n      topology.close(); // Create mongos connection instead\n\n      return createTopology(mongoClient, 'mongos', options, callback);\n    } // Fire all the events\n\n\n    replayEvents(mongoClient, collectedEvents); // Otherwise callback\n\n    callback(err, topology);\n  });\n}\n\nconst DEPRECATED_UNIFIED_EVENTS = new Set(['reconnect', 'reconnectFailed', 'attemptReconnect', 'joined', 'left', 'ping', 'ha', 'all', 'fullsetup', 'open']);\n\nfunction registerDeprecatedEventNotifiers(client) {\n  client.on('newListener', eventName => {\n    if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {\n      emitDeprecationWarning(`The \\`${eventName}\\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`, 'DeprecationWarning');\n    }\n  });\n}\n\nfunction createTopology(mongoClient, topologyType, options, callback) {\n  // Pass in the promise library\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\n  const translationOptions = {};\n  if (topologyType === 'unified') translationOptions.createServers = false; // Set default options\n\n  const servers = translateOptions(options, translationOptions); // determine CSFLE support\n\n  if (options.autoEncryption != null) {\n    const Encrypter = require('../encrypter').Encrypter;\n\n    options.encrypter = new Encrypter(mongoClient, options);\n    options.autoEncrypter = options.encrypter.autoEncrypter;\n  } // Create the topology\n\n\n  let topology;\n\n  if (topologyType === 'mongos') {\n    topology = new Mongos(servers, options);\n  } else if (topologyType === 'replicaset') {\n    topology = new ReplSet(servers, options);\n  } else if (topologyType === 'unified') {\n    topology = new NativeTopology(options.servers, options);\n    registerDeprecatedEventNotifiers(mongoClient);\n  } // Add listeners\n\n\n  addListeners(mongoClient, topology); // Propagate the events to the client\n\n  relayEvents(mongoClient, topology); // Open the connection\n\n  assignTopology(mongoClient, topology); // initialize CSFLE if requested\n\n  if (options.autoEncrypter) {\n    options.autoEncrypter.init(err => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      topology.connect(options, err => {\n        if (err) {\n          topology.close(true);\n          callback(err);\n          return;\n        }\n\n        options.encrypter.connectInternalClient(error => {\n          if (error) return callback(error);\n          callback(undefined, topology);\n        });\n      });\n    });\n    return;\n  } // otherwise connect normally\n\n\n  topology.connect(options, err => {\n    if (err) {\n      topology.close(true);\n      return callback(err);\n    }\n\n    callback(undefined, topology);\n    return;\n  });\n}\n\nfunction createUnifiedOptions(finalOptions, options) {\n  const childOptions = ['mongos', 'server', 'db', 'replset', 'db_options', 'server_options', 'rs_options', 'mongos_options'];\n  const noMerge = ['readconcern', 'compression', 'autoencryption'];\n  const skip = ['w', 'wtimeout', 'j', 'journal', 'fsync', 'writeConcern'];\n\n  for (const name in options) {\n    if (skip.indexOf(name.toLowerCase()) !== -1) {\n      continue;\n    } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions[name] = options[name];\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\n      finalOptions = mergeOptions(finalOptions, options[name], false);\n    } else {\n      if (options[name] && typeof options[name] === 'object' && !Buffer.isBuffer(options[name]) && !Array.isArray(options[name])) {\n        finalOptions = mergeOptions(finalOptions, options[name], true);\n      } else {\n        finalOptions[name] = options[name];\n      }\n    }\n  } // Handle write concern keys separately, since `options` may have the keys at the top level or\n  // under `options.writeConcern`. The final merged keys will be under `finalOptions.writeConcern`.\n  // This way, `fromOptions` will warn once if `options` is using deprecated write concern options\n\n\n  const optionsWriteConcern = WriteConcern.fromOptions(options);\n\n  if (optionsWriteConcern) {\n    finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);\n  }\n\n  return finalOptions;\n}\n\nfunction generateCredentials(client, username, password, options) {\n  options = Object.assign({}, options); // the default db to authenticate against is 'self'\n  // if authententicate is called from a retry context, it may be another one, like admin\n\n  const source = options.authSource || options.authdb || options.dbName; // authMechanism\n\n  const authMechanismRaw = options.authMechanism || 'DEFAULT';\n  const authMechanism = authMechanismRaw.toUpperCase();\n  const mechanismProperties = options.authMechanismProperties;\n\n  if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {\n    throw MongoError.create({\n      message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,\n      driver: true\n    });\n  }\n\n  return new MongoCredentials({\n    mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],\n    mechanismProperties,\n    source,\n    username,\n    password\n  });\n}\n\nfunction legacyTransformUrlOptions(object) {\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\n}\n\nfunction mergeOptions(target, source, flatten) {\n  for (const name in source) {\n    if (source[name] && typeof source[name] === 'object' && flatten) {\n      target = mergeOptions(target, source[name], flatten);\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n}\n\nfunction relayEvents(mongoClient, topology) {\n  const serverOrCommandEvents = [// APM\n  'commandStarted', 'commandSucceeded', 'commandFailed', // SDAM\n  'serverOpening', 'serverClosed', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', // Legacy\n  'joined', 'left', 'ping', 'ha'].concat(CMAP_EVENT_NAMES);\n  serverOrCommandEvents.forEach(event => {\n    topology.on(event, (object1, object2) => {\n      mongoClient.emit(event, object1, object2);\n    });\n  });\n} //\n// Replay any events due to single server connection switching to Mongos\n//\n\n\nfunction replayEvents(mongoClient, events) {\n  for (let i = 0; i < events.length; i++) {\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\n  }\n}\n\nfunction transformUrlOptions(_object) {\n  let object = Object.assign({\n    servers: _object.hosts\n  }, _object.options);\n\n  for (let name in object) {\n    const camelCaseName = LEGACY_OPTIONS_MAP[name];\n\n    if (camelCaseName) {\n      object[camelCaseName] = object[name];\n    }\n  }\n\n  const hasUsername = _object.auth && _object.auth.username;\n  const hasAuthMechanism = _object.options && _object.options.authMechanism;\n\n  if (hasUsername || hasAuthMechanism) {\n    object.auth = Object.assign({}, _object.auth);\n\n    if (object.auth.db) {\n      object.authSource = object.authSource || object.auth.db;\n    }\n\n    if (object.auth.username) {\n      object.auth.user = object.auth.username;\n    }\n  }\n\n  if (_object.defaultDatabase) {\n    object.dbName = _object.defaultDatabase;\n  }\n\n  if (object.maxPoolSize) {\n    object.poolSize = object.maxPoolSize;\n  }\n\n  if (object.readConcernLevel) {\n    object.readConcern = new ReadConcern(object.readConcernLevel);\n  }\n\n  if (object.wTimeoutMS) {\n    object.wtimeout = object.wTimeoutMS;\n    object.wTimeoutMS = undefined;\n  }\n\n  if (_object.srvHost) {\n    object.srvHost = _object.srvHost;\n  } // Any write concern options from the URL will be top-level, so we manually\n  // move them options under `object.writeConcern` to avoid warnings later\n\n\n  const wcKeys = ['w', 'wtimeout', 'j', 'journal', 'fsync'];\n\n  for (const key of wcKeys) {\n    if (object[key] !== undefined) {\n      if (object.writeConcern === undefined) object.writeConcern = {};\n      object.writeConcern[key] = object[key];\n      object[key] = undefined;\n    }\n  }\n\n  return object;\n}\n\nfunction translateOptions(options, translationOptions) {\n  translationOptions = Object.assign({}, {\n    createServers: true\n  }, translationOptions); // If we have a readPreference passed in by the db options\n\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\n  } // Do we have readPreference tags, add them\n\n\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\n  } // Do we have maxStalenessSeconds\n\n\n  if (options.maxStalenessSeconds) {\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\n  } // Set the socket and connection timeouts\n\n\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 0;\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 10000;\n\n  if (!translationOptions.createServers) {\n    return;\n  } // Create server instances\n\n\n  return options.servers.map(serverObj => {\n    return serverObj.domain_socket ? new Server(serverObj.domain_socket, 27017, options) : new Server(serverObj.host, serverObj.port, options);\n  });\n}\n\nmodule.exports = {\n  validOptions,\n  connect\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/operations/connect.js"],"names":["deprecate","require","Logger","MongoCredentials","MongoError","Mongos","NativeTopology","parse","parseConnectionString","ReadConcern","ReadPreference","ReplSet","Server","ServerSessionPool","Sessions","emitDeprecationWarning","emitWarningOnce","fs","WriteConcern","CMAP_EVENT_NAMES","client","loadClient","legacyParse","AUTH_MECHANISM_INTERNAL_MAP","DEFAULT","PLAIN","GSSAPI","monitoringEvents","VALID_AUTH_MECHANISMS","Set","validOptionNames","ignoreOptionNames","legacyOptionNames","validOptions","options","_validOptions","concat","name","indexOf","validateOptions","LEGACY_OPTIONS_MAP","reduce","obj","toLowerCase","addListeners","mongoClient","topology","on","createListener","once","assignTopology","s","sessionPool","coreTopology","clearAllEvents","forEach","event","removeAllListeners","collectEvents","MongoClient","collectedEvents","object1","object2","push","resolveTLSOptions","tls","optionName","readFileSync","connect","url","callback","Object","assign","Error","didRequestAuthentication","logger","connectWithUrl","connectCallback","useNewUrlParser","parseFn","transform","transformUrlOptions","legacyTransformUrlOptions","err","_object","object","_finalOptions","createUnifiedOptions","socketTimeoutMS","connectTimeoutMS","retryWrites","useRecoveryToken","readPreference","db_options","auth","fromOptions","writeConcern","servers","length","credentials","generateCredentials","user","password","useUnifiedTopology","createTopology","replicaSet","rs_name","createServer","warningMessage","message","isWarn","warn","emit","relayEvents","finalOptions","read_preference","isDoingAuth","authMechanism","eventSet","v1","v2","has","promiseLibrary","translateOptions","server","close","ismaster","lastIsMaster","msg","replayEvents","DEPRECATED_UNIFIED_EVENTS","registerDeprecatedEventNotifiers","eventName","topologyType","translationOptions","createServers","autoEncryption","Encrypter","encrypter","autoEncrypter","init","connectInternalClient","error","undefined","childOptions","noMerge","skip","mergeOptions","Buffer","isBuffer","Array","isArray","optionsWriteConcern","username","source","authSource","authdb","dbName","authMechanismRaw","toUpperCase","mechanismProperties","authMechanismProperties","create","driver","mechanism","target","flatten","serverOrCommandEvents","events","i","hosts","camelCaseName","hasUsername","hasAuthMechanism","db","defaultDatabase","maxPoolSize","poolSize","readConcernLevel","readConcern","wTimeoutMS","wtimeout","srvHost","wcKeys","key","readPreferenceTags","read_preference_tags","tags","maxStalenessSeconds","map","serverObj","domain_socket","host","port","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,MAAD,CAAP,CAAgBD,SAAlC;;AACA,MAAME,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,MAAlC;;AACA,MAAMC,gBAAgB,GAAGF,OAAO,CAAC,SAAD,CAAP,CAAmBE,gBAA5C;;AACA,MAAMC,UAAU,GAAGH,OAAO,CAAC,SAAD,CAAP,CAAmBG,UAAtC;;AACA,MAAMC,MAAM,GAAGJ,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMK,cAAc,GAAGL,OAAO,CAAC,+BAAD,CAA9B;;AACA,MAAMM,KAAK,GAAGN,OAAO,CAAC,SAAD,CAAP,CAAmBO,qBAAjC;;AACA,MAAMC,WAAW,GAAGR,OAAO,CAAC,iBAAD,CAA3B;;AACA,MAAMS,cAAc,GAAGT,OAAO,CAAC,SAAD,CAAP,CAAmBS,cAA1C;;AACA,MAAMC,OAAO,GAAGV,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMW,MAAM,GAAGX,OAAO,CAAC,sBAAD,CAAtB;;AACA,MAAMY,iBAAiB,GAAGZ,OAAO,CAAC,SAAD,CAAP,CAAmBa,QAAnB,CAA4BD,iBAAtD;;AACA,MAAME,sBAAsB,GAAGd,OAAO,CAAC,UAAD,CAAP,CAAoBc,sBAAnD;;AACA,MAAMC,eAAe,GAAGf,OAAO,CAAC,UAAD,CAAP,CAAoBe,eAA5C;;AACA,MAAMC,EAAE,GAAGhB,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMiB,YAAY,GAAGjB,OAAO,CAAC,kBAAD,CAA5B;;AACA,MAAMkB,gBAAgB,GAAGlB,OAAO,CAAC,gBAAD,CAAP,CAA0BkB,gBAAnD;;AAEA,IAAIC,MAAJ;;AACA,SAASC,UAAT,GAAsB;AACpB,MAAI,CAACD,MAAL,EAAa;AACXA,IAAAA,MAAM,GAAGnB,OAAO,CAAC,iBAAD,CAAhB;AACD;;AACD,SAAOmB,MAAP;AACD;;AAED,MAAME,WAAW,GAAGtB,SAAS,CAC3BC,OAAO,CAAC,eAAD,CADoB,EAE3B,uFACE,sFAHyB,CAA7B;AAMA,MAAMsB,2BAA2B,GAAG;AAClCC,EAAAA,OAAO,EAAE,SADyB;AAElCC,EAAAA,KAAK,EAAE,OAF2B;AAGlCC,EAAAA,MAAM,EAAE,QAH0B;AAIlC,gBAAc,SAJoB;AAKlC,kBAAgB,MALkB;AAMlC,iBAAe,aANmB;AAOlC,iBAAe,aAPmB;AAQlC,mBAAiB;AARiB,CAApC;AAWA,MAAMC,gBAAgB,GAAG,CACvB,SADuB,EAEvB,OAFuB,EAGvB,eAHuB,EAIvB,0BAJuB,EAKvB,wBALuB,EAMvB,0BANuB,EAOvB,uBAPuB,EAQvB,cARuB,EASvB,iBATuB,EAUvB,gBAVuB,EAWvB,4BAXuB,EAYvB,gBAZuB,EAavB,kBAbuB,EAcvB,eAduB,EAevB,QAfuB,EAgBvB,MAhBuB,EAiBvB,MAjBuB,EAkBvB,IAlBuB,EAmBvB,KAnBuB,EAoBvB,WApBuB,EAqBvB,MArBuB,CAAzB;AAwBA,MAAMC,qBAAqB,GAAG,IAAIC,GAAJ,CAAQ,CACpC,SADoC,EAEpC,OAFoC,EAGpC,QAHoC,EAIpC,YAJoC,EAKpC,cALoC,EAMpC,aANoC,EAOpC,aAPoC,EAQpC,eARoC,CAAR,CAA9B;AAWA,MAAMC,gBAAgB,GAAG,CACvB,UADuB,EAEvB,KAFuB,EAGvB,aAHuB,EAIvB,OAJuB,EAKvB,SALuB,EAMvB,QANuB,EAOvB,SAPuB,EAQvB,QARuB,EASvB,eATuB,EAUvB,SAVuB,EAWvB,WAXuB,EAYvB,uBAZuB,EAavB,kBAbuB,EAcvB,QAduB,EAevB,iBAfuB,EAgBvB,gBAhBuB,EAiBvB,mBAjBuB,EAkBvB,IAlBuB,EAmBvB,YAnBuB,EAoBvB,YApBuB,EAqBvB,8BArBuB,EAsBvB,qBAtBuB,EAuBvB,sBAvBuB,EAwBvB,YAxBuB,EAyBvB,GAzBuB,EA0BvB,UA1BuB,EA2BvB,GA3BuB,EA4BvB,cA5BuB,EA6BvB,qBA7BuB,EA8BvB,oBA9BuB,EA+BvB,iBA/BuB,EAgCvB,KAhCuB,EAiCvB,kBAjCuB,EAkCvB,gBAlCuB,EAmCvB,WAnCuB,EAoCvB,gBApCuB,EAqCvB,aArCuB,EAsCvB,qBAtCuB,EAuCvB,aAvCuB,EAwCvB,QAxCuB,EAyCvB,eAzCuB,EA0CvB,gBA1CuB,EA2CvB,cA3CuB,EA4CvB,gBA5CuB,EA6CvB,qBA7CuB,EA8CvB,iBA9CuB,EA+CvB,SA/CuB,EAgDvB,MAhDuB,EAiDvB,MAjDuB,EAkDvB,UAlDuB,EAmDvB,eAnDuB,EAoDvB,aApDuB,EAqDvB,OArDuB,EAsDvB,oBAtDuB,EAuDvB,iBAvDuB,EAwDvB,gBAxDuB,EAyDvB,SAzDuB,EA0DvB,iBA1DuB,EA2DvB,aA3DuB,EA4DvB,YA5DuB,EA6DvB,iBA7DuB,EA8DvB,oBA9DuB,EA+DvB,0BA/DuB,EAgEvB,kBAhEuB,EAiEvB,gBAjEuB,EAkEvB,YAlEuB,EAmEvB,KAnEuB,EAoEvB,aApEuB,EAqEvB,aArEuB,EAsEvB,6BAtEuB,EAuEvB,0BAvEuB,EAwEvB,WAxEuB,EAyEvB,oBAzEuB,EA0EvB,uBA1EuB,EA2EvB,+BA3EuB,EA4EvB,yBA5EuB,EA6EvB,sBA7EuB,EA8EvB,kBA9EuB,EA+EvB,SA/EuB,EAiFvB;AACA,aAlFuB,EAmFvB,aAnFuB,EAoFvB,eApFuB,EAqFvB,oBArFuB,CAAzB;AAwFA,MAAMC,iBAAiB,GAAG,CAAC,eAAD,CAA1B;AACA,MAAMC,iBAAiB,GAAG,CAAC,QAAD,EAAW,SAAX,EAAsB,SAAtB,EAAiC,QAAjC,EAA2C,IAA3C,CAA1B,C,CAEA;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAC7B,QAAMC,aAAa,GAAGL,gBAAgB,CAACM,MAAjB,CAAwBJ,iBAAxB,CAAtB;;AAEA,OAAK,MAAMK,IAAX,IAAmBH,OAAnB,EAA4B;AAC1B,QAAIH,iBAAiB,CAACO,OAAlB,CAA0BD,IAA1B,MAAoC,CAAC,CAAzC,EAA4C;AAC1C;AACD;;AAED,QAAIF,aAAa,CAACG,OAAd,CAAsBD,IAAtB,MAAgC,CAAC,CAArC,EAAwC;AACtC,UAAIH,OAAO,CAACK,eAAZ,EAA6B;AAC3B,eAAO,IAAInC,UAAJ,CAAgB,UAASiC,IAAK,mBAA9B,CAAP;AACD,OAFD,MAEO;AACLrB,QAAAA,eAAe,CAAE,gBAAeqB,IAAK,oBAAtB,CAAf;AACD;AACF;;AAED,QAAIL,iBAAiB,CAACM,OAAlB,CAA0BD,IAA1B,MAAoC,CAAC,CAAzC,EAA4C;AAC1CrB,MAAAA,eAAe,CACZ,uDAAD,GACG,2EAA0Ec,gBAAiB,GAFjF,CAAf;AAID;AACF;AACF;;AAED,MAAMU,kBAAkB,GAAGV,gBAAgB,CAACW,MAAjB,CAAwB,CAACC,GAAD,EAAML,IAAN,KAAe;AAChEK,EAAAA,GAAG,CAACL,IAAI,CAACM,WAAL,EAAD,CAAH,GAA0BN,IAA1B;AACA,SAAOK,GAAP;AACD,CAH0B,EAGxB,EAHwB,CAA3B;;AAKA,SAASE,YAAT,CAAsBC,WAAtB,EAAmCC,QAAnC,EAA6C;AAC3CA,EAAAA,QAAQ,CAACC,EAAT,CAAY,eAAZ,EAA6BC,cAAc,CAACH,WAAD,EAAc,eAAd,CAA3C;AACAC,EAAAA,QAAQ,CAACC,EAAT,CAAY,OAAZ,EAAqBC,cAAc,CAACH,WAAD,EAAc,OAAd,CAAnC;AACAC,EAAAA,QAAQ,CAACC,EAAT,CAAY,SAAZ,EAAuBC,cAAc,CAACH,WAAD,EAAc,SAAd,CAArC;AACAC,EAAAA,QAAQ,CAACC,EAAT,CAAY,OAAZ,EAAqBC,cAAc,CAACH,WAAD,EAAc,OAAd,CAAnC;AACAC,EAAAA,QAAQ,CAACC,EAAT,CAAY,YAAZ,EAA0BC,cAAc,CAACH,WAAD,EAAc,YAAd,CAAxC;AACAC,EAAAA,QAAQ,CAACG,IAAT,CAAc,MAAd,EAAsBD,cAAc,CAACH,WAAD,EAAc,MAAd,CAApC;AACAC,EAAAA,QAAQ,CAACG,IAAT,CAAc,WAAd,EAA2BD,cAAc,CAACH,WAAD,EAAc,WAAd,CAAzC;AACAC,EAAAA,QAAQ,CAACG,IAAT,CAAc,KAAd,EAAqBD,cAAc,CAACH,WAAD,EAAc,KAAd,CAAnC;AACAC,EAAAA,QAAQ,CAACC,EAAT,CAAY,WAAZ,EAAyBC,cAAc,CAACH,WAAD,EAAc,WAAd,CAAvC;AACD;;AAED,SAASK,cAAT,CAAwB9B,MAAxB,EAAgC0B,QAAhC,EAA0C;AACxC1B,EAAAA,MAAM,CAAC0B,QAAP,GAAkBA,QAAlB;;AAEA,MAAI,EAAEA,QAAQ,YAAYxC,cAAtB,CAAJ,EAA2C;AACzCwC,IAAAA,QAAQ,CAACK,CAAT,CAAWC,WAAX,GAAyB,IAAIvC,iBAAJ,CAAsBiC,QAAQ,CAACK,CAAT,CAAWE,YAAjC,CAAzB;AACD;AACF,C,CAED;;;AACA,SAASC,cAAT,CAAwBR,QAAxB,EAAkC;AAChCnB,EAAAA,gBAAgB,CAAC4B,OAAjB,CAAyBC,KAAK,IAAIV,QAAQ,CAACW,kBAAT,CAA4BD,KAA5B,CAAlC;AACD,C,CAED;;;AACA,SAASE,aAAT,CAAuBb,WAAvB,EAAoCC,QAApC,EAA8C;AAC5C,MAAIa,WAAW,GAAGtC,UAAU,EAA5B;AACA,QAAMuC,eAAe,GAAG,EAAxB;;AAEA,MAAIf,WAAW,YAAYc,WAA3B,EAAwC;AACtChC,IAAAA,gBAAgB,CAAC4B,OAAjB,CAAyBC,KAAK,IAAI;AAChCV,MAAAA,QAAQ,CAACC,EAAT,CAAYS,KAAZ,EAAmB,CAACK,OAAD,EAAUC,OAAV,KAAsB;AACvC,YAAIN,KAAK,KAAK,MAAd,EAAsB;AACpBI,UAAAA,eAAe,CAACG,IAAhB,CAAqB;AAAEP,YAAAA,KAAK,EAAEA,KAAT;AAAgBK,YAAAA,OAAO,EAAEhB;AAAzB,WAArB;AACD,SAFD,MAEO;AACLe,UAAAA,eAAe,CAACG,IAAhB,CAAqB;AAAEP,YAAAA,KAAK,EAAEA,KAAT;AAAgBK,YAAAA,OAAO,EAAEA,OAAzB;AAAkCC,YAAAA,OAAO,EAAEA;AAA3C,WAArB;AACD;AACF,OAND;AAOD,KARD;AASD;;AAED,SAAOF,eAAP;AACD;;AAED,SAASI,iBAAT,CAA2B9B,OAA3B,EAAoC;AAClC,MAAIA,OAAO,CAAC+B,GAAR,IAAe,IAAnB,EAAyB;AACvB;AACD;;AAED,GAAC,OAAD,EAAU,QAAV,EAAoB,SAApB,EAA+BV,OAA/B,CAAuCW,UAAU,IAAI;AACnD,QAAIhC,OAAO,CAACgC,UAAD,CAAX,EAAyB;AACvBhC,MAAAA,OAAO,CAACgC,UAAD,CAAP,GAAsBjD,EAAE,CAACkD,YAAH,CAAgBjC,OAAO,CAACgC,UAAD,CAAvB,CAAtB;AACD;AACF,GAJD;AAKD;;AAED,SAASE,OAAT,CAAiBvB,WAAjB,EAA8BwB,GAA9B,EAAmCnC,OAAnC,EAA4CoC,QAA5C,EAAsD;AACpDpC,EAAAA,OAAO,GAAGqC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtC,OAAlB,CAAV,CADoD,CAGpD;;AACA,MAAIoC,QAAQ,IAAI,IAAhB,EAAsB;AACpB,UAAM,IAAIG,KAAJ,CAAU,+BAAV,CAAN;AACD;;AAED,MAAIC,wBAAwB,GAAG,KAA/B;AACA,QAAMC,MAAM,GAAGzE,MAAM,CAAC,aAAD,EAAgBgC,OAAhB,CAArB,CAToD,CAWpD;;AACA,MAAImC,GAAG,YAAYzD,MAAf,IAAyByD,GAAG,YAAY1D,OAAxC,IAAmD0D,GAAG,YAAYhE,MAAtE,EAA8E;AAC5E,WAAOuE,cAAc,CAAC/B,WAAD,EAAcwB,GAAd,EAAmBnC,OAAnB,EAA4B2C,eAA5B,CAArB;AACD;;AAED,QAAMC,eAAe,GAAG5C,OAAO,CAAC4C,eAAR,KAA4B,KAApD;AAEA,QAAMC,OAAO,GAAGD,eAAe,GAAGvE,KAAH,GAAWe,WAA1C;AACA,QAAM0D,SAAS,GAAGF,eAAe,GAAGG,mBAAH,GAAyBC,yBAA1D;AAEAH,EAAAA,OAAO,CAACV,GAAD,EAAMnC,OAAN,EAAe,CAACiD,GAAD,EAAMC,OAAN,KAAkB;AACtC;AACA,QAAID,GAAJ,EAAS,OAAOb,QAAQ,CAACa,GAAD,CAAf,CAF6B,CAItC;;AACA,UAAME,MAAM,GAAGL,SAAS,CAACI,OAAD,CAAxB,CALsC,CAOtC;;AACA,UAAME,aAAa,GAAGC,oBAAoB,CAACF,MAAD,EAASnD,OAAT,CAA1C,CARsC,CAUtC;;;AACA,QAAIoD,aAAa,CAACE,eAAd,IAAiC,IAArC,EAA2CF,aAAa,CAACE,eAAd,GAAgC,CAAhC;AAC3C,QAAIF,aAAa,CAACG,gBAAd,IAAkC,IAAtC,EAA4CH,aAAa,CAACG,gBAAd,GAAiC,KAAjC;AAC5C,QAAIH,aAAa,CAACI,WAAd,IAA6B,IAAjC,EAAuCJ,aAAa,CAACI,WAAd,GAA4B,IAA5B;AACvC,QAAIJ,aAAa,CAACK,gBAAd,IAAkC,IAAtC,EAA4CL,aAAa,CAACK,gBAAd,GAAiC,IAAjC;AAC5C,QAAIL,aAAa,CAACM,cAAd,IAAgC,IAApC,EAA0CN,aAAa,CAACM,cAAd,GAA+B,SAA/B;;AAE1C,QAAIN,aAAa,CAACO,UAAd,IAA4BP,aAAa,CAACO,UAAd,CAAyBC,IAAzD,EAA+D;AAC7D,aAAOR,aAAa,CAACO,UAAd,CAAyBC,IAAhC;AACD,KAnBqC,CAqBtC;;;AACA9B,IAAAA,iBAAiB,CAACsB,aAAD,CAAjB,CAtBsC,CAwBtC;;AACAzC,IAAAA,WAAW,CAACM,CAAZ,CAAcjB,OAAd,GAAwBoD,aAAxB,CAzBsC,CA2BtC;;AACAzC,IAAAA,WAAW,CAACM,CAAZ,CAAcyC,cAAd,GAA+BlF,cAAc,CAACqF,WAAf,CAA2BT,aAA3B,CAA/B;AACAzC,IAAAA,WAAW,CAACM,CAAZ,CAAc6C,YAAd,GAA6B9E,YAAY,CAAC6E,WAAb,CAAyBT,aAAzB,CAA7B,CA7BsC,CA+BtC;;AACA,QAAID,MAAM,CAACY,OAAP,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,aAAO5B,QAAQ,CAAC,IAAIG,KAAJ,CAAU,uDAAV,CAAD,CAAf;AACD;;AAED,QAAIa,aAAa,CAACQ,IAAd,IAAsB,CAACR,aAAa,CAACa,WAAzC,EAAsD;AACpD,UAAI;AACFzB,QAAAA,wBAAwB,GAAG,IAA3B;AACAY,QAAAA,aAAa,CAACa,WAAd,GAA4BC,mBAAmB,CAC7CvD,WAD6C,EAE7CyC,aAAa,CAACQ,IAAd,CAAmBO,IAF0B,EAG7Cf,aAAa,CAACQ,IAAd,CAAmBQ,QAH0B,EAI7ChB,aAJ6C,CAA/C;AAMD,OARD,CAQE,OAAOH,GAAP,EAAY;AACZ,eAAOb,QAAQ,CAACa,GAAD,CAAf;AACD;AACF;;AAED,QAAIG,aAAa,CAACiB,kBAAlB,EAAsC;AACpC,aAAOC,cAAc,CAAC3D,WAAD,EAAc,SAAd,EAAyByC,aAAzB,EAAwCT,eAAxC,CAArB;AACD;;AAED7D,IAAAA,eAAe,CACb,uOADa,CAAf,CAtDsC,CA0DtC;;AACA,QAAIsE,aAAa,CAACmB,UAAd,IAA4BnB,aAAa,CAACoB,OAA9C,EAAuD;AACrD,aAAOF,cAAc,CAAC3D,WAAD,EAAc,YAAd,EAA4ByC,aAA5B,EAA2CT,eAA3C,CAArB;AACD,KAFD,MAEO,IAAIQ,MAAM,CAACY,OAAP,CAAeC,MAAf,GAAwB,CAA5B,EAA+B;AACpC,aAAOM,cAAc,CAAC3D,WAAD,EAAc,QAAd,EAAwByC,aAAxB,EAAuCT,eAAvC,CAArB;AACD,KAFM,MAEA;AACL,aAAO8B,YAAY,CAAC9D,WAAD,EAAcyC,aAAd,EAA6BT,eAA7B,CAAnB;AACD;AACF,GAlEM,CAAP;;AAoEA,WAASA,eAAT,CAAyBM,GAAzB,EAA8BrC,QAA9B,EAAwC;AACtC,UAAM8D,cAAc,GAAI,sLAAxB;;AACA,QAAIzB,GAAG,IAAIA,GAAG,CAAC0B,OAAJ,KAAgB,sCAA3B,EAAmE;AACjE,UAAIlC,MAAM,CAACmC,MAAP,EAAJ,EAAqB;AACnBnC,QAAAA,MAAM,CAACoC,IAAP,CAAYH,cAAZ;AACD,OAHgE,CAKjE;;;AACA,aAAOtC,QAAQ,CAAC,IAAIlE,UAAJ,CAAewG,cAAf,CAAD,CAAf;AACD;;AAED,QAAIlC,wBAAJ,EAA8B;AAC5B7B,MAAAA,WAAW,CAACmE,IAAZ,CAAiB,eAAjB,EAAkC,IAAlC,EAAwC,IAAxC;AACD,KAbqC,CAetC;;;AACA1C,IAAAA,QAAQ,CAACa,GAAD,EAAMrC,QAAN,CAAR;AACD;AACF;;AAED,SAAS8B,cAAT,CAAwB/B,WAAxB,EAAqCwB,GAArC,EAA0CnC,OAA1C,EAAmD2C,eAAnD,EAAoE;AAClE;AACA3B,EAAAA,cAAc,CAACL,WAAD,EAAcwB,GAAd,CAAd,CAFkE,CAIlE;;AACAzB,EAAAA,YAAY,CAACC,WAAD,EAAcwB,GAAd,CAAZ,CALkE,CAOlE;;AACA4C,EAAAA,WAAW,CAACpE,WAAD,EAAcwB,GAAd,CAAX;AAEA,MAAI6C,YAAY,GAAG3C,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtC,OAAlB,CAAnB,CAVkE,CAYlE;;AACA,MAAI,OAAOA,OAAO,CAAC0D,cAAf,KAAkC,QAAlC,IAA8C,OAAO1D,OAAO,CAACiF,eAAf,KAAmC,QAArF,EAA+F;AAC7FD,IAAAA,YAAY,CAACtB,cAAb,GAA8B,IAAIlF,cAAJ,CAC5BwB,OAAO,CAAC0D,cAAR,IAA0B1D,OAAO,CAACiF,eADN,CAA9B;AAGD;;AAED,QAAMC,WAAW,GAAGF,YAAY,CAACb,IAAb,IAAqBa,YAAY,CAACZ,QAAlC,IAA8CY,YAAY,CAACG,aAA/E;;AACA,MAAID,WAAW,IAAI,CAACF,YAAY,CAACf,WAAjC,EAA8C;AAC5C,QAAI;AACFe,MAAAA,YAAY,CAACf,WAAb,GAA2BC,mBAAmB,CAC5CvD,WAD4C,EAE5CqE,YAAY,CAACb,IAF+B,EAG5Ca,YAAY,CAACZ,QAH+B,EAI5CY,YAJ4C,CAA9C;AAMD,KAPD,CAOE,OAAO/B,GAAP,EAAY;AACZ,aAAON,eAAe,CAACM,GAAD,EAAMd,GAAN,CAAtB;AACD;AACF;;AAED,SAAOA,GAAG,CAACD,OAAJ,CAAY8C,YAAZ,EAA0BrC,eAA1B,CAAP;AACD;;AAED,SAAS7B,cAAT,CAAwBH,WAAxB,EAAqCW,KAArC,EAA4C;AAC1C,QAAM8D,QAAQ,GAAG,IAAIzF,GAAJ,CAAQ,CAAC,KAAD,EAAQ,WAAR,EAAqB,MAArB,EAA6B,WAA7B,CAAR,CAAjB;AACA,SAAO,CAAC0F,EAAD,EAAKC,EAAL,KAAY;AACjB,QAAIF,QAAQ,CAACG,GAAT,CAAajE,KAAb,CAAJ,EAAyB;AACvB,aAAOX,WAAW,CAACmE,IAAZ,CAAiBxD,KAAjB,EAAwBX,WAAxB,CAAP;AACD;;AAEDA,IAAAA,WAAW,CAACmE,IAAZ,CAAiBxD,KAAjB,EAAwB+D,EAAxB,EAA4BC,EAA5B;AACD,GAND;AAOD;;AAED,SAASb,YAAT,CAAsB9D,WAAtB,EAAmCX,OAAnC,EAA4CoC,QAA5C,EAAsD;AACpD;AACApC,EAAAA,OAAO,CAACwF,cAAR,GAAyB7E,WAAW,CAACM,CAAZ,CAAcuE,cAAvC,CAFoD,CAIpD;;AACA,QAAMzB,OAAO,GAAG0B,gBAAgB,CAACzF,OAAD,CAAhC;AAEA,QAAM0F,MAAM,GAAG3B,OAAO,CAAC,CAAD,CAAtB,CAPoD,CASpD;;AACA,QAAMrC,eAAe,GAAGF,aAAa,CAACb,WAAD,EAAc+E,MAAd,CAArC,CAVoD,CAYpD;;AACAA,EAAAA,MAAM,CAACxD,OAAP,CAAelC,OAAf,EAAwB,CAACiD,GAAD,EAAMrC,QAAN,KAAmB;AACzC,QAAIqC,GAAJ,EAAS;AACPyC,MAAAA,MAAM,CAACC,KAAP,CAAa,IAAb;AACA,aAAOvD,QAAQ,CAACa,GAAD,CAAf;AACD,KAJwC,CAKzC;;;AACA7B,IAAAA,cAAc,CAACsE,MAAD,CAAd,CANyC,CAQzC;;AACAX,IAAAA,WAAW,CAACpE,WAAD,EAAc+E,MAAd,CAAX,CATyC,CAUzC;;AACAhF,IAAAA,YAAY,CAACC,WAAD,EAAc+E,MAAd,CAAZ,CAXyC,CAYzC;;AACA,UAAME,QAAQ,GAAGhF,QAAQ,CAACiF,YAAT,EAAjB,CAbyC,CAezC;;AACA7E,IAAAA,cAAc,CAACL,WAAD,EAAcC,QAAd,CAAd,CAhByC,CAkBzC;;AACA,QAAIgF,QAAQ,IAAIA,QAAQ,CAACE,GAAT,KAAiB,UAAjC,EAA6C;AAC3C;AACAlF,MAAAA,QAAQ,CAAC+E,KAAT,GAF2C,CAG3C;;AACA,aAAOrB,cAAc,CAAC3D,WAAD,EAAc,QAAd,EAAwBX,OAAxB,EAAiCoC,QAAjC,CAArB;AACD,KAxBwC,CA0BzC;;;AACA2D,IAAAA,YAAY,CAACpF,WAAD,EAAce,eAAd,CAAZ,CA3ByC,CA4BzC;;AACAU,IAAAA,QAAQ,CAACa,GAAD,EAAMrC,QAAN,CAAR;AACD,GA9BD;AA+BD;;AAED,MAAMoF,yBAAyB,GAAG,IAAIrG,GAAJ,CAAQ,CACxC,WADwC,EAExC,iBAFwC,EAGxC,kBAHwC,EAIxC,QAJwC,EAKxC,MALwC,EAMxC,MANwC,EAOxC,IAPwC,EAQxC,KARwC,EASxC,WATwC,EAUxC,MAVwC,CAAR,CAAlC;;AAaA,SAASsG,gCAAT,CAA0C/G,MAA1C,EAAkD;AAChDA,EAAAA,MAAM,CAAC2B,EAAP,CAAU,aAAV,EAAyBqF,SAAS,IAAI;AACpC,QAAIF,yBAAyB,CAACT,GAA1B,CAA8BW,SAA9B,CAAJ,EAA8C;AAC5CrH,MAAAA,sBAAsB,CACnB,SAAQqH,SAAU,6GADC,EAEpB,oBAFoB,CAAtB;AAID;AACF,GAPD;AAQD;;AAED,SAAS5B,cAAT,CAAwB3D,WAAxB,EAAqCwF,YAArC,EAAmDnG,OAAnD,EAA4DoC,QAA5D,EAAsE;AACpE;AACApC,EAAAA,OAAO,CAACwF,cAAR,GAAyB7E,WAAW,CAACM,CAAZ,CAAcuE,cAAvC;AAEA,QAAMY,kBAAkB,GAAG,EAA3B;AACA,MAAID,YAAY,KAAK,SAArB,EAAgCC,kBAAkB,CAACC,aAAnB,GAAmC,KAAnC,CALoC,CAOpE;;AACA,QAAMtC,OAAO,GAAG0B,gBAAgB,CAACzF,OAAD,EAAUoG,kBAAV,CAAhC,CARoE,CAUpE;;AACA,MAAIpG,OAAO,CAACsG,cAAR,IAA0B,IAA9B,EAAoC;AAClC,UAAMC,SAAS,GAAGxI,OAAO,CAAC,cAAD,CAAP,CAAwBwI,SAA1C;;AACAvG,IAAAA,OAAO,CAACwG,SAAR,GAAoB,IAAID,SAAJ,CAAc5F,WAAd,EAA2BX,OAA3B,CAApB;AACAA,IAAAA,OAAO,CAACyG,aAAR,GAAwBzG,OAAO,CAACwG,SAAR,CAAkBC,aAA1C;AACD,GAfmE,CAiBpE;;;AACA,MAAI7F,QAAJ;;AACA,MAAIuF,YAAY,KAAK,QAArB,EAA+B;AAC7BvF,IAAAA,QAAQ,GAAG,IAAIzC,MAAJ,CAAW4F,OAAX,EAAoB/D,OAApB,CAAX;AACD,GAFD,MAEO,IAAImG,YAAY,KAAK,YAArB,EAAmC;AACxCvF,IAAAA,QAAQ,GAAG,IAAInC,OAAJ,CAAYsF,OAAZ,EAAqB/D,OAArB,CAAX;AACD,GAFM,MAEA,IAAImG,YAAY,KAAK,SAArB,EAAgC;AACrCvF,IAAAA,QAAQ,GAAG,IAAIxC,cAAJ,CAAmB4B,OAAO,CAAC+D,OAA3B,EAAoC/D,OAApC,CAAX;AACAiG,IAAAA,gCAAgC,CAACtF,WAAD,CAAhC;AACD,GA1BmE,CA4BpE;;;AACAD,EAAAA,YAAY,CAACC,WAAD,EAAcC,QAAd,CAAZ,CA7BoE,CA+BpE;;AACAmE,EAAAA,WAAW,CAACpE,WAAD,EAAcC,QAAd,CAAX,CAhCoE,CAkCpE;;AACAI,EAAAA,cAAc,CAACL,WAAD,EAAcC,QAAd,CAAd,CAnCoE,CAqCpE;;AACA,MAAIZ,OAAO,CAACyG,aAAZ,EAA2B;AACzBzG,IAAAA,OAAO,CAACyG,aAAR,CAAsBC,IAAtB,CAA2BzD,GAAG,IAAI;AAChC,UAAIA,GAAJ,EAAS;AACPb,QAAAA,QAAQ,CAACa,GAAD,CAAR;AACA;AACD;;AAEDrC,MAAAA,QAAQ,CAACsB,OAAT,CAAiBlC,OAAjB,EAA0BiD,GAAG,IAAI;AAC/B,YAAIA,GAAJ,EAAS;AACPrC,UAAAA,QAAQ,CAAC+E,KAAT,CAAe,IAAf;AACAvD,UAAAA,QAAQ,CAACa,GAAD,CAAR;AACA;AACD;;AAEDjD,QAAAA,OAAO,CAACwG,SAAR,CAAkBG,qBAAlB,CAAwCC,KAAK,IAAI;AAC/C,cAAIA,KAAJ,EAAW,OAAOxE,QAAQ,CAACwE,KAAD,CAAf;AACXxE,UAAAA,QAAQ,CAACyE,SAAD,EAAYjG,QAAZ,CAAR;AACD,SAHD;AAID,OAXD;AAYD,KAlBD;AAoBA;AACD,GA5DmE,CA8DpE;;;AACAA,EAAAA,QAAQ,CAACsB,OAAT,CAAiBlC,OAAjB,EAA0BiD,GAAG,IAAI;AAC/B,QAAIA,GAAJ,EAAS;AACPrC,MAAAA,QAAQ,CAAC+E,KAAT,CAAe,IAAf;AACA,aAAOvD,QAAQ,CAACa,GAAD,CAAf;AACD;;AAEDb,IAAAA,QAAQ,CAACyE,SAAD,EAAYjG,QAAZ,CAAR;AACA;AACD,GARD;AASD;;AAED,SAASyC,oBAAT,CAA8B2B,YAA9B,EAA4ChF,OAA5C,EAAqD;AACnD,QAAM8G,YAAY,GAAG,CACnB,QADmB,EAEnB,QAFmB,EAGnB,IAHmB,EAInB,SAJmB,EAKnB,YALmB,EAMnB,gBANmB,EAOnB,YAPmB,EAQnB,gBARmB,CAArB;AAUA,QAAMC,OAAO,GAAG,CAAC,aAAD,EAAgB,aAAhB,EAA+B,gBAA/B,CAAhB;AACA,QAAMC,IAAI,GAAG,CAAC,GAAD,EAAM,UAAN,EAAkB,GAAlB,EAAuB,SAAvB,EAAkC,OAAlC,EAA2C,cAA3C,CAAb;;AAEA,OAAK,MAAM7G,IAAX,IAAmBH,OAAnB,EAA4B;AAC1B,QAAIgH,IAAI,CAAC5G,OAAL,CAAaD,IAAI,CAACM,WAAL,EAAb,MAAqC,CAAC,CAA1C,EAA6C;AAC3C;AACD,KAFD,MAEO,IAAIsG,OAAO,CAAC3G,OAAR,CAAgBD,IAAI,CAACM,WAAL,EAAhB,MAAwC,CAAC,CAA7C,EAAgD;AACrDuE,MAAAA,YAAY,CAAC7E,IAAD,CAAZ,GAAqBH,OAAO,CAACG,IAAD,CAA5B;AACD,KAFM,MAEA,IAAI2G,YAAY,CAAC1G,OAAb,CAAqBD,IAAI,CAACM,WAAL,EAArB,MAA6C,CAAC,CAAlD,EAAqD;AAC1DuE,MAAAA,YAAY,GAAGiC,YAAY,CAACjC,YAAD,EAAehF,OAAO,CAACG,IAAD,CAAtB,EAA8B,KAA9B,CAA3B;AACD,KAFM,MAEA;AACL,UACEH,OAAO,CAACG,IAAD,CAAP,IACA,OAAOH,OAAO,CAACG,IAAD,CAAd,KAAyB,QADzB,IAEA,CAAC+G,MAAM,CAACC,QAAP,CAAgBnH,OAAO,CAACG,IAAD,CAAvB,CAFD,IAGA,CAACiH,KAAK,CAACC,OAAN,CAAcrH,OAAO,CAACG,IAAD,CAArB,CAJH,EAKE;AACA6E,QAAAA,YAAY,GAAGiC,YAAY,CAACjC,YAAD,EAAehF,OAAO,CAACG,IAAD,CAAtB,EAA8B,IAA9B,CAA3B;AACD,OAPD,MAOO;AACL6E,QAAAA,YAAY,CAAC7E,IAAD,CAAZ,GAAqBH,OAAO,CAACG,IAAD,CAA5B;AACD;AACF;AACF,GAjCkD,CAmCnD;AACA;AACA;;;AACA,QAAMmH,mBAAmB,GAAGtI,YAAY,CAAC6E,WAAb,CAAyB7D,OAAzB,CAA5B;;AACA,MAAIsH,mBAAJ,EAAyB;AACvBtC,IAAAA,YAAY,CAAClB,YAAb,GAA4BzB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB0C,YAAY,CAAClB,YAA/B,EAA6CwD,mBAA7C,CAA5B;AACD;;AAED,SAAOtC,YAAP;AACD;;AAED,SAASd,mBAAT,CAA6BhF,MAA7B,EAAqCqI,QAArC,EAA+CnD,QAA/C,EAAyDpE,OAAzD,EAAkE;AAChEA,EAAAA,OAAO,GAAGqC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtC,OAAlB,CAAV,CADgE,CAGhE;AACA;;AACA,QAAMwH,MAAM,GAAGxH,OAAO,CAACyH,UAAR,IAAsBzH,OAAO,CAAC0H,MAA9B,IAAwC1H,OAAO,CAAC2H,MAA/D,CALgE,CAOhE;;AACA,QAAMC,gBAAgB,GAAG5H,OAAO,CAACmF,aAAR,IAAyB,SAAlD;AACA,QAAMA,aAAa,GAAGyC,gBAAgB,CAACC,WAAjB,EAAtB;AACA,QAAMC,mBAAmB,GAAG9H,OAAO,CAAC+H,uBAApC;;AAEA,MAAI,CAACrI,qBAAqB,CAAC6F,GAAtB,CAA0BJ,aAA1B,CAAL,EAA+C;AAC7C,UAAMjH,UAAU,CAAC8J,MAAX,CAAkB;AACtBrD,MAAAA,OAAO,EAAG,4BAA2BiD,gBAAiB,wCADhC;AAEtBK,MAAAA,MAAM,EAAE;AAFc,KAAlB,CAAN;AAID;;AAED,SAAO,IAAIhK,gBAAJ,CAAqB;AAC1BiK,IAAAA,SAAS,EAAE7I,2BAA2B,CAAC8F,aAAD,CADZ;AAE1B2C,IAAAA,mBAF0B;AAG1BN,IAAAA,MAH0B;AAI1BD,IAAAA,QAJ0B;AAK1BnD,IAAAA;AAL0B,GAArB,CAAP;AAOD;;AAED,SAASpB,yBAAT,CAAmCG,MAAnC,EAA2C;AACzC,SAAO8D,YAAY,CAAC5D,oBAAoB,CAAC,EAAD,EAAKF,MAAL,CAArB,EAAmCA,MAAnC,EAA2C,KAA3C,CAAnB;AACD;;AAED,SAAS8D,YAAT,CAAsBkB,MAAtB,EAA8BX,MAA9B,EAAsCY,OAAtC,EAA+C;AAC7C,OAAK,MAAMjI,IAAX,IAAmBqH,MAAnB,EAA2B;AACzB,QAAIA,MAAM,CAACrH,IAAD,CAAN,IAAgB,OAAOqH,MAAM,CAACrH,IAAD,CAAb,KAAwB,QAAxC,IAAoDiI,OAAxD,EAAiE;AAC/DD,MAAAA,MAAM,GAAGlB,YAAY,CAACkB,MAAD,EAASX,MAAM,CAACrH,IAAD,CAAf,EAAuBiI,OAAvB,CAArB;AACD,KAFD,MAEO;AACLD,MAAAA,MAAM,CAAChI,IAAD,CAAN,GAAeqH,MAAM,CAACrH,IAAD,CAArB;AACD;AACF;;AAED,SAAOgI,MAAP;AACD;;AAED,SAASpD,WAAT,CAAqBpE,WAArB,EAAkCC,QAAlC,EAA4C;AAC1C,QAAMyH,qBAAqB,GAAG,CAC5B;AACA,kBAF4B,EAG5B,kBAH4B,EAI5B,eAJ4B,EAM5B;AACA,iBAP4B,EAQ5B,cAR4B,EAS5B,0BAT4B,EAU5B,wBAV4B,EAW5B,0BAX4B,EAY5B,uBAZ4B,EAa5B,iBAb4B,EAc5B,gBAd4B,EAe5B,4BAf4B,EAiB5B;AACA,UAlB4B,EAmB5B,MAnB4B,EAoB5B,MApB4B,EAqB5B,IArB4B,EAsB5BnI,MAtB4B,CAsBrBjB,gBAtBqB,CAA9B;AAwBAoJ,EAAAA,qBAAqB,CAAChH,OAAtB,CAA8BC,KAAK,IAAI;AACrCV,IAAAA,QAAQ,CAACC,EAAT,CAAYS,KAAZ,EAAmB,CAACK,OAAD,EAAUC,OAAV,KAAsB;AACvCjB,MAAAA,WAAW,CAACmE,IAAZ,CAAiBxD,KAAjB,EAAwBK,OAAxB,EAAiCC,OAAjC;AACD,KAFD;AAGD,GAJD;AAKD,C,CAED;AACA;AACA;;;AACA,SAASmE,YAAT,CAAsBpF,WAAtB,EAAmC2H,MAAnC,EAA2C;AACzC,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAAM,CAACtE,MAA3B,EAAmCuE,CAAC,EAApC,EAAwC;AACtC5H,IAAAA,WAAW,CAACmE,IAAZ,CAAiBwD,MAAM,CAACC,CAAD,CAAN,CAAUjH,KAA3B,EAAkCgH,MAAM,CAACC,CAAD,CAAN,CAAU5G,OAA5C,EAAqD2G,MAAM,CAACC,CAAD,CAAN,CAAU3G,OAA/D;AACD;AACF;;AAED,SAASmB,mBAAT,CAA6BG,OAA7B,EAAsC;AACpC,MAAIC,MAAM,GAAGd,MAAM,CAACC,MAAP,CAAc;AAAEyB,IAAAA,OAAO,EAAEb,OAAO,CAACsF;AAAnB,GAAd,EAA0CtF,OAAO,CAAClD,OAAlD,CAAb;;AACA,OAAK,IAAIG,IAAT,IAAiBgD,MAAjB,EAAyB;AACvB,UAAMsF,aAAa,GAAGnI,kBAAkB,CAACH,IAAD,CAAxC;;AACA,QAAIsI,aAAJ,EAAmB;AACjBtF,MAAAA,MAAM,CAACsF,aAAD,CAAN,GAAwBtF,MAAM,CAAChD,IAAD,CAA9B;AACD;AACF;;AAED,QAAMuI,WAAW,GAAGxF,OAAO,CAACU,IAAR,IAAgBV,OAAO,CAACU,IAAR,CAAa2D,QAAjD;AACA,QAAMoB,gBAAgB,GAAGzF,OAAO,CAAClD,OAAR,IAAmBkD,OAAO,CAAClD,OAAR,CAAgBmF,aAA5D;;AACA,MAAIuD,WAAW,IAAIC,gBAAnB,EAAqC;AACnCxF,IAAAA,MAAM,CAACS,IAAP,GAAcvB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBY,OAAO,CAACU,IAA1B,CAAd;;AACA,QAAIT,MAAM,CAACS,IAAP,CAAYgF,EAAhB,EAAoB;AAClBzF,MAAAA,MAAM,CAACsE,UAAP,GAAoBtE,MAAM,CAACsE,UAAP,IAAqBtE,MAAM,CAACS,IAAP,CAAYgF,EAArD;AACD;;AAED,QAAIzF,MAAM,CAACS,IAAP,CAAY2D,QAAhB,EAA0B;AACxBpE,MAAAA,MAAM,CAACS,IAAP,CAAYO,IAAZ,GAAmBhB,MAAM,CAACS,IAAP,CAAY2D,QAA/B;AACD;AACF;;AAED,MAAIrE,OAAO,CAAC2F,eAAZ,EAA6B;AAC3B1F,IAAAA,MAAM,CAACwE,MAAP,GAAgBzE,OAAO,CAAC2F,eAAxB;AACD;;AAED,MAAI1F,MAAM,CAAC2F,WAAX,EAAwB;AACtB3F,IAAAA,MAAM,CAAC4F,QAAP,GAAkB5F,MAAM,CAAC2F,WAAzB;AACD;;AAED,MAAI3F,MAAM,CAAC6F,gBAAX,EAA6B;AAC3B7F,IAAAA,MAAM,CAAC8F,WAAP,GAAqB,IAAI1K,WAAJ,CAAgB4E,MAAM,CAAC6F,gBAAvB,CAArB;AACD;;AAED,MAAI7F,MAAM,CAAC+F,UAAX,EAAuB;AACrB/F,IAAAA,MAAM,CAACgG,QAAP,GAAkBhG,MAAM,CAAC+F,UAAzB;AACA/F,IAAAA,MAAM,CAAC+F,UAAP,GAAoBrC,SAApB;AACD;;AAED,MAAI3D,OAAO,CAACkG,OAAZ,EAAqB;AACnBjG,IAAAA,MAAM,CAACiG,OAAP,GAAiBlG,OAAO,CAACkG,OAAzB;AACD,GAzCmC,CA2CpC;AACA;;;AACA,QAAMC,MAAM,GAAG,CAAC,GAAD,EAAM,UAAN,EAAkB,GAAlB,EAAuB,SAAvB,EAAkC,OAAlC,CAAf;;AACA,OAAK,MAAMC,GAAX,IAAkBD,MAAlB,EAA0B;AACxB,QAAIlG,MAAM,CAACmG,GAAD,CAAN,KAAgBzC,SAApB,EAA+B;AAC7B,UAAI1D,MAAM,CAACW,YAAP,KAAwB+C,SAA5B,EAAuC1D,MAAM,CAACW,YAAP,GAAsB,EAAtB;AACvCX,MAAAA,MAAM,CAACW,YAAP,CAAoBwF,GAApB,IAA2BnG,MAAM,CAACmG,GAAD,CAAjC;AACAnG,MAAAA,MAAM,CAACmG,GAAD,CAAN,GAAczC,SAAd;AACD;AACF;;AAED,SAAO1D,MAAP;AACD;;AAED,SAASsC,gBAAT,CAA0BzF,OAA1B,EAAmCoG,kBAAnC,EAAuD;AACrDA,EAAAA,kBAAkB,GAAG/D,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB;AAAE+D,IAAAA,aAAa,EAAE;AAAjB,GAAlB,EAA2CD,kBAA3C,CAArB,CADqD,CAGrD;;AACA,MAAI,OAAOpG,OAAO,CAAC0D,cAAf,KAAkC,QAAlC,IAA8C,OAAO1D,OAAO,CAACiF,eAAf,KAAmC,QAArF,EAA+F;AAC7FjF,IAAAA,OAAO,CAAC0D,cAAR,GAAyB,IAAIlF,cAAJ,CAAmBwB,OAAO,CAAC0D,cAAR,IAA0B1D,OAAO,CAACiF,eAArD,CAAzB;AACD,GANoD,CAQrD;;;AACA,MAAIjF,OAAO,CAAC0D,cAAR,KAA2B1D,OAAO,CAACuJ,kBAAR,IAA8BvJ,OAAO,CAACwJ,oBAAjE,CAAJ,EAA4F;AAC1FxJ,IAAAA,OAAO,CAAC0D,cAAR,CAAuB+F,IAAvB,GAA8BzJ,OAAO,CAACuJ,kBAAR,IAA8BvJ,OAAO,CAACwJ,oBAApE;AACD,GAXoD,CAarD;;;AACA,MAAIxJ,OAAO,CAAC0J,mBAAZ,EAAiC;AAC/B1J,IAAAA,OAAO,CAAC0D,cAAR,CAAuBgG,mBAAvB,GAA6C1J,OAAO,CAAC0J,mBAArD;AACD,GAhBoD,CAkBrD;;;AACA,MAAI1J,OAAO,CAACsD,eAAR,IAA2B,IAA/B,EAAqCtD,OAAO,CAACsD,eAAR,GAA0B,CAA1B;AACrC,MAAItD,OAAO,CAACuD,gBAAR,IAA4B,IAAhC,EAAsCvD,OAAO,CAACuD,gBAAR,GAA2B,KAA3B;;AAEtC,MAAI,CAAC6C,kBAAkB,CAACC,aAAxB,EAAuC;AACrC;AACD,GAxBoD,CA0BrD;;;AACA,SAAOrG,OAAO,CAAC+D,OAAR,CAAgB4F,GAAhB,CAAoBC,SAAS,IAAI;AACtC,WAAOA,SAAS,CAACC,aAAV,GACH,IAAInL,MAAJ,CAAWkL,SAAS,CAACC,aAArB,EAAoC,KAApC,EAA2C7J,OAA3C,CADG,GAEH,IAAItB,MAAJ,CAAWkL,SAAS,CAACE,IAArB,EAA2BF,SAAS,CAACG,IAArC,EAA2C/J,OAA3C,CAFJ;AAGD,GAJM,CAAP;AAKD;;AAEDgK,MAAM,CAACC,OAAP,GAAiB;AAAElK,EAAAA,YAAF;AAAgBmC,EAAAA;AAAhB,CAAjB","sourcesContent":["'use strict';\r\n\r\nconst deprecate = require('util').deprecate;\r\nconst Logger = require('../core').Logger;\r\nconst MongoCredentials = require('../core').MongoCredentials;\r\nconst MongoError = require('../core').MongoError;\r\nconst Mongos = require('../topologies/mongos');\r\nconst NativeTopology = require('../topologies/native_topology');\r\nconst parse = require('../core').parseConnectionString;\r\nconst ReadConcern = require('../read_concern');\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst ReplSet = require('../topologies/replset');\r\nconst Server = require('../topologies/server');\r\nconst ServerSessionPool = require('../core').Sessions.ServerSessionPool;\r\nconst emitDeprecationWarning = require('../utils').emitDeprecationWarning;\r\nconst emitWarningOnce = require('../utils').emitWarningOnce;\r\nconst fs = require('fs');\r\nconst WriteConcern = require('../write_concern');\r\nconst CMAP_EVENT_NAMES = require('../cmap/events').CMAP_EVENT_NAMES;\r\n\r\nlet client;\r\nfunction loadClient() {\r\n  if (!client) {\r\n    client = require('../mongo_client');\r\n  }\r\n  return client;\r\n}\r\n\r\nconst legacyParse = deprecate(\r\n  require('../url_parser'),\r\n  'current URL string parser is deprecated, and will be removed in a future version. ' +\r\n    'To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.'\r\n);\r\n\r\nconst AUTH_MECHANISM_INTERNAL_MAP = {\r\n  DEFAULT: 'default',\r\n  PLAIN: 'plain',\r\n  GSSAPI: 'gssapi',\r\n  'MONGODB-CR': 'mongocr',\r\n  'MONGODB-X509': 'x509',\r\n  'MONGODB-AWS': 'mongodb-aws',\r\n  'SCRAM-SHA-1': 'scram-sha-1',\r\n  'SCRAM-SHA-256': 'scram-sha-256'\r\n};\r\n\r\nconst monitoringEvents = [\r\n  'timeout',\r\n  'close',\r\n  'serverOpening',\r\n  'serverDescriptionChanged',\r\n  'serverHeartbeatStarted',\r\n  'serverHeartbeatSucceeded',\r\n  'serverHeartbeatFailed',\r\n  'serverClosed',\r\n  'topologyOpening',\r\n  'topologyClosed',\r\n  'topologyDescriptionChanged',\r\n  'commandStarted',\r\n  'commandSucceeded',\r\n  'commandFailed',\r\n  'joined',\r\n  'left',\r\n  'ping',\r\n  'ha',\r\n  'all',\r\n  'fullsetup',\r\n  'open'\r\n];\r\n\r\nconst VALID_AUTH_MECHANISMS = new Set([\r\n  'DEFAULT',\r\n  'PLAIN',\r\n  'GSSAPI',\r\n  'MONGODB-CR',\r\n  'MONGODB-X509',\r\n  'MONGODB-AWS',\r\n  'SCRAM-SHA-1',\r\n  'SCRAM-SHA-256'\r\n]);\r\n\r\nconst validOptionNames = [\r\n  'poolSize',\r\n  'ssl',\r\n  'sslValidate',\r\n  'sslCA',\r\n  'sslCert',\r\n  'sslKey',\r\n  'sslPass',\r\n  'sslCRL',\r\n  'autoReconnect',\r\n  'noDelay',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'connectTimeoutMS',\r\n  'family',\r\n  'socketTimeoutMS',\r\n  'reconnectTries',\r\n  'reconnectInterval',\r\n  'ha',\r\n  'haInterval',\r\n  'replicaSet',\r\n  'secondaryAcceptableLatencyMS',\r\n  'acceptableLatencyMS',\r\n  'connectWithNoPrimary',\r\n  'authSource',\r\n  'w',\r\n  'wtimeout',\r\n  'j',\r\n  'writeConcern',\r\n  'forceServerObjectId',\r\n  'serializeFunctions',\r\n  'ignoreUndefined',\r\n  'raw',\r\n  'bufferMaxEntries',\r\n  'readPreference',\r\n  'pkFactory',\r\n  'promiseLibrary',\r\n  'readConcern',\r\n  'maxStalenessSeconds',\r\n  'loggerLevel',\r\n  'logger',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'promoteLongs',\r\n  'domainsEnabled',\r\n  'checkServerIdentity',\r\n  'validateOptions',\r\n  'appname',\r\n  'auth',\r\n  'user',\r\n  'password',\r\n  'authMechanism',\r\n  'compression',\r\n  'fsync',\r\n  'readPreferenceTags',\r\n  'numberOfRetries',\r\n  'auto_reconnect',\r\n  'minSize',\r\n  'monitorCommands',\r\n  'retryWrites',\r\n  'retryReads',\r\n  'useNewUrlParser',\r\n  'useUnifiedTopology',\r\n  'serverSelectionTimeoutMS',\r\n  'useRecoveryToken',\r\n  'autoEncryption',\r\n  'driverInfo',\r\n  'tls',\r\n  'tlsInsecure',\r\n  'tlsinsecure',\r\n  'tlsAllowInvalidCertificates',\r\n  'tlsAllowInvalidHostnames',\r\n  'tlsCAFile',\r\n  'tlsCertificateFile',\r\n  'tlsCertificateKeyFile',\r\n  'tlsCertificateKeyFilePassword',\r\n  'minHeartbeatFrequencyMS',\r\n  'heartbeatFrequencyMS',\r\n  'directConnection',\r\n  'appName',\r\n\r\n  // CMAP options\r\n  'maxPoolSize',\r\n  'minPoolSize',\r\n  'maxIdleTimeMS',\r\n  'waitQueueTimeoutMS'\r\n];\r\n\r\nconst ignoreOptionNames = ['native_parser'];\r\nconst legacyOptionNames = ['server', 'replset', 'replSet', 'mongos', 'db'];\r\n\r\n// Validate options object\r\nfunction validOptions(options) {\r\n  const _validOptions = validOptionNames.concat(legacyOptionNames);\r\n\r\n  for (const name in options) {\r\n    if (ignoreOptionNames.indexOf(name) !== -1) {\r\n      continue;\r\n    }\r\n\r\n    if (_validOptions.indexOf(name) === -1) {\r\n      if (options.validateOptions) {\r\n        return new MongoError(`option ${name} is not supported`);\r\n      } else {\r\n        emitWarningOnce(`the options [${name}] is not supported`);\r\n      }\r\n    }\r\n\r\n    if (legacyOptionNames.indexOf(name) !== -1) {\r\n      emitWarningOnce(\r\n        `the server/replset/mongos/db options are deprecated, ` +\r\n          `all their options are supported at the top level of the options object [${validOptionNames}]`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nconst LEGACY_OPTIONS_MAP = validOptionNames.reduce((obj, name) => {\r\n  obj[name.toLowerCase()] = name;\r\n  return obj;\r\n}, {});\r\n\r\nfunction addListeners(mongoClient, topology) {\r\n  topology.on('authenticated', createListener(mongoClient, 'authenticated'));\r\n  topology.on('error', createListener(mongoClient, 'error'));\r\n  topology.on('timeout', createListener(mongoClient, 'timeout'));\r\n  topology.on('close', createListener(mongoClient, 'close'));\r\n  topology.on('parseError', createListener(mongoClient, 'parseError'));\r\n  topology.once('open', createListener(mongoClient, 'open'));\r\n  topology.once('fullsetup', createListener(mongoClient, 'fullsetup'));\r\n  topology.once('all', createListener(mongoClient, 'all'));\r\n  topology.on('reconnect', createListener(mongoClient, 'reconnect'));\r\n}\r\n\r\nfunction assignTopology(client, topology) {\r\n  client.topology = topology;\r\n\r\n  if (!(topology instanceof NativeTopology)) {\r\n    topology.s.sessionPool = new ServerSessionPool(topology.s.coreTopology);\r\n  }\r\n}\r\n\r\n// Clear out all events\r\nfunction clearAllEvents(topology) {\r\n  monitoringEvents.forEach(event => topology.removeAllListeners(event));\r\n}\r\n\r\n// Collect all events in order from SDAM\r\nfunction collectEvents(mongoClient, topology) {\r\n  let MongoClient = loadClient();\r\n  const collectedEvents = [];\r\n\r\n  if (mongoClient instanceof MongoClient) {\r\n    monitoringEvents.forEach(event => {\r\n      topology.on(event, (object1, object2) => {\r\n        if (event === 'open') {\r\n          collectedEvents.push({ event: event, object1: mongoClient });\r\n        } else {\r\n          collectedEvents.push({ event: event, object1: object1, object2: object2 });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  return collectedEvents;\r\n}\r\n\r\nfunction resolveTLSOptions(options) {\r\n  if (options.tls == null) {\r\n    return;\r\n  }\r\n\r\n  ['sslCA', 'sslKey', 'sslCert'].forEach(optionName => {\r\n    if (options[optionName]) {\r\n      options[optionName] = fs.readFileSync(options[optionName]);\r\n    }\r\n  });\r\n}\r\n\r\nfunction connect(mongoClient, url, options, callback) {\r\n  options = Object.assign({}, options);\r\n\r\n  // If callback is null throw an exception\r\n  if (callback == null) {\r\n    throw new Error('no callback function provided');\r\n  }\r\n\r\n  let didRequestAuthentication = false;\r\n  const logger = Logger('MongoClient', options);\r\n\r\n  // Did we pass in a Server/ReplSet/Mongos\r\n  if (url instanceof Server || url instanceof ReplSet || url instanceof Mongos) {\r\n    return connectWithUrl(mongoClient, url, options, connectCallback);\r\n  }\r\n\r\n  const useNewUrlParser = options.useNewUrlParser !== false;\r\n\r\n  const parseFn = useNewUrlParser ? parse : legacyParse;\r\n  const transform = useNewUrlParser ? transformUrlOptions : legacyTransformUrlOptions;\r\n\r\n  parseFn(url, options, (err, _object) => {\r\n    // Do not attempt to connect if parsing error\r\n    if (err) return callback(err);\r\n\r\n    // Flatten\r\n    const object = transform(_object);\r\n\r\n    // Parse the string\r\n    const _finalOptions = createUnifiedOptions(object, options);\r\n\r\n    // Check if we have connection and socket timeout set\r\n    if (_finalOptions.socketTimeoutMS == null) _finalOptions.socketTimeoutMS = 0;\r\n    if (_finalOptions.connectTimeoutMS == null) _finalOptions.connectTimeoutMS = 10000;\r\n    if (_finalOptions.retryWrites == null) _finalOptions.retryWrites = true;\r\n    if (_finalOptions.useRecoveryToken == null) _finalOptions.useRecoveryToken = true;\r\n    if (_finalOptions.readPreference == null) _finalOptions.readPreference = 'primary';\r\n\r\n    if (_finalOptions.db_options && _finalOptions.db_options.auth) {\r\n      delete _finalOptions.db_options.auth;\r\n    }\r\n\r\n    // resolve tls options if needed\r\n    resolveTLSOptions(_finalOptions);\r\n\r\n    // Store the merged options object\r\n    mongoClient.s.options = _finalOptions;\r\n\r\n    // Apply read and write concern from parsed url\r\n    mongoClient.s.readPreference = ReadPreference.fromOptions(_finalOptions);\r\n    mongoClient.s.writeConcern = WriteConcern.fromOptions(_finalOptions);\r\n\r\n    // Failure modes\r\n    if (object.servers.length === 0) {\r\n      return callback(new Error('connection string must contain at least one seed host'));\r\n    }\r\n\r\n    if (_finalOptions.auth && !_finalOptions.credentials) {\r\n      try {\r\n        didRequestAuthentication = true;\r\n        _finalOptions.credentials = generateCredentials(\r\n          mongoClient,\r\n          _finalOptions.auth.user,\r\n          _finalOptions.auth.password,\r\n          _finalOptions\r\n        );\r\n      } catch (err) {\r\n        return callback(err);\r\n      }\r\n    }\r\n\r\n    if (_finalOptions.useUnifiedTopology) {\r\n      return createTopology(mongoClient, 'unified', _finalOptions, connectCallback);\r\n    }\r\n\r\n    emitWarningOnce(\r\n      'Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.'\r\n    );\r\n\r\n    // Do we have a replicaset then skip discovery and go straight to connectivity\r\n    if (_finalOptions.replicaSet || _finalOptions.rs_name) {\r\n      return createTopology(mongoClient, 'replicaset', _finalOptions, connectCallback);\r\n    } else if (object.servers.length > 1) {\r\n      return createTopology(mongoClient, 'mongos', _finalOptions, connectCallback);\r\n    } else {\r\n      return createServer(mongoClient, _finalOptions, connectCallback);\r\n    }\r\n  });\r\n\r\n  function connectCallback(err, topology) {\r\n    const warningMessage = `seed list contains no mongos proxies, replicaset connections requires the parameter replicaSet to be supplied in the URI or options object, mongodb://server:port/db?replicaSet=name`;\r\n    if (err && err.message === 'no mongos proxies found in seed list') {\r\n      if (logger.isWarn()) {\r\n        logger.warn(warningMessage);\r\n      }\r\n\r\n      // Return a more specific error message for MongoClient.connect\r\n      return callback(new MongoError(warningMessage));\r\n    }\r\n\r\n    if (didRequestAuthentication) {\r\n      mongoClient.emit('authenticated', null, true);\r\n    }\r\n\r\n    // Return the error and db instance\r\n    callback(err, topology);\r\n  }\r\n}\r\n\r\nfunction connectWithUrl(mongoClient, url, options, connectCallback) {\r\n  // Set the topology\r\n  assignTopology(mongoClient, url);\r\n\r\n  // Add listeners\r\n  addListeners(mongoClient, url);\r\n\r\n  // Propagate the events to the client\r\n  relayEvents(mongoClient, url);\r\n\r\n  let finalOptions = Object.assign({}, options);\r\n\r\n  // If we have a readPreference passed in by the db options, convert it from a string\r\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\r\n    finalOptions.readPreference = new ReadPreference(\r\n      options.readPreference || options.read_preference\r\n    );\r\n  }\r\n\r\n  const isDoingAuth = finalOptions.user || finalOptions.password || finalOptions.authMechanism;\r\n  if (isDoingAuth && !finalOptions.credentials) {\r\n    try {\r\n      finalOptions.credentials = generateCredentials(\r\n        mongoClient,\r\n        finalOptions.user,\r\n        finalOptions.password,\r\n        finalOptions\r\n      );\r\n    } catch (err) {\r\n      return connectCallback(err, url);\r\n    }\r\n  }\r\n\r\n  return url.connect(finalOptions, connectCallback);\r\n}\r\n\r\nfunction createListener(mongoClient, event) {\r\n  const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);\r\n  return (v1, v2) => {\r\n    if (eventSet.has(event)) {\r\n      return mongoClient.emit(event, mongoClient);\r\n    }\r\n\r\n    mongoClient.emit(event, v1, v2);\r\n  };\r\n}\r\n\r\nfunction createServer(mongoClient, options, callback) {\r\n  // Pass in the promise library\r\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\r\n\r\n  // Set default options\r\n  const servers = translateOptions(options);\r\n\r\n  const server = servers[0];\r\n\r\n  // Propagate the events to the client\r\n  const collectedEvents = collectEvents(mongoClient, server);\r\n\r\n  // Connect to topology\r\n  server.connect(options, (err, topology) => {\r\n    if (err) {\r\n      server.close(true);\r\n      return callback(err);\r\n    }\r\n    // Clear out all the collected event listeners\r\n    clearAllEvents(server);\r\n\r\n    // Relay all the events\r\n    relayEvents(mongoClient, server);\r\n    // Add listeners\r\n    addListeners(mongoClient, server);\r\n    // Check if we are really speaking to a mongos\r\n    const ismaster = topology.lastIsMaster();\r\n\r\n    // Set the topology\r\n    assignTopology(mongoClient, topology);\r\n\r\n    // Do we actually have a mongos\r\n    if (ismaster && ismaster.msg === 'isdbgrid') {\r\n      // Destroy the current connection\r\n      topology.close();\r\n      // Create mongos connection instead\r\n      return createTopology(mongoClient, 'mongos', options, callback);\r\n    }\r\n\r\n    // Fire all the events\r\n    replayEvents(mongoClient, collectedEvents);\r\n    // Otherwise callback\r\n    callback(err, topology);\r\n  });\r\n}\r\n\r\nconst DEPRECATED_UNIFIED_EVENTS = new Set([\r\n  'reconnect',\r\n  'reconnectFailed',\r\n  'attemptReconnect',\r\n  'joined',\r\n  'left',\r\n  'ping',\r\n  'ha',\r\n  'all',\r\n  'fullsetup',\r\n  'open'\r\n]);\r\n\r\nfunction registerDeprecatedEventNotifiers(client) {\r\n  client.on('newListener', eventName => {\r\n    if (DEPRECATED_UNIFIED_EVENTS.has(eventName)) {\r\n      emitDeprecationWarning(\r\n        `The \\`${eventName}\\` event is no longer supported by the unified topology, please read more by visiting http://bit.ly/2D8WfT6`,\r\n        'DeprecationWarning'\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nfunction createTopology(mongoClient, topologyType, options, callback) {\r\n  // Pass in the promise library\r\n  options.promiseLibrary = mongoClient.s.promiseLibrary;\r\n\r\n  const translationOptions = {};\r\n  if (topologyType === 'unified') translationOptions.createServers = false;\r\n\r\n  // Set default options\r\n  const servers = translateOptions(options, translationOptions);\r\n\r\n  // determine CSFLE support\r\n  if (options.autoEncryption != null) {\r\n    const Encrypter = require('../encrypter').Encrypter;\r\n    options.encrypter = new Encrypter(mongoClient, options);\r\n    options.autoEncrypter = options.encrypter.autoEncrypter;\r\n  }\r\n\r\n  // Create the topology\r\n  let topology;\r\n  if (topologyType === 'mongos') {\r\n    topology = new Mongos(servers, options);\r\n  } else if (topologyType === 'replicaset') {\r\n    topology = new ReplSet(servers, options);\r\n  } else if (topologyType === 'unified') {\r\n    topology = new NativeTopology(options.servers, options);\r\n    registerDeprecatedEventNotifiers(mongoClient);\r\n  }\r\n\r\n  // Add listeners\r\n  addListeners(mongoClient, topology);\r\n\r\n  // Propagate the events to the client\r\n  relayEvents(mongoClient, topology);\r\n\r\n  // Open the connection\r\n  assignTopology(mongoClient, topology);\r\n\r\n  // initialize CSFLE if requested\r\n  if (options.autoEncrypter) {\r\n    options.autoEncrypter.init(err => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      topology.connect(options, err => {\r\n        if (err) {\r\n          topology.close(true);\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        options.encrypter.connectInternalClient(error => {\r\n          if (error) return callback(error);\r\n          callback(undefined, topology);\r\n        });\r\n      });\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  // otherwise connect normally\r\n  topology.connect(options, err => {\r\n    if (err) {\r\n      topology.close(true);\r\n      return callback(err);\r\n    }\r\n\r\n    callback(undefined, topology);\r\n    return;\r\n  });\r\n}\r\n\r\nfunction createUnifiedOptions(finalOptions, options) {\r\n  const childOptions = [\r\n    'mongos',\r\n    'server',\r\n    'db',\r\n    'replset',\r\n    'db_options',\r\n    'server_options',\r\n    'rs_options',\r\n    'mongos_options'\r\n  ];\r\n  const noMerge = ['readconcern', 'compression', 'autoencryption'];\r\n  const skip = ['w', 'wtimeout', 'j', 'journal', 'fsync', 'writeConcern'];\r\n\r\n  for (const name in options) {\r\n    if (skip.indexOf(name.toLowerCase()) !== -1) {\r\n      continue;\r\n    } else if (noMerge.indexOf(name.toLowerCase()) !== -1) {\r\n      finalOptions[name] = options[name];\r\n    } else if (childOptions.indexOf(name.toLowerCase()) !== -1) {\r\n      finalOptions = mergeOptions(finalOptions, options[name], false);\r\n    } else {\r\n      if (\r\n        options[name] &&\r\n        typeof options[name] === 'object' &&\r\n        !Buffer.isBuffer(options[name]) &&\r\n        !Array.isArray(options[name])\r\n      ) {\r\n        finalOptions = mergeOptions(finalOptions, options[name], true);\r\n      } else {\r\n        finalOptions[name] = options[name];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Handle write concern keys separately, since `options` may have the keys at the top level or\r\n  // under `options.writeConcern`. The final merged keys will be under `finalOptions.writeConcern`.\r\n  // This way, `fromOptions` will warn once if `options` is using deprecated write concern options\r\n  const optionsWriteConcern = WriteConcern.fromOptions(options);\r\n  if (optionsWriteConcern) {\r\n    finalOptions.writeConcern = Object.assign({}, finalOptions.writeConcern, optionsWriteConcern);\r\n  }\r\n\r\n  return finalOptions;\r\n}\r\n\r\nfunction generateCredentials(client, username, password, options) {\r\n  options = Object.assign({}, options);\r\n\r\n  // the default db to authenticate against is 'self'\r\n  // if authententicate is called from a retry context, it may be another one, like admin\r\n  const source = options.authSource || options.authdb || options.dbName;\r\n\r\n  // authMechanism\r\n  const authMechanismRaw = options.authMechanism || 'DEFAULT';\r\n  const authMechanism = authMechanismRaw.toUpperCase();\r\n  const mechanismProperties = options.authMechanismProperties;\r\n\r\n  if (!VALID_AUTH_MECHANISMS.has(authMechanism)) {\r\n    throw MongoError.create({\r\n      message: `authentication mechanism ${authMechanismRaw} not supported', options.authMechanism`,\r\n      driver: true\r\n    });\r\n  }\r\n\r\n  return new MongoCredentials({\r\n    mechanism: AUTH_MECHANISM_INTERNAL_MAP[authMechanism],\r\n    mechanismProperties,\r\n    source,\r\n    username,\r\n    password\r\n  });\r\n}\r\n\r\nfunction legacyTransformUrlOptions(object) {\r\n  return mergeOptions(createUnifiedOptions({}, object), object, false);\r\n}\r\n\r\nfunction mergeOptions(target, source, flatten) {\r\n  for (const name in source) {\r\n    if (source[name] && typeof source[name] === 'object' && flatten) {\r\n      target = mergeOptions(target, source[name], flatten);\r\n    } else {\r\n      target[name] = source[name];\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction relayEvents(mongoClient, topology) {\r\n  const serverOrCommandEvents = [\r\n    // APM\r\n    'commandStarted',\r\n    'commandSucceeded',\r\n    'commandFailed',\r\n\r\n    // SDAM\r\n    'serverOpening',\r\n    'serverClosed',\r\n    'serverDescriptionChanged',\r\n    'serverHeartbeatStarted',\r\n    'serverHeartbeatSucceeded',\r\n    'serverHeartbeatFailed',\r\n    'topologyOpening',\r\n    'topologyClosed',\r\n    'topologyDescriptionChanged',\r\n\r\n    // Legacy\r\n    'joined',\r\n    'left',\r\n    'ping',\r\n    'ha'\r\n  ].concat(CMAP_EVENT_NAMES);\r\n\r\n  serverOrCommandEvents.forEach(event => {\r\n    topology.on(event, (object1, object2) => {\r\n      mongoClient.emit(event, object1, object2);\r\n    });\r\n  });\r\n}\r\n\r\n//\r\n// Replay any events due to single server connection switching to Mongos\r\n//\r\nfunction replayEvents(mongoClient, events) {\r\n  for (let i = 0; i < events.length; i++) {\r\n    mongoClient.emit(events[i].event, events[i].object1, events[i].object2);\r\n  }\r\n}\r\n\r\nfunction transformUrlOptions(_object) {\r\n  let object = Object.assign({ servers: _object.hosts }, _object.options);\r\n  for (let name in object) {\r\n    const camelCaseName = LEGACY_OPTIONS_MAP[name];\r\n    if (camelCaseName) {\r\n      object[camelCaseName] = object[name];\r\n    }\r\n  }\r\n\r\n  const hasUsername = _object.auth && _object.auth.username;\r\n  const hasAuthMechanism = _object.options && _object.options.authMechanism;\r\n  if (hasUsername || hasAuthMechanism) {\r\n    object.auth = Object.assign({}, _object.auth);\r\n    if (object.auth.db) {\r\n      object.authSource = object.authSource || object.auth.db;\r\n    }\r\n\r\n    if (object.auth.username) {\r\n      object.auth.user = object.auth.username;\r\n    }\r\n  }\r\n\r\n  if (_object.defaultDatabase) {\r\n    object.dbName = _object.defaultDatabase;\r\n  }\r\n\r\n  if (object.maxPoolSize) {\r\n    object.poolSize = object.maxPoolSize;\r\n  }\r\n\r\n  if (object.readConcernLevel) {\r\n    object.readConcern = new ReadConcern(object.readConcernLevel);\r\n  }\r\n\r\n  if (object.wTimeoutMS) {\r\n    object.wtimeout = object.wTimeoutMS;\r\n    object.wTimeoutMS = undefined;\r\n  }\r\n\r\n  if (_object.srvHost) {\r\n    object.srvHost = _object.srvHost;\r\n  }\r\n\r\n  // Any write concern options from the URL will be top-level, so we manually\r\n  // move them options under `object.writeConcern` to avoid warnings later\r\n  const wcKeys = ['w', 'wtimeout', 'j', 'journal', 'fsync'];\r\n  for (const key of wcKeys) {\r\n    if (object[key] !== undefined) {\r\n      if (object.writeConcern === undefined) object.writeConcern = {};\r\n      object.writeConcern[key] = object[key];\r\n      object[key] = undefined;\r\n    }\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\nfunction translateOptions(options, translationOptions) {\r\n  translationOptions = Object.assign({}, { createServers: true }, translationOptions);\r\n\r\n  // If we have a readPreference passed in by the db options\r\n  if (typeof options.readPreference === 'string' || typeof options.read_preference === 'string') {\r\n    options.readPreference = new ReadPreference(options.readPreference || options.read_preference);\r\n  }\r\n\r\n  // Do we have readPreference tags, add them\r\n  if (options.readPreference && (options.readPreferenceTags || options.read_preference_tags)) {\r\n    options.readPreference.tags = options.readPreferenceTags || options.read_preference_tags;\r\n  }\r\n\r\n  // Do we have maxStalenessSeconds\r\n  if (options.maxStalenessSeconds) {\r\n    options.readPreference.maxStalenessSeconds = options.maxStalenessSeconds;\r\n  }\r\n\r\n  // Set the socket and connection timeouts\r\n  if (options.socketTimeoutMS == null) options.socketTimeoutMS = 0;\r\n  if (options.connectTimeoutMS == null) options.connectTimeoutMS = 10000;\r\n\r\n  if (!translationOptions.createServers) {\r\n    return;\r\n  }\r\n\r\n  // Create server instances\r\n  return options.servers.map(serverObj => {\r\n    return serverObj.domain_socket\r\n      ? new Server(serverObj.domain_socket, 27017, options)\r\n      : new Server(serverObj.host, serverObj.port, options);\r\n  });\r\n}\r\n\r\nmodule.exports = { validOptions, connect };\r\n"]},"metadata":{},"sourceType":"script"}