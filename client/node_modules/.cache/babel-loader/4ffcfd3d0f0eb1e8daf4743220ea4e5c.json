{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      host: server.description.host,\n      port: server.description.port,\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials; // ensure encryption is not requested for monitoring\n\n    delete connectOptions.autoEncrypter;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    const topologyVersion = this[kServer].description.topologyVersion;\n\n    if (isInCloseState(this) || topologyVersion == null) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // restart monitor\n\n    stateTransition(this, STATE_IDLE); // restart monitoring\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // close monitor\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction resetMonitorState(monitor) {\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({\n      force: true\n    });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({\n        force: true\n      });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = {\n      ismaster: true\n    };\n    const options = {\n      socketTimeout: connectTimeoutMS\n    };\n\n    if (isAwaitable) {\n      cmd.maxAwaitTimeMS = maxAwaitTimeMS;\n      cmd.topologyVersion = makeTopologyVersion(topologyVersion);\n\n      if (connectTimeoutMS) {\n        options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;\n      }\n\n      options.exhaustAllowed = true;\n\n      if (monitor[kRTTPinger] == null) {\n        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n      }\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const rttPinger = monitor[kRTTPinger];\n      const duration = isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\n      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    } // TODO: the next line is a legacy event, remove in v4\n\n\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n  }\n\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', {\n    ismaster: 1\n  }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/core/sdam/monitor.js"],"names":["ServerType","require","EventEmitter","connect","Connection","common","makeStateMachine","MongoNetworkError","BSON","retrieveBSON","makeInterruptableAsyncInterval","calculateDurationInMs","now","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","connectOptions","assign","id","host","port","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","credentials","autoEncrypter","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","reset","topologyVersion","resetMonitorState","close","emit","stop","clearTimeout","destroy","force","checkServer","callback","start","failureHandler","err","closed","maxAwaitTimeMS","isAwaitable","cmd","ismaster","socketTimeout","makeTopologyVersion","exhaustAllowed","RTTPinger","command","result","isMaster","rttPinger","duration","roundTripTime","conn","done","process","nextTick","type","Unknown","setTimeout","tv","processId","counter","Long","fromNumber","cancellationToken","measureRoundTripTime","measureAndReschedule","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst ServerType = require('./common').ServerType;\r\nconst EventEmitter = require('events');\r\nconst connect = require('../connection/connect');\r\nconst Connection = require('../../cmap/connection').Connection;\r\nconst common = require('./common');\r\nconst makeStateMachine = require('../utils').makeStateMachine;\r\nconst MongoNetworkError = require('../error').MongoNetworkError;\r\nconst BSON = require('../connection/utils').retrieveBSON();\r\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\r\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\r\nconst now = require('../../utils').now;\r\n\r\nconst sdamEvents = require('./events');\r\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\r\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\r\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\r\n\r\nconst kServer = Symbol('server');\r\nconst kMonitorId = Symbol('monitorId');\r\nconst kConnection = Symbol('connection');\r\nconst kCancellationToken = Symbol('cancellationToken');\r\nconst kRTTPinger = Symbol('rttPinger');\r\nconst kRoundTripTime = Symbol('roundTripTime');\r\n\r\nconst STATE_CLOSED = common.STATE_CLOSED;\r\nconst STATE_CLOSING = common.STATE_CLOSING;\r\nconst STATE_IDLE = 'idle';\r\nconst STATE_MONITORING = 'monitoring';\r\nconst stateTransition = makeStateMachine({\r\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\r\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\r\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\r\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\r\n});\r\n\r\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\r\n\r\nfunction isInCloseState(monitor) {\r\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\r\n}\r\n\r\nclass Monitor extends EventEmitter {\r\n  constructor(server, options) {\r\n    super(options);\r\n\r\n    this[kServer] = server;\r\n    this[kConnection] = undefined;\r\n    this[kCancellationToken] = new EventEmitter();\r\n    this[kCancellationToken].setMaxListeners(Infinity);\r\n    this[kMonitorId] = null;\r\n    this.s = {\r\n      state: STATE_CLOSED\r\n    };\r\n\r\n    this.address = server.description.address;\r\n    this.options = Object.freeze({\r\n      connectTimeoutMS:\r\n        typeof options.connectionTimeout === 'number'\r\n          ? options.connectionTimeout\r\n          : typeof options.connectTimeoutMS === 'number'\r\n          ? options.connectTimeoutMS\r\n          : 10000,\r\n      heartbeatFrequencyMS:\r\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\r\n      minHeartbeatFrequencyMS:\r\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\r\n    });\r\n\r\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\r\n    const connectOptions = Object.assign(\r\n      {\r\n        id: '<monitor>',\r\n        host: server.description.host,\r\n        port: server.description.port,\r\n        bson: server.s.bson,\r\n        connectionType: Connection\r\n      },\r\n      server.s.options,\r\n      this.options,\r\n\r\n      // force BSON serialization options\r\n      {\r\n        raw: false,\r\n        promoteLongs: true,\r\n        promoteValues: true,\r\n        promoteBuffers: true\r\n      }\r\n    );\r\n\r\n    // ensure no authentication is used for monitoring\r\n    delete connectOptions.credentials;\r\n\r\n    // ensure encryption is not requested for monitoring\r\n    delete connectOptions.autoEncrypter;\r\n\r\n    this.connectOptions = Object.freeze(connectOptions);\r\n  }\r\n\r\n  connect() {\r\n    if (this.s.state !== STATE_CLOSED) {\r\n      return;\r\n    }\r\n\r\n    // start\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\r\n      interval: heartbeatFrequencyMS,\r\n      minInterval: minHeartbeatFrequencyMS,\r\n      immediate: true\r\n    });\r\n  }\r\n\r\n  requestCheck() {\r\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\r\n      return;\r\n    }\r\n\r\n    this[kMonitorId].wake();\r\n  }\r\n\r\n  reset() {\r\n    const topologyVersion = this[kServer].description.topologyVersion;\r\n    if (isInCloseState(this) || topologyVersion == null) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // restart monitor\r\n    stateTransition(this, STATE_IDLE);\r\n\r\n    // restart monitoring\r\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\r\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\r\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\r\n      interval: heartbeatFrequencyMS,\r\n      minInterval: minHeartbeatFrequencyMS\r\n    });\r\n  }\r\n\r\n  close() {\r\n    if (isInCloseState(this)) {\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, STATE_CLOSING);\r\n    resetMonitorState(this);\r\n\r\n    // close monitor\r\n    this.emit('close');\r\n    stateTransition(this, STATE_CLOSED);\r\n  }\r\n}\r\n\r\nfunction resetMonitorState(monitor) {\r\n  if (monitor[kMonitorId]) {\r\n    monitor[kMonitorId].stop();\r\n    monitor[kMonitorId] = null;\r\n  }\r\n\r\n  if (monitor[kRTTPinger]) {\r\n    monitor[kRTTPinger].close();\r\n    monitor[kRTTPinger] = undefined;\r\n  }\r\n\r\n  monitor[kCancellationToken].emit('cancel');\r\n  if (monitor[kMonitorId]) {\r\n    clearTimeout(monitor[kMonitorId]);\r\n    monitor[kMonitorId] = undefined;\r\n  }\r\n\r\n  if (monitor[kConnection]) {\r\n    monitor[kConnection].destroy({ force: true });\r\n  }\r\n}\r\n\r\nfunction checkServer(monitor, callback) {\r\n  let start = now();\r\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\r\n\r\n  function failureHandler(err) {\r\n    if (monitor[kConnection]) {\r\n      monitor[kConnection].destroy({ force: true });\r\n      monitor[kConnection] = undefined;\r\n    }\r\n\r\n    monitor.emit(\r\n      'serverHeartbeatFailed',\r\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\r\n    );\r\n\r\n    monitor.emit('resetServer', err);\r\n    monitor.emit('resetConnectionPool');\r\n    callback(err);\r\n  }\r\n\r\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\r\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\r\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\r\n    const topologyVersion = monitor[kServer].description.topologyVersion;\r\n    const isAwaitable = topologyVersion != null;\r\n\r\n    const cmd = { ismaster: true };\r\n    const options = { socketTimeout: connectTimeoutMS };\r\n\r\n    if (isAwaitable) {\r\n      cmd.maxAwaitTimeMS = maxAwaitTimeMS;\r\n      cmd.topologyVersion = makeTopologyVersion(topologyVersion);\r\n      if (connectTimeoutMS) {\r\n        options.socketTimeout = connectTimeoutMS + maxAwaitTimeMS;\r\n      }\r\n      options.exhaustAllowed = true;\r\n      if (monitor[kRTTPinger] == null) {\r\n        monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\r\n      }\r\n    }\r\n\r\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\r\n      if (err) {\r\n        failureHandler(err);\r\n        return;\r\n      }\r\n\r\n      const isMaster = result.result;\r\n      const rttPinger = monitor[kRTTPinger];\r\n\r\n      const duration =\r\n        isAwaitable && rttPinger ? rttPinger.roundTripTime : calculateDurationInMs(start);\r\n\r\n      monitor.emit(\r\n        'serverHeartbeatSucceeded',\r\n        new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)\r\n      );\r\n\r\n      // if we are using the streaming protocol then we immediately issue another `started`\r\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\r\n      if (isAwaitable && isMaster.topologyVersion) {\r\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\r\n        start = now();\r\n      } else {\r\n        if (monitor[kRTTPinger]) {\r\n          monitor[kRTTPinger].close();\r\n          monitor[kRTTPinger] = undefined;\r\n        }\r\n\r\n        callback(undefined, isMaster);\r\n      }\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  // connecting does an implicit `ismaster`\r\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\r\n    if (conn && isInCloseState(monitor)) {\r\n      conn.destroy({ force: true });\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      monitor[kConnection] = undefined;\r\n\r\n      // we already reset the connection pool on network errors in all cases\r\n      if (!(err instanceof MongoNetworkError)) {\r\n        monitor.emit('resetConnectionPool');\r\n      }\r\n\r\n      failureHandler(err);\r\n      return;\r\n    }\r\n\r\n    monitor[kConnection] = conn;\r\n    monitor.emit(\r\n      'serverHeartbeatSucceeded',\r\n      new ServerHeartbeatSucceededEvent(\r\n        calculateDurationInMs(start),\r\n        conn.ismaster,\r\n        monitor.address\r\n      )\r\n    );\r\n\r\n    callback(undefined, conn.ismaster);\r\n  });\r\n}\r\n\r\nfunction monitorServer(monitor) {\r\n  return callback => {\r\n    stateTransition(monitor, STATE_MONITORING);\r\n    function done() {\r\n      if (!isInCloseState(monitor)) {\r\n        stateTransition(monitor, STATE_IDLE);\r\n      }\r\n\r\n      callback();\r\n    }\r\n\r\n    // TODO: the next line is a legacy event, remove in v4\r\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\r\n\r\n    checkServer(monitor, (err, isMaster) => {\r\n      if (err) {\r\n        // otherwise an error occured on initial discovery, also bail\r\n        if (monitor[kServer].description.type === ServerType.Unknown) {\r\n          monitor.emit('resetServer', err);\r\n          return done();\r\n        }\r\n      }\r\n\r\n      // if the check indicates streaming is supported, immediately reschedule monitoring\r\n      if (isMaster && isMaster.topologyVersion) {\r\n        setTimeout(() => {\r\n          if (!isInCloseState(monitor)) {\r\n            monitor[kMonitorId].wake();\r\n          }\r\n        });\r\n      }\r\n\r\n      done();\r\n    });\r\n  };\r\n}\r\n\r\nfunction makeTopologyVersion(tv) {\r\n  return {\r\n    processId: tv.processId,\r\n    counter: BSON.Long.fromNumber(tv.counter)\r\n  };\r\n}\r\n\r\nclass RTTPinger {\r\n  constructor(cancellationToken, options) {\r\n    this[kConnection] = null;\r\n    this[kCancellationToken] = cancellationToken;\r\n    this[kRoundTripTime] = 0;\r\n    this.closed = false;\r\n\r\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\r\n  }\r\n\r\n  get roundTripTime() {\r\n    return this[kRoundTripTime];\r\n  }\r\n\r\n  close() {\r\n    this.closed = true;\r\n\r\n    clearTimeout(this[kMonitorId]);\r\n    this[kMonitorId] = undefined;\r\n\r\n    if (this[kConnection]) {\r\n      this[kConnection].destroy({ force: true });\r\n    }\r\n  }\r\n}\r\n\r\nfunction measureRoundTripTime(rttPinger, options) {\r\n  const start = now();\r\n  const cancellationToken = rttPinger[kCancellationToken];\r\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\r\n  if (rttPinger.closed) {\r\n    return;\r\n  }\r\n\r\n  function measureAndReschedule(conn) {\r\n    if (rttPinger.closed) {\r\n      conn.destroy({ force: true });\r\n      return;\r\n    }\r\n\r\n    if (rttPinger[kConnection] == null) {\r\n      rttPinger[kConnection] = conn;\r\n    }\r\n\r\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\r\n    rttPinger[kMonitorId] = setTimeout(\r\n      () => measureRoundTripTime(rttPinger, options),\r\n      heartbeatFrequencyMS\r\n    );\r\n  }\r\n\r\n  if (rttPinger[kConnection] == null) {\r\n    connect(options, cancellationToken, (err, conn) => {\r\n      if (err) {\r\n        rttPinger[kConnection] = undefined;\r\n        rttPinger[kRoundTripTime] = 0;\r\n        return;\r\n      }\r\n\r\n      measureAndReschedule(conn);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  rttPinger[kConnection].command('admin.$cmd', { ismaster: 1 }, err => {\r\n    if (err) {\r\n      rttPinger[kConnection] = undefined;\r\n      rttPinger[kRoundTripTime] = 0;\r\n      return;\r\n    }\r\n\r\n    measureAndReschedule();\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  Monitor\r\n};\r\n"]},"metadata":{},"sourceType":"script"}