{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst ServerDescription = require('./server_description').ServerDescription;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst TopologyType = require('./common').TopologyType; // contstants related to compatability checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION; // Representation of a deployment of servers\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    options = options || {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null; // save this locally, but don't display when printing the instance out\n\n    Object.defineProperty(this, 'options', {\n      value: options,\n      enumberable: false\n    }); // determine server compatibility\n\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = null;\n\n    for (const addressServerTuple of this.servers) {\n      const server = addressServerTuple[1];\n\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, this.options, null);\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n    // potentially mutated values\n\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        topologyType = result[0], setName = result[1];\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId);\n        topologyType = result[0], setName = result[1], maxSetVersion = result[2], maxElectionId = result[3];\n      } else if ([ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, this.options);\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n\n    return undefined;\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, setName, serverDescription, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb/lib/core/sdam/topology_description.js"],"names":["ServerType","require","ServerDescription","WIRE_CONSTANTS","TopologyType","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","TopologyDescription","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","type","Unknown","servers","Map","stale","compatible","compatibilityError","logicalSessionTimeoutMinutes","heartbeatFrequencyMS","localThresholdMS","Object","defineProperty","value","enumberable","serverDescription","values","minWireVersion","address","maxWireVersion","addressServerTuple","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","has","delete","size","set","update","serverType","Single","Standalone","topologyTypeForServerType","Sharded","Mongos","indexOf","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","RSSecondary","RSArbiter","RSOther","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","undefined","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","RSGhost","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","keys","get","allHosts","forEach","currentAddresses","responseAddresses","addr","TypeError","me","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nconst ServerType = require('./common').ServerType;\nconst ServerDescription = require('./server_description').ServerDescription;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst TopologyType = require('./common').TopologyType;\n\n// contstants related to compatability checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\n\n// Representation of a deployment of servers\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   *\n   * @param {string} topologyType\n   * @param {Map<string, ServerDescription>} serverDescriptions the a map of address to ServerDescription\n   * @param {string} setName\n   * @param {number} maxSetVersion\n   * @param {ObjectId} maxElectionId\n   */\n  constructor(\n    topologyType,\n    serverDescriptions,\n    setName,\n    maxSetVersion,\n    maxElectionId,\n    commonWireVersion,\n    options\n  ) {\n    options = options || {};\n\n    // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n    this.type = topologyType || TopologyType.Unknown;\n    this.setName = setName || null;\n    this.maxSetVersion = maxSetVersion || null;\n    this.maxElectionId = maxElectionId || null;\n    this.servers = serverDescriptions || new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.compatibilityError = null;\n    this.logicalSessionTimeoutMinutes = null;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 0;\n    this.localThresholdMS = options.localThresholdMS || 0;\n    this.commonWireVersion = commonWireVersion || null;\n\n    // save this locally, but don't display when printing the instance out\n    Object.defineProperty(this, 'options', { value: options, enumberable: false });\n\n    // determine server compatibility\n    for (const serverDescription of this.servers.values()) {\n      if (serverDescription.type === ServerType.Unknown) continue;\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    }\n\n    // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n    this.logicalSessionTimeoutMinutes = null;\n    for (const addressServerTuple of this.servers) {\n      const server = addressServerTuple[1];\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = null;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        }\n\n        // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n        this.logicalSessionTimeoutMinutes = Math.min(\n          this.logicalSessionTimeoutMinutes,\n          server.logicalSessionTimeoutMinutes\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @param {SrvPollingEvent} ev The event\n   */\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n    for (const server of this.servers) {\n      if (newAddresses.has(server[0])) {\n        newAddresses.delete(server[0]);\n      } else {\n        serverDescriptions.delete(server[0]);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const address of newAddresses) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n\n    return new TopologyDescription(\n      this.type,\n      serverDescriptions,\n      this.setName,\n      this.maxSetVersion,\n      this.maxElectionId,\n      this.commonWireVersion,\n      this.options,\n      null\n    );\n  }\n\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   *\n   * @param {ServerDescription} serverDescription\n   */\n  update(serverDescription) {\n    const address = serverDescription.address;\n    // NOTE: there are a number of prime targets for refactoring here\n    //       once we support destructuring assignments\n\n    // potentially mutated values\n    let topologyType = this.type;\n    let setName = this.setName;\n    let maxSetVersion = this.maxSetVersion;\n    let maxElectionId = this.maxElectionId;\n    let commonWireVersion = this.commonWireVersion;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new ServerDescription(address, null);\n    }\n\n    const serverType = serverDescription.type;\n    let serverDescriptions = new Map(this.servers);\n\n    // update common wire version\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    }\n\n    // update the actual server description\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(\n        TopologyType.Single,\n        serverDescriptions,\n        setName,\n        maxSetVersion,\n        maxElectionId,\n        commonWireVersion,\n        this.options\n      );\n    }\n\n    if (topologyType === TopologyType.Unknown) {\n      if (serverType === ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === TopologyType.Sharded) {\n      if ([ServerType.Mongos, ServerType.Unknown].indexOf(serverType) === -1) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetNoPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription);\n        (topologyType = result[0]), (setName = result[1]);\n      }\n    }\n\n    if (topologyType === TopologyType.ReplicaSetWithPrimary) {\n      if ([ServerType.Standalone, ServerType.Mongos].indexOf(serverType) >= 0) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(\n          serverDescriptions,\n          setName,\n          serverDescription,\n          maxSetVersion,\n          maxElectionId\n        );\n\n        (topologyType = result[0]),\n          (setName = result[1]),\n          (maxSetVersion = result[2]),\n          (maxElectionId = result[3]);\n      } else if (\n        [ServerType.RSSecondary, ServerType.RSArbiter, ServerType.RSOther].indexOf(serverType) >= 0\n      ) {\n        topologyType = updateRsWithPrimaryFromMember(\n          serverDescriptions,\n          setName,\n          serverDescription\n        );\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(\n      topologyType,\n      serverDescriptions,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion,\n      this.options\n    );\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines if the topology description has any known servers\n   */\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== ServerType.Unknown);\n  }\n\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n\n  /**\n   * Determines if the topology has a definition for the provided address\n   *\n   * @param {String} address\n   * @return {Boolean} Whether the topology knows about this server\n   */\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n}\n\nfunction topologyTypeForServerType(serverType) {\n  if (serverType === ServerType.Standalone) {\n    return TopologyType.Single;\n  }\n\n  if (serverType === ServerType.Mongos) {\n    return TopologyType.Sharded;\n  }\n\n  if (serverType === ServerType.RSPrimary) {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  if (serverType === ServerType.RSGhost || serverType === ServerType.Unknown) {\n    return TopologyType.Unknown;\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(\n  serverDescriptions,\n  setName,\n  serverDescription,\n  maxSetVersion,\n  maxElectionId\n) {\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (\n        maxSetVersion > serverDescription.setVersion ||\n        compareObjectId(maxElectionId, electionId) > 0\n      ) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(\n          serverDescription.address,\n          new ServerDescription(serverDescription.address)\n        );\n\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (\n    serverDescription.setVersion != null &&\n    (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)\n  ) {\n    maxSetVersion = serverDescription.setVersion;\n  }\n\n  // We've heard from the primary. Is it the same primary as before?\n  for (const address of serverDescriptions.keys()) {\n    const server = serverDescriptions.get(address);\n\n    if (server.type === ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new ServerDescription(server.address));\n\n      // There can only be one primary\n      break;\n    }\n  }\n\n  // Discover new hosts from this primary's response.\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  // Remove hosts not in the response.\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses\n    .filter(addr => responseAddresses.indexOf(addr) === -1)\n    .forEach(address => {\n      serverDescriptions.delete(address);\n    });\n\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  if (setName == null) {\n    throw new TypeError('setName is required');\n  }\n\n  if (\n    setName !== serverDescription.setName ||\n    (serverDescription.me && serverDescription.address !== serverDescription.me)\n  ) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, setName, serverDescription) {\n  let topologyType = TopologyType.ReplicaSetNoPrimary;\n\n  setName = setName || serverDescription.setName;\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const addr of serverDescriptions.keys()) {\n    if (serverDescriptions.get(addr).type === ServerType.RSPrimary) {\n      return TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return TopologyType.ReplicaSetNoPrimary;\n}\n\nmodule.exports = {\n  TopologyDescription\n};\n"]},"metadata":{},"sourceType":"script"}