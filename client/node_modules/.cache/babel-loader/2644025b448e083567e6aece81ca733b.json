{"ast":null,"code":"'use strict';\n\nvar Long = require('../long').Long,\n    Double = require('../double').Double,\n    Timestamp = require('../timestamp').Timestamp,\n    ObjectID = require('../objectid').ObjectID,\n    Symbol = require('../symbol').Symbol,\n    Code = require('../code').Code,\n    MinKey = require('../min_key').MinKey,\n    MaxKey = require('../max_key').MaxKey,\n    Decimal128 = require('../decimal128'),\n    Int32 = require('../int_32'),\n    DBRef = require('../db_ref').DBRef,\n    BSONRegExp = require('../regexp').BSONRegExp,\n    Binary = require('../binary').Binary;\n\nvar utils = require('./utils');\n\nvar deserialize = function (buffer, options, isArray) {\n  options = options == null ? {} : options;\n  var index = options && options.index ? options.index : 0; // Read the document size\n\n  var size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; // Ensure buffer is valid size\n\n  if (size < 5 || buffer.length < size || size + index > buffer.length) {\n    throw new Error('corrupt bson message');\n  } // Illegal end value\n\n\n  if (buffer[index + size - 1] !== 0) {\n    throw new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  } // Start deserializtion\n\n\n  return deserializeObject(buffer, index, options, isArray);\n};\n\nvar deserializeObject = function (buffer, index, options, isArray) {\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\n  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\n  if (!cacheFunctionsCrc32) var crc32 = null;\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw']; // Return raw bson buffer instead of parsing it\n\n  var raw = options['raw'] == null ? false : options['raw']; // Return BSONRegExp objects instead of native regular expressions\n\n  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false; // Controls the promotion of values vs wrapper classes\n\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues']; // Set the start index\n\n  var startIndex = index; // Validate that we have at least 4 bytes of buffer\n\n  if (buffer.length < 5) throw new Error('corrupt bson message < 5 bytes long'); // Read the document size\n\n  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Ensure buffer is valid size\n\n  if (size < 5 || size > buffer.length) throw new Error('corrupt bson message'); // Create holding object\n\n  var object = isArray ? [] : {}; // Used for arrays to skip having to perform utf8 decoding\n\n  var arrayIndex = 0;\n  var done = false; // While we have more left data left keep parsing\n  // while (buffer[index + 1] !== 0) {\n\n  while (!done) {\n    // Read the type\n    var elementType = buffer[index++]; // If we get a zero it's the last byte, exit\n\n    if (elementType === 0) break; // Get the start search index\n\n    var i = index; // Locate the end of the c string\n\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    } // If are at the end of the buffer there is a problem with the document\n\n\n    if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\n    index = i + 1;\n\n    if (elementType === BSON.BSON_DATA_STRING) {\n      var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_OID) {\n      var oid = utils.allocBuffer(12);\n      buffer.copy(oid, 0, index, index + 12);\n      object[name] = new ObjectID(oid);\n      index = index + 12;\n    } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {\n      object[name] = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n    } else if (elementType === BSON.BSON_DATA_INT) {\n      object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {\n      object[name] = new Double(buffer.readDoubleLE(index));\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_NUMBER) {\n      object[name] = buffer.readDoubleLE(index);\n      index = index + 8;\n    } else if (elementType === BSON.BSON_DATA_DATE) {\n      var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON.BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new Error('illegal boolean type value');\n      object[name] = buffer[index++] === 1;\n    } else if (elementType === BSON.BSON_DATA_OBJECT) {\n      var _index = index;\n      var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer.length - index) throw new Error('bad embedded document length in bson'); // We have a raw value\n\n      if (raw) {\n        object[name] = buffer.slice(index, index + objectSize);\n      } else {\n        object[name] = deserializeObject(buffer, _index, options, false);\n      }\n\n      index = index + objectSize;\n    } else if (elementType === BSON.BSON_DATA_ARRAY) {\n      _index = index;\n      objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      var arrayOptions = options; // Stop index\n\n      var stopIndex = index + objectSize; // All elements of array to be returned as raw bson\n\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {};\n\n        for (var n in options) arrayOptions[n] = options[n];\n\n        arrayOptions['raw'] = true;\n      }\n\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer[index - 1] !== 0) throw new Error('invalid array terminator byte');\n      if (index !== stopIndex) throw new Error('corrupted array bson');\n    } else if (elementType === BSON.BSON_DATA_UNDEFINED) {\n      object[name] = undefined;\n    } else if (elementType === BSON.BSON_DATA_NULL) {\n      object[name] = null;\n    } else if (elementType === BSON.BSON_DATA_LONG) {\n      // Unpack the low and high bits\n      lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var long = new Long(lowBits, highBits); // Promote the long if possible\n\n      if (promoteLongs && promoteValues === true) {\n        object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        object[name] = long;\n      }\n    } else if (elementType === BSON.BSON_DATA_DECIMAL128) {\n      // Buffer to contain the decimal bytes\n      var bytes = utils.allocBuffer(16); // Copy the next 16 bytes into the bytes buffer\n\n      buffer.copy(bytes, 0, index, index + 16); // Update index\n\n      index = index + 16; // Assign the new Decimal128 value\n\n      var decimal128 = new Decimal128(bytes); // If we have an alternative mapper use that\n\n      object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\n    } else if (elementType === BSON.BSON_DATA_BINARY) {\n      var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      var totalBinarySize = binarySize;\n      var subType = buffer[index++]; // Did we have a negative binary size, throw\n\n      if (binarySize < 0) throw new Error('Negative binary type element size found'); // Is the length longer than the document\n\n      if (binarySize > buffer.length) throw new Error('Binary type size larger than document size'); // Decode as raw Buffer object if options specifies it\n\n      if (buffer['slice'] != null) {\n        // If we have subtype 2 skip the 4 bytes for the size\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = buffer.slice(index, index + binarySize);\n        } else {\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\n        }\n      } else {\n        var _buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize); // If we have subtype 2 skip the 4 bytes for the size\n\n\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');\n          if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');\n        } // Copy the data\n\n\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n\n        if (promoteBuffers && promoteValues) {\n          object[name] = _buffer;\n        } else {\n          object[name] = new Binary(_buffer, subType);\n        }\n      } // Update the index\n\n\n      index = index + binarySize;\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {\n      // Get the start search index\n      i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string\n\n      var source = buffer.toString('utf8', index, i); // Create the regexp\n\n      index = i + 1; // Get the start search index\n\n      i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string\n\n      var regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1; // For each option add the corresponding one for javascript\n\n      var optionsArray = new Array(regExpOptions.length); // Parse options\n\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n\n      object[name] = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {\n      // Get the start search index\n      i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string\n\n      source = buffer.toString('utf8', index, i);\n      index = i + 1; // Get the start search index\n\n      i = index; // Locate the end of the c string\n\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      } // If are at the end of the buffer there is a problem with the document\n\n\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string\n\n      regExpOptions = buffer.toString('utf8', index, i);\n      index = i + 1; // Set the object\n\n      object[name] = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON.BSON_DATA_SYMBOL) {\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {\n      lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      object[name] = new Timestamp(lowBits, highBits);\n    } else if (elementType === BSON.BSON_DATA_MIN_KEY) {\n      object[name] = new MinKey();\n    } else if (elementType === BSON.BSON_DATA_MAX_KEY) {\n      object[name] = new MaxKey();\n    } else if (elementType === BSON.BSON_DATA_CODE) {\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1); // If we are evaluating the functions\n\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval\n\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n      } else {\n        object[name] = new Code(functionString);\n      } // Update parse index position\n\n\n      index = index + stringSize;\n    } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {\n      var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\n\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new Error('code_w_scope total size shorter minimum expected length');\n      } // Get the code string size\n\n\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Check if we have a valid string\n\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); // Javascript function\n\n      functionString = buffer.toString('utf8', index, index + stringSize - 1); // Update parse index position\n\n      index = index + stringSize; // Parse the element\n\n      _index = index; // Decode the size of the object document\n\n      objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24; // Decode the scope object\n\n      var scopeObject = deserializeObject(buffer, _index, options, false); // Adjust the index\n\n      index = index + objectSize; // Check if field length is to short\n\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to short, truncating scope');\n      } // Check if totalSize field is to long\n\n\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new Error('code_w_scope total size is to long, clips outer document');\n      } // If we are evaluating the functions\n\n\n      if (evalFunctions) {\n        // If we have cache enabled let's look for the md5 of the function in the cache\n        if (cacheFunctions) {\n          hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval\n\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\n        } else {\n          object[name] = isolateEval(functionString);\n        }\n\n        object[name].scope = scopeObject;\n      } else {\n        object[name] = new Code(functionString, scopeObject);\n      }\n    } else if (elementType === BSON.BSON_DATA_DBPOINTER) {\n      // Get the code string size\n      stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24; // Check if we have a valid string\n\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new Error('bad string length in bson'); // Namespace\n\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1); // Update parse index position\n\n      index = index + stringSize; // Read the oid\n\n      var oidBuffer = utils.allocBuffer(12);\n      buffer.copy(oidBuffer, 0, index, index + 12);\n      oid = new ObjectID(oidBuffer); // Update the index\n\n      index = index + 12; // Split the namespace\n\n      var parts = namespace.split('.');\n      var db = parts.shift();\n      var collection = parts.join('.'); // Upgrade to DBRef type\n\n      object[name] = new DBRef(collection, oid, db);\n    } else {\n      throw new Error('Detected unknown BSON type ' + elementType.toString(16) + ' for fieldname \"' + name + '\", are you using the latest BSON parser');\n    }\n  } // Check if the deserialization was against a valid array/object\n\n\n  if (size !== index - startIndex) {\n    if (isArray) throw new Error('corrupt array bson');\n    throw new Error('corrupt object bson');\n  } // Check if we have a db ref object\n\n\n  if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\n  return object;\n};\n/**\r\n * Ensure eval is isolated.\r\n *\r\n * @ignore\r\n * @api private\r\n */\n\n\nvar isolateEvalWithHash = function (functionCache, hash, functionString, object) {\n  // Contains the value we are going to set\n  var value = null; // Check for cache hit, eval if missing and return cached function\n\n  if (functionCache[hash] == null) {\n    eval('value = ' + functionString);\n    functionCache[hash] = value;\n  } // Set the object\n\n\n  return functionCache[hash].bind(object);\n};\n/**\r\n * Ensure eval is isolated.\r\n *\r\n * @ignore\r\n * @api private\r\n */\n\n\nvar isolateEval = function (functionString) {\n  // Contains the value we are going to set\n  var value = null; // Eval the function\n\n  eval('value = ' + functionString);\n  return value;\n};\n\nvar BSON = {};\n/**\r\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\r\n *\r\n * @ignore\r\n * @api private\r\n */\n\nvar functionCache = BSON.functionCache = {};\n/**\r\n * Number BSON Type\r\n *\r\n * @classconstant BSON_DATA_NUMBER\r\n **/\n\nBSON.BSON_DATA_NUMBER = 1;\n/**\r\n * String BSON Type\r\n *\r\n * @classconstant BSON_DATA_STRING\r\n **/\n\nBSON.BSON_DATA_STRING = 2;\n/**\r\n * Object BSON Type\r\n *\r\n * @classconstant BSON_DATA_OBJECT\r\n **/\n\nBSON.BSON_DATA_OBJECT = 3;\n/**\r\n * Array BSON Type\r\n *\r\n * @classconstant BSON_DATA_ARRAY\r\n **/\n\nBSON.BSON_DATA_ARRAY = 4;\n/**\r\n * Binary BSON Type\r\n *\r\n * @classconstant BSON_DATA_BINARY\r\n **/\n\nBSON.BSON_DATA_BINARY = 5;\n/**\r\n * Binary BSON Type\r\n *\r\n * @classconstant BSON_DATA_UNDEFINED\r\n **/\n\nBSON.BSON_DATA_UNDEFINED = 6;\n/**\r\n * ObjectID BSON Type\r\n *\r\n * @classconstant BSON_DATA_OID\r\n **/\n\nBSON.BSON_DATA_OID = 7;\n/**\r\n * Boolean BSON Type\r\n *\r\n * @classconstant BSON_DATA_BOOLEAN\r\n **/\n\nBSON.BSON_DATA_BOOLEAN = 8;\n/**\r\n * Date BSON Type\r\n *\r\n * @classconstant BSON_DATA_DATE\r\n **/\n\nBSON.BSON_DATA_DATE = 9;\n/**\r\n * null BSON Type\r\n *\r\n * @classconstant BSON_DATA_NULL\r\n **/\n\nBSON.BSON_DATA_NULL = 10;\n/**\r\n * RegExp BSON Type\r\n *\r\n * @classconstant BSON_DATA_REGEXP\r\n **/\n\nBSON.BSON_DATA_REGEXP = 11;\n/**\r\n * Code BSON Type\r\n *\r\n * @classconstant BSON_DATA_DBPOINTER\r\n **/\n\nBSON.BSON_DATA_DBPOINTER = 12;\n/**\r\n * Code BSON Type\r\n *\r\n * @classconstant BSON_DATA_CODE\r\n **/\n\nBSON.BSON_DATA_CODE = 13;\n/**\r\n * Symbol BSON Type\r\n *\r\n * @classconstant BSON_DATA_SYMBOL\r\n **/\n\nBSON.BSON_DATA_SYMBOL = 14;\n/**\r\n * Code with Scope BSON Type\r\n *\r\n * @classconstant BSON_DATA_CODE_W_SCOPE\r\n **/\n\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\n/**\r\n * 32 bit Integer BSON Type\r\n *\r\n * @classconstant BSON_DATA_INT\r\n **/\n\nBSON.BSON_DATA_INT = 16;\n/**\r\n * Timestamp BSON Type\r\n *\r\n * @classconstant BSON_DATA_TIMESTAMP\r\n **/\n\nBSON.BSON_DATA_TIMESTAMP = 17;\n/**\r\n * Long BSON Type\r\n *\r\n * @classconstant BSON_DATA_LONG\r\n **/\n\nBSON.BSON_DATA_LONG = 18;\n/**\r\n * Long BSON Type\r\n *\r\n * @classconstant BSON_DATA_DECIMAL128\r\n **/\n\nBSON.BSON_DATA_DECIMAL128 = 19;\n/**\r\n * MinKey BSON Type\r\n *\r\n * @classconstant BSON_DATA_MIN_KEY\r\n **/\n\nBSON.BSON_DATA_MIN_KEY = 0xff;\n/**\r\n * MaxKey BSON Type\r\n *\r\n * @classconstant BSON_DATA_MAX_KEY\r\n **/\n\nBSON.BSON_DATA_MAX_KEY = 0x7f;\n/**\r\n * Binary Default Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\n/**\r\n * Binary Function Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\n/**\r\n * Binary Byte Array Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\n/**\r\n * Binary UUID Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_UUID\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\n/**\r\n * Binary MD5 Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_MD5\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\n/**\r\n * Binary User Defined Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\r\n **/\n\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128; // BSON MAX VALUES\n\nBSON.BSON_INT32_MAX = 0x7fffffff;\nBSON.BSON_INT32_MIN = -0x80000000;\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\nBSON.BSON_INT64_MIN = -Math.pow(2, 63); // JS MAX PRECISE VALUES\n\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\n\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\n// Internal long versions\n\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\n\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\n\nmodule.exports = deserialize;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/bson/lib/bson/parser/deserializer.js"],"names":["Long","require","Double","Timestamp","ObjectID","Symbol","Code","MinKey","MaxKey","Decimal128","Int32","DBRef","BSONRegExp","Binary","utils","deserialize","buffer","options","isArray","index","size","length","Error","deserializeObject","evalFunctions","cacheFunctions","cacheFunctionsCrc32","crc32","fieldsAsRaw","raw","bsonRegExp","promoteBuffers","promoteLongs","promoteValues","startIndex","object","arrayIndex","done","elementType","i","name","toString","BSON","BSON_DATA_STRING","stringSize","BSON_DATA_OID","oid","allocBuffer","copy","BSON_DATA_INT","BSON_DATA_NUMBER","readDoubleLE","BSON_DATA_DATE","lowBits","highBits","Date","toNumber","BSON_DATA_BOOLEAN","BSON_DATA_OBJECT","_index","objectSize","slice","BSON_DATA_ARRAY","arrayOptions","stopIndex","n","BSON_DATA_UNDEFINED","undefined","BSON_DATA_NULL","BSON_DATA_LONG","long","lessThanOrEqual","JS_INT_MAX_LONG","greaterThanOrEqual","JS_INT_MIN_LONG","BSON_DATA_DECIMAL128","bytes","decimal128","toObject","BSON_DATA_BINARY","binarySize","totalBinarySize","subType","SUBTYPE_BYTE_ARRAY","_buffer","Uint8Array","ArrayBuffer","Array","BSON_DATA_REGEXP","source","regExpOptions","optionsArray","RegExp","join","BSON_DATA_SYMBOL","BSON_DATA_TIMESTAMP","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","BSON_DATA_CODE","functionString","hash","isolateEvalWithHash","functionCache","isolateEval","BSON_DATA_CODE_W_SCOPE","totalSize","scopeObject","scope","BSON_DATA_DBPOINTER","namespace","oidBuffer","parts","split","db","shift","collection","value","eval","bind","BSON_BINARY_SUBTYPE_DEFAULT","BSON_BINARY_SUBTYPE_FUNCTION","BSON_BINARY_SUBTYPE_BYTE_ARRAY","BSON_BINARY_SUBTYPE_UUID","BSON_BINARY_SUBTYPE_MD5","BSON_BINARY_SUBTYPE_USER_DEFINED","BSON_INT32_MAX","BSON_INT32_MIN","BSON_INT64_MAX","Math","pow","BSON_INT64_MIN","JS_INT_MAX","JS_INT_MIN","fromNumber","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Long = require('../long').Long,\r\n  Double = require('../double').Double,\r\n  Timestamp = require('../timestamp').Timestamp,\r\n  ObjectID = require('../objectid').ObjectID,\r\n  Symbol = require('../symbol').Symbol,\r\n  Code = require('../code').Code,\r\n  MinKey = require('../min_key').MinKey,\r\n  MaxKey = require('../max_key').MaxKey,\r\n  Decimal128 = require('../decimal128'),\r\n  Int32 = require('../int_32'),\r\n  DBRef = require('../db_ref').DBRef,\r\n  BSONRegExp = require('../regexp').BSONRegExp,\r\n  Binary = require('../binary').Binary;\r\n\r\nvar utils = require('./utils');\r\n\r\nvar deserialize = function(buffer, options, isArray) {\r\n  options = options == null ? {} : options;\r\n  var index = options && options.index ? options.index : 0;\r\n  // Read the document size\r\n  var size =\r\n    buffer[index] |\r\n    (buffer[index + 1] << 8) |\r\n    (buffer[index + 2] << 16) |\r\n    (buffer[index + 3] << 24);\r\n\r\n  // Ensure buffer is valid size\r\n  if (size < 5 || buffer.length < size || size + index > buffer.length) {\r\n    throw new Error('corrupt bson message');\r\n  }\r\n\r\n  // Illegal end value\r\n  if (buffer[index + size - 1] !== 0) {\r\n    throw new Error(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\r\n  }\r\n\r\n  // Start deserializtion\r\n  return deserializeObject(buffer, index, options, isArray);\r\n};\r\n\r\nvar deserializeObject = function(buffer, index, options, isArray) {\r\n  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];\r\n  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];\r\n  var cacheFunctionsCrc32 =\r\n    options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];\r\n\r\n  if (!cacheFunctionsCrc32) var crc32 = null;\r\n\r\n  var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\r\n\r\n  // Return raw bson buffer instead of parsing it\r\n  var raw = options['raw'] == null ? false : options['raw'];\r\n\r\n  // Return BSONRegExp objects instead of native regular expressions\r\n  var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\r\n\r\n  // Controls the promotion of values vs wrapper classes\r\n  var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];\r\n  var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];\r\n  var promoteValues = options['promoteValues'] == null ? true : options['promoteValues'];\r\n\r\n  // Set the start index\r\n  var startIndex = index;\r\n\r\n  // Validate that we have at least 4 bytes of buffer\r\n  if (buffer.length < 5) throw new Error('corrupt bson message < 5 bytes long');\r\n\r\n  // Read the document size\r\n  var size =\r\n    buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\r\n\r\n  // Ensure buffer is valid size\r\n  if (size < 5 || size > buffer.length) throw new Error('corrupt bson message');\r\n\r\n  // Create holding object\r\n  var object = isArray ? [] : {};\r\n  // Used for arrays to skip having to perform utf8 decoding\r\n  var arrayIndex = 0;\r\n\r\n  var done = false;\r\n\r\n  // While we have more left data left keep parsing\r\n  // while (buffer[index + 1] !== 0) {\r\n  while (!done) {\r\n    // Read the type\r\n    var elementType = buffer[index++];\r\n    // If we get a zero it's the last byte, exit\r\n    if (elementType === 0) break;\r\n\r\n    // Get the start search index\r\n    var i = index;\r\n    // Locate the end of the c string\r\n    while (buffer[i] !== 0x00 && i < buffer.length) {\r\n      i++;\r\n    }\r\n\r\n    // If are at the end of the buffer there is a problem with the document\r\n    if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\r\n    var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);\r\n\r\n    index = i + 1;\r\n\r\n    if (elementType === BSON.BSON_DATA_STRING) {\r\n      var stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new Error('bad string length in bson');\r\n      object[name] = buffer.toString('utf8', index, index + stringSize - 1);\r\n      index = index + stringSize;\r\n    } else if (elementType === BSON.BSON_DATA_OID) {\r\n      var oid = utils.allocBuffer(12);\r\n      buffer.copy(oid, 0, index, index + 12);\r\n      object[name] = new ObjectID(oid);\r\n      index = index + 12;\r\n    } else if (elementType === BSON.BSON_DATA_INT && promoteValues === false) {\r\n      object[name] = new Int32(\r\n        buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24)\r\n      );\r\n    } else if (elementType === BSON.BSON_DATA_INT) {\r\n      object[name] =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n    } else if (elementType === BSON.BSON_DATA_NUMBER && promoteValues === false) {\r\n      object[name] = new Double(buffer.readDoubleLE(index));\r\n      index = index + 8;\r\n    } else if (elementType === BSON.BSON_DATA_NUMBER) {\r\n      object[name] = buffer.readDoubleLE(index);\r\n      index = index + 8;\r\n    } else if (elementType === BSON.BSON_DATA_DATE) {\r\n      var lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      var highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      object[name] = new Date(new Long(lowBits, highBits).toNumber());\r\n    } else if (elementType === BSON.BSON_DATA_BOOLEAN) {\r\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new Error('illegal boolean type value');\r\n      object[name] = buffer[index++] === 1;\r\n    } else if (elementType === BSON.BSON_DATA_OBJECT) {\r\n      var _index = index;\r\n      var objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      if (objectSize <= 0 || objectSize > buffer.length - index)\r\n        throw new Error('bad embedded document length in bson');\r\n\r\n      // We have a raw value\r\n      if (raw) {\r\n        object[name] = buffer.slice(index, index + objectSize);\r\n      } else {\r\n        object[name] = deserializeObject(buffer, _index, options, false);\r\n      }\r\n\r\n      index = index + objectSize;\r\n    } else if (elementType === BSON.BSON_DATA_ARRAY) {\r\n      _index = index;\r\n      objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      var arrayOptions = options;\r\n\r\n      // Stop index\r\n      var stopIndex = index + objectSize;\r\n\r\n      // All elements of array to be returned as raw bson\r\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\r\n        arrayOptions = {};\r\n        for (var n in options) arrayOptions[n] = options[n];\r\n        arrayOptions['raw'] = true;\r\n      }\r\n\r\n      object[name] = deserializeObject(buffer, _index, arrayOptions, true);\r\n      index = index + objectSize;\r\n\r\n      if (buffer[index - 1] !== 0) throw new Error('invalid array terminator byte');\r\n      if (index !== stopIndex) throw new Error('corrupted array bson');\r\n    } else if (elementType === BSON.BSON_DATA_UNDEFINED) {\r\n      object[name] = undefined;\r\n    } else if (elementType === BSON.BSON_DATA_NULL) {\r\n      object[name] = null;\r\n    } else if (elementType === BSON.BSON_DATA_LONG) {\r\n      // Unpack the low and high bits\r\n      lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      var long = new Long(lowBits, highBits);\r\n      // Promote the long if possible\r\n      if (promoteLongs && promoteValues === true) {\r\n        object[name] =\r\n          long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\r\n            ? long.toNumber()\r\n            : long;\r\n      } else {\r\n        object[name] = long;\r\n      }\r\n    } else if (elementType === BSON.BSON_DATA_DECIMAL128) {\r\n      // Buffer to contain the decimal bytes\r\n      var bytes = utils.allocBuffer(16);\r\n      // Copy the next 16 bytes into the bytes buffer\r\n      buffer.copy(bytes, 0, index, index + 16);\r\n      // Update index\r\n      index = index + 16;\r\n      // Assign the new Decimal128 value\r\n      var decimal128 = new Decimal128(bytes);\r\n      // If we have an alternative mapper use that\r\n      object[name] = decimal128.toObject ? decimal128.toObject() : decimal128;\r\n    } else if (elementType === BSON.BSON_DATA_BINARY) {\r\n      var binarySize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      var totalBinarySize = binarySize;\r\n      var subType = buffer[index++];\r\n\r\n      // Did we have a negative binary size, throw\r\n      if (binarySize < 0) throw new Error('Negative binary type element size found');\r\n\r\n      // Is the length longer than the document\r\n      if (binarySize > buffer.length) throw new Error('Binary type size larger than document size');\r\n\r\n      // Decode as raw Buffer object if options specifies it\r\n      if (buffer['slice'] != null) {\r\n        // If we have subtype 2 skip the 4 bytes for the size\r\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\r\n          binarySize =\r\n            buffer[index++] |\r\n            (buffer[index++] << 8) |\r\n            (buffer[index++] << 16) |\r\n            (buffer[index++] << 24);\r\n          if (binarySize < 0)\r\n            throw new Error('Negative binary type element size found for subtype 0x02');\r\n          if (binarySize > totalBinarySize - 4)\r\n            throw new Error('Binary type with subtype 0x02 contains to long binary size');\r\n          if (binarySize < totalBinarySize - 4)\r\n            throw new Error('Binary type with subtype 0x02 contains to short binary size');\r\n        }\r\n\r\n        if (promoteBuffers && promoteValues) {\r\n          object[name] = buffer.slice(index, index + binarySize);\r\n        } else {\r\n          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);\r\n        }\r\n      } else {\r\n        var _buffer =\r\n          typeof Uint8Array !== 'undefined'\r\n            ? new Uint8Array(new ArrayBuffer(binarySize))\r\n            : new Array(binarySize);\r\n        // If we have subtype 2 skip the 4 bytes for the size\r\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\r\n          binarySize =\r\n            buffer[index++] |\r\n            (buffer[index++] << 8) |\r\n            (buffer[index++] << 16) |\r\n            (buffer[index++] << 24);\r\n          if (binarySize < 0)\r\n            throw new Error('Negative binary type element size found for subtype 0x02');\r\n          if (binarySize > totalBinarySize - 4)\r\n            throw new Error('Binary type with subtype 0x02 contains to long binary size');\r\n          if (binarySize < totalBinarySize - 4)\r\n            throw new Error('Binary type with subtype 0x02 contains to short binary size');\r\n        }\r\n\r\n        // Copy the data\r\n        for (i = 0; i < binarySize; i++) {\r\n          _buffer[i] = buffer[index + i];\r\n        }\r\n\r\n        if (promoteBuffers && promoteValues) {\r\n          object[name] = _buffer;\r\n        } else {\r\n          object[name] = new Binary(_buffer, subType);\r\n        }\r\n      }\r\n\r\n      // Update the index\r\n      index = index + binarySize;\r\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === false) {\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      var source = buffer.toString('utf8', index, i);\r\n      // Create the regexp\r\n      index = i + 1;\r\n\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      var regExpOptions = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // For each option add the corresponding one for javascript\r\n      var optionsArray = new Array(regExpOptions.length);\r\n\r\n      // Parse options\r\n      for (i = 0; i < regExpOptions.length; i++) {\r\n        switch (regExpOptions[i]) {\r\n          case 'm':\r\n            optionsArray[i] = 'm';\r\n            break;\r\n          case 's':\r\n            optionsArray[i] = 'g';\r\n            break;\r\n          case 'i':\r\n            optionsArray[i] = 'i';\r\n            break;\r\n        }\r\n      }\r\n\r\n      object[name] = new RegExp(source, optionsArray.join(''));\r\n    } else if (elementType === BSON.BSON_DATA_REGEXP && bsonRegExp === true) {\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      source = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // Get the start search index\r\n      i = index;\r\n      // Locate the end of the c string\r\n      while (buffer[i] !== 0x00 && i < buffer.length) {\r\n        i++;\r\n      }\r\n      // If are at the end of the buffer there is a problem with the document\r\n      if (i >= buffer.length) throw new Error('Bad BSON Document: illegal CString');\r\n      // Return the C string\r\n      regExpOptions = buffer.toString('utf8', index, i);\r\n      index = i + 1;\r\n\r\n      // Set the object\r\n      object[name] = new BSONRegExp(source, regExpOptions);\r\n    } else if (elementType === BSON.BSON_DATA_SYMBOL) {\r\n      stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new Error('bad string length in bson');\r\n      object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));\r\n      index = index + stringSize;\r\n    } else if (elementType === BSON.BSON_DATA_TIMESTAMP) {\r\n      lowBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      highBits =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      object[name] = new Timestamp(lowBits, highBits);\r\n    } else if (elementType === BSON.BSON_DATA_MIN_KEY) {\r\n      object[name] = new MinKey();\r\n    } else if (elementType === BSON.BSON_DATA_MAX_KEY) {\r\n      object[name] = new MaxKey();\r\n    } else if (elementType === BSON.BSON_DATA_CODE) {\r\n      stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new Error('bad string length in bson');\r\n      var functionString = buffer.toString('utf8', index, index + stringSize - 1);\r\n\r\n      // If we are evaluating the functions\r\n      if (evalFunctions) {\r\n        // If we have cache enabled let's look for the md5 of the function in the cache\r\n        if (cacheFunctions) {\r\n          var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\r\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\r\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\r\n        } else {\r\n          object[name] = isolateEval(functionString);\r\n        }\r\n      } else {\r\n        object[name] = new Code(functionString);\r\n      }\r\n\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n    } else if (elementType === BSON.BSON_DATA_CODE_W_SCOPE) {\r\n      var totalSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n\r\n      // Element cannot be shorter than totalSize + stringSize + documentSize + terminator\r\n      if (totalSize < 4 + 4 + 4 + 1) {\r\n        throw new Error('code_w_scope total size shorter minimum expected length');\r\n      }\r\n\r\n      // Get the code string size\r\n      stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      // Check if we have a valid string\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new Error('bad string length in bson');\r\n\r\n      // Javascript function\r\n      functionString = buffer.toString('utf8', index, index + stringSize - 1);\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n      // Parse the element\r\n      _index = index;\r\n      // Decode the size of the object document\r\n      objectSize =\r\n        buffer[index] |\r\n        (buffer[index + 1] << 8) |\r\n        (buffer[index + 2] << 16) |\r\n        (buffer[index + 3] << 24);\r\n      // Decode the scope object\r\n      var scopeObject = deserializeObject(buffer, _index, options, false);\r\n      // Adjust the index\r\n      index = index + objectSize;\r\n\r\n      // Check if field length is to short\r\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\r\n        throw new Error('code_w_scope total size is to short, truncating scope');\r\n      }\r\n\r\n      // Check if totalSize field is to long\r\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\r\n        throw new Error('code_w_scope total size is to long, clips outer document');\r\n      }\r\n\r\n      // If we are evaluating the functions\r\n      if (evalFunctions) {\r\n        // If we have cache enabled let's look for the md5 of the function in the cache\r\n        if (cacheFunctions) {\r\n          hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;\r\n          // Got to do this to avoid V8 deoptimizing the call due to finding eval\r\n          object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);\r\n        } else {\r\n          object[name] = isolateEval(functionString);\r\n        }\r\n\r\n        object[name].scope = scopeObject;\r\n      } else {\r\n        object[name] = new Code(functionString, scopeObject);\r\n      }\r\n    } else if (elementType === BSON.BSON_DATA_DBPOINTER) {\r\n      // Get the code string size\r\n      stringSize =\r\n        buffer[index++] |\r\n        (buffer[index++] << 8) |\r\n        (buffer[index++] << 16) |\r\n        (buffer[index++] << 24);\r\n      // Check if we have a valid string\r\n      if (\r\n        stringSize <= 0 ||\r\n        stringSize > buffer.length - index ||\r\n        buffer[index + stringSize - 1] !== 0\r\n      )\r\n        throw new Error('bad string length in bson');\r\n      // Namespace\r\n      var namespace = buffer.toString('utf8', index, index + stringSize - 1);\r\n      // Update parse index position\r\n      index = index + stringSize;\r\n\r\n      // Read the oid\r\n      var oidBuffer = utils.allocBuffer(12);\r\n      buffer.copy(oidBuffer, 0, index, index + 12);\r\n      oid = new ObjectID(oidBuffer);\r\n\r\n      // Update the index\r\n      index = index + 12;\r\n\r\n      // Split the namespace\r\n      var parts = namespace.split('.');\r\n      var db = parts.shift();\r\n      var collection = parts.join('.');\r\n      // Upgrade to DBRef type\r\n      object[name] = new DBRef(collection, oid, db);\r\n    } else {\r\n      throw new Error(\r\n        'Detected unknown BSON type ' +\r\n          elementType.toString(16) +\r\n          ' for fieldname \"' +\r\n          name +\r\n          '\", are you using the latest BSON parser'\r\n      );\r\n    }\r\n  }\r\n\r\n  // Check if the deserialization was against a valid array/object\r\n  if (size !== index - startIndex) {\r\n    if (isArray) throw new Error('corrupt array bson');\r\n    throw new Error('corrupt object bson');\r\n  }\r\n\r\n  // Check if we have a db ref object\r\n  if (object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);\r\n  return object;\r\n};\r\n\r\n/**\r\n * Ensure eval is isolated.\r\n *\r\n * @ignore\r\n * @api private\r\n */\r\nvar isolateEvalWithHash = function(functionCache, hash, functionString, object) {\r\n  // Contains the value we are going to set\r\n  var value = null;\r\n\r\n  // Check for cache hit, eval if missing and return cached function\r\n  if (functionCache[hash] == null) {\r\n    eval('value = ' + functionString);\r\n    functionCache[hash] = value;\r\n  }\r\n  // Set the object\r\n  return functionCache[hash].bind(object);\r\n};\r\n\r\n/**\r\n * Ensure eval is isolated.\r\n *\r\n * @ignore\r\n * @api private\r\n */\r\nvar isolateEval = function(functionString) {\r\n  // Contains the value we are going to set\r\n  var value = null;\r\n  // Eval the function\r\n  eval('value = ' + functionString);\r\n  return value;\r\n};\r\n\r\nvar BSON = {};\r\n\r\n/**\r\n * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5\r\n *\r\n * @ignore\r\n * @api private\r\n */\r\nvar functionCache = (BSON.functionCache = {});\r\n\r\n/**\r\n * Number BSON Type\r\n *\r\n * @classconstant BSON_DATA_NUMBER\r\n **/\r\nBSON.BSON_DATA_NUMBER = 1;\r\n/**\r\n * String BSON Type\r\n *\r\n * @classconstant BSON_DATA_STRING\r\n **/\r\nBSON.BSON_DATA_STRING = 2;\r\n/**\r\n * Object BSON Type\r\n *\r\n * @classconstant BSON_DATA_OBJECT\r\n **/\r\nBSON.BSON_DATA_OBJECT = 3;\r\n/**\r\n * Array BSON Type\r\n *\r\n * @classconstant BSON_DATA_ARRAY\r\n **/\r\nBSON.BSON_DATA_ARRAY = 4;\r\n/**\r\n * Binary BSON Type\r\n *\r\n * @classconstant BSON_DATA_BINARY\r\n **/\r\nBSON.BSON_DATA_BINARY = 5;\r\n/**\r\n * Binary BSON Type\r\n *\r\n * @classconstant BSON_DATA_UNDEFINED\r\n **/\r\nBSON.BSON_DATA_UNDEFINED = 6;\r\n/**\r\n * ObjectID BSON Type\r\n *\r\n * @classconstant BSON_DATA_OID\r\n **/\r\nBSON.BSON_DATA_OID = 7;\r\n/**\r\n * Boolean BSON Type\r\n *\r\n * @classconstant BSON_DATA_BOOLEAN\r\n **/\r\nBSON.BSON_DATA_BOOLEAN = 8;\r\n/**\r\n * Date BSON Type\r\n *\r\n * @classconstant BSON_DATA_DATE\r\n **/\r\nBSON.BSON_DATA_DATE = 9;\r\n/**\r\n * null BSON Type\r\n *\r\n * @classconstant BSON_DATA_NULL\r\n **/\r\nBSON.BSON_DATA_NULL = 10;\r\n/**\r\n * RegExp BSON Type\r\n *\r\n * @classconstant BSON_DATA_REGEXP\r\n **/\r\nBSON.BSON_DATA_REGEXP = 11;\r\n/**\r\n * Code BSON Type\r\n *\r\n * @classconstant BSON_DATA_DBPOINTER\r\n **/\r\nBSON.BSON_DATA_DBPOINTER = 12;\r\n/**\r\n * Code BSON Type\r\n *\r\n * @classconstant BSON_DATA_CODE\r\n **/\r\nBSON.BSON_DATA_CODE = 13;\r\n/**\r\n * Symbol BSON Type\r\n *\r\n * @classconstant BSON_DATA_SYMBOL\r\n **/\r\nBSON.BSON_DATA_SYMBOL = 14;\r\n/**\r\n * Code with Scope BSON Type\r\n *\r\n * @classconstant BSON_DATA_CODE_W_SCOPE\r\n **/\r\nBSON.BSON_DATA_CODE_W_SCOPE = 15;\r\n/**\r\n * 32 bit Integer BSON Type\r\n *\r\n * @classconstant BSON_DATA_INT\r\n **/\r\nBSON.BSON_DATA_INT = 16;\r\n/**\r\n * Timestamp BSON Type\r\n *\r\n * @classconstant BSON_DATA_TIMESTAMP\r\n **/\r\nBSON.BSON_DATA_TIMESTAMP = 17;\r\n/**\r\n * Long BSON Type\r\n *\r\n * @classconstant BSON_DATA_LONG\r\n **/\r\nBSON.BSON_DATA_LONG = 18;\r\n/**\r\n * Long BSON Type\r\n *\r\n * @classconstant BSON_DATA_DECIMAL128\r\n **/\r\nBSON.BSON_DATA_DECIMAL128 = 19;\r\n/**\r\n * MinKey BSON Type\r\n *\r\n * @classconstant BSON_DATA_MIN_KEY\r\n **/\r\nBSON.BSON_DATA_MIN_KEY = 0xff;\r\n/**\r\n * MaxKey BSON Type\r\n *\r\n * @classconstant BSON_DATA_MAX_KEY\r\n **/\r\nBSON.BSON_DATA_MAX_KEY = 0x7f;\r\n\r\n/**\r\n * Binary Default Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_DEFAULT\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;\r\n/**\r\n * Binary Function Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_FUNCTION\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;\r\n/**\r\n * Binary Byte Array Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;\r\n/**\r\n * Binary UUID Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_UUID\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_UUID = 3;\r\n/**\r\n * Binary MD5 Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_MD5\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_MD5 = 4;\r\n/**\r\n * Binary User Defined Type\r\n *\r\n * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED\r\n **/\r\nBSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;\r\n\r\n// BSON MAX VALUES\r\nBSON.BSON_INT32_MAX = 0x7fffffff;\r\nBSON.BSON_INT32_MIN = -0x80000000;\r\n\r\nBSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;\r\nBSON.BSON_INT64_MIN = -Math.pow(2, 63);\r\n\r\n// JS MAX PRECISE VALUES\r\nBSON.JS_INT_MAX = 0x20000000000000; // Any integer up to 2^53 can be precisely represented by a double.\r\nBSON.JS_INT_MIN = -0x20000000000000; // Any integer down to -2^53 can be precisely represented by a double.\r\n\r\n// Internal long versions\r\nvar JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000); // Any integer up to 2^53 can be precisely represented by a double.\r\nvar JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000); // Any integer down to -2^53 can be precisely represented by a double.\r\n\r\nmodule.exports = deserialize;\r\n"]},"metadata":{},"sourceType":"script"}