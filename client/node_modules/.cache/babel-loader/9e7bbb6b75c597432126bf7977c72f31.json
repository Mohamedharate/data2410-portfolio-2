{"ast":null,"code":"'use strict';\n\nconst TopologyBase = require('./topology_base').TopologyBase;\n\nconst MongoError = require('../core').MongoError;\n\nconst CMongos = require('../core').Mongos;\n\nconst Cursor = require('../cursor');\n\nconst Server = require('./server');\n\nconst Store = require('./topology_base').Store;\n\nconst MAX_JS_INT = require('../utils').MAX_JS_INT;\n\nconst translateOptions = require('../utils').translateOptions;\n\nconst filterOptions = require('../utils').filterOptions;\n\nconst mergeOptions = require('../utils').mergeOptions;\n/**\r\n * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is\r\n * used to construct connections.\r\n *\r\n * **Mongos Should not be used, use MongoClient.connect**\r\n */\n// Allowed parameters\n\n\nvar legalOptionNames = ['ha', 'haInterval', 'acceptableLatencyMS', 'poolSize', 'ssl', 'checkServerIdentity', 'sslValidate', 'sslCA', 'sslCRL', 'sslCert', 'ciphers', 'ecdhCurve', 'sslKey', 'sslPass', 'socketOptions', 'bufferMaxEntries', 'store', 'auto_reconnect', 'autoReconnect', 'emitError', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectTimeoutMS', 'socketTimeoutMS', 'loggerLevel', 'logger', 'reconnectTries', 'appname', 'domainsEnabled', 'servername', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'promiseLibrary', 'monitorCommands'];\n/**\r\n * Creates a new Mongos instance\r\n * @class\r\n * @deprecated\r\n * @param {Server[]} servers A seedlist of servers participating in the replicaset.\r\n * @param {object} [options] Optional settings.\r\n * @param {booelan} [options.ha=true] Turn on high availability monitoring.\r\n * @param {number} [options.haInterval=5000] Time between each replicaset status check.\r\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\r\n * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection\r\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\r\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\r\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\r\n * @param {object} [options.socketOptions] Socket options\r\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\r\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.socketOptions.keepAliveInitialDelay=120000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\r\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\r\n * @param {number} [options.socketOptions.socketTimeoutMS=0] How long a send or receive on a socket can take before timing out\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @fires Mongos#connect\r\n * @fires Mongos#ha\r\n * @fires Mongos#joined\r\n * @fires Mongos#left\r\n * @fires Mongos#fullsetup\r\n * @fires Mongos#open\r\n * @fires Mongos#close\r\n * @fires Mongos#error\r\n * @fires Mongos#timeout\r\n * @fires Mongos#parseError\r\n * @fires Mongos#commandStarted\r\n * @fires Mongos#commandSucceeded\r\n * @fires Mongos#commandFailed\r\n * @property {string} parserType the parser type used (c++ or js).\r\n * @return {Mongos} a Mongos instance.\r\n */\n\nclass Mongos extends TopologyBase {\n  constructor(servers, options) {\n    super();\n    options = options || {};\n    var self = this; // Filter the options\n\n    options = filterOptions(options, legalOptionNames); // Ensure all the instances are Server\n\n    for (var i = 0; i < servers.length; i++) {\n      if (!(servers[i] instanceof Server)) {\n        throw MongoError.create({\n          message: 'all seed list instances must be of the Server type',\n          driver: true\n        });\n      }\n    } // Stored options\n\n\n    var storeOptions = {\n      force: false,\n      bufferMaxEntries: typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\n    }; // Shared global store\n\n    var store = options.store || new Store(self, storeOptions); // Build seed list\n\n    var seedlist = servers.map(function (x) {\n      return {\n        host: x.host,\n        port: x.port\n      };\n    }); // Get the reconnect option\n\n    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;\n    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect; // Clone options\n\n    var clonedOptions = mergeOptions({}, {\n      disconnectHandler: store,\n      cursorFactory: Cursor,\n      reconnect: reconnect,\n      emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\n      size: typeof options.poolSize === 'number' ? options.poolSize : 5,\n      monitorCommands: typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\n    }); // Translate any SSL options and other connectivity options\n\n    clonedOptions = translateOptions(clonedOptions, options); // Socket options\n\n    var socketOptions = options.socketOptions && Object.keys(options.socketOptions).length > 0 ? options.socketOptions : options; // Translate all the options to the core types\n\n    clonedOptions = translateOptions(clonedOptions, socketOptions); // Internal state\n\n    this.s = {\n      // Create the Mongos\n      coreTopology: new CMongos(seedlist, clonedOptions),\n      // Server capabilities\n      sCapabilities: null,\n      // Debug turned on\n      debug: clonedOptions.debug,\n      // Store option defaults\n      storeOptions: storeOptions,\n      // Cloned options\n      clonedOptions: clonedOptions,\n      // Actual store of callbacks\n      store: store,\n      // Options\n      options: options,\n      // Server Session Pool\n      sessionPool: null,\n      // Active client sessions\n      sessions: new Set(),\n      // Promise library\n      promiseLibrary: options.promiseLibrary || Promise\n    };\n  } // Connect\n\n\n  connect(_options, callback) {\n    var self = this;\n    if ('function' === typeof _options) callback = _options, _options = {};\n    if (_options == null) _options = {};\n    if (!('function' === typeof callback)) callback = null;\n    _options = Object.assign({}, this.s.clonedOptions, _options);\n    self.s.options = _options; // Update bufferMaxEntries\n\n    self.s.storeOptions.bufferMaxEntries = typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1; // Error handler\n\n    var connectErrorHandler = function () {\n      return function (err) {\n        // Remove all event handlers\n        var events = ['timeout', 'error', 'close'];\n        events.forEach(function (e) {\n          self.removeListener(e, connectErrorHandler);\n        });\n        self.s.coreTopology.removeListener('connect', connectErrorHandler); // Force close the topology\n\n        self.close(true); // Try to callback\n\n        try {\n          callback(err);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      };\n    }; // Actual handler\n\n\n    var errorHandler = function (event) {\n      return function (err) {\n        if (event !== 'error') {\n          self.emit(event, err);\n        }\n      };\n    }; // Error handler\n\n\n    var reconnectHandler = function () {\n      self.emit('reconnect');\n      self.s.store.execute();\n    }; // relay the event\n\n\n    var relay = function (event) {\n      return function (t, server) {\n        self.emit(event, t, server);\n      };\n    }; // Connect handler\n\n\n    var connectHandler = function () {\n      // Clear out all the current handlers left over\n      var events = ['timeout', 'error', 'close', 'fullsetup'];\n      events.forEach(function (e) {\n        self.s.coreTopology.removeAllListeners(e);\n      }); // Set up listeners\n\n      self.s.coreTopology.on('timeout', errorHandler('timeout'));\n      self.s.coreTopology.on('error', errorHandler('error'));\n      self.s.coreTopology.on('close', errorHandler('close')); // Set up serverConfig listeners\n\n      self.s.coreTopology.on('fullsetup', function () {\n        self.emit('fullsetup', self);\n      }); // Emit open event\n\n      self.emit('open', null, self); // Return correctly\n\n      try {\n        callback(null, self);\n      } catch (err) {\n        process.nextTick(function () {\n          throw err;\n        });\n      }\n    }; // Clear out all the current handlers left over\n\n\n    var events = ['timeout', 'error', 'close', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHeartbeatFailed', 'serverClosed', 'topologyOpening', 'topologyClosed', 'topologyDescriptionChanged', 'commandStarted', 'commandSucceeded', 'commandFailed'];\n    events.forEach(function (e) {\n      self.s.coreTopology.removeAllListeners(e);\n    }); // Set up SDAM listeners\n\n    self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\n    self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\n    self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\n    self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\n    self.s.coreTopology.on('serverOpening', relay('serverOpening'));\n    self.s.coreTopology.on('serverClosed', relay('serverClosed'));\n    self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\n    self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\n    self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\n    self.s.coreTopology.on('commandStarted', relay('commandStarted'));\n    self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\n    self.s.coreTopology.on('commandFailed', relay('commandFailed')); // Set up listeners\n\n    self.s.coreTopology.once('timeout', connectErrorHandler('timeout'));\n    self.s.coreTopology.once('error', connectErrorHandler('error'));\n    self.s.coreTopology.once('close', connectErrorHandler('close'));\n    self.s.coreTopology.once('connect', connectHandler); // Join and leave events\n\n    self.s.coreTopology.on('joined', relay('joined'));\n    self.s.coreTopology.on('left', relay('left')); // Reconnect server\n\n    self.s.coreTopology.on('reconnect', reconnectHandler); // Start connection\n\n    self.s.coreTopology.connect(_options);\n  }\n\n}\n\nObject.defineProperty(Mongos.prototype, 'haInterval', {\n  enumerable: true,\n  get: function () {\n    return this.s.coreTopology.s.haInterval;\n  }\n});\n/**\r\n * A mongos connect event, used to verify that the connection is up and running\r\n *\r\n * @event Mongos#connect\r\n * @type {Mongos}\r\n */\n\n/**\r\n * The mongos high availability event\r\n *\r\n * @event Mongos#ha\r\n * @type {function}\r\n * @param {string} type The stage in the high availability event (start|end)\r\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\r\n * @param {number} data.id The id for this high availability request\r\n * @param {object} data.state An object containing the information about the current replicaset\r\n */\n\n/**\r\n * A server member left the mongos set\r\n *\r\n * @event Mongos#left\r\n * @type {function}\r\n * @param {string} type The type of member that left (primary|secondary|arbiter)\r\n * @param {Server} server The server object that left\r\n */\n\n/**\r\n * A server member joined the mongos set\r\n *\r\n * @event Mongos#joined\r\n * @type {function}\r\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\r\n * @param {Server} server The server object that joined\r\n */\n\n/**\r\n * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.\r\n *\r\n * @event Mongos#fullsetup\r\n * @type {Mongos}\r\n */\n\n/**\r\n * Mongos open event, emitted when mongos can start processing commands.\r\n *\r\n * @event Mongos#open\r\n * @type {Mongos}\r\n */\n\n/**\r\n * Mongos close event\r\n *\r\n * @event Mongos#close\r\n * @type {object}\r\n */\n\n/**\r\n * Mongos error event, emitted if there is an error listener.\r\n *\r\n * @event Mongos#error\r\n * @type {MongoError}\r\n */\n\n/**\r\n * Mongos timeout event\r\n *\r\n * @event Mongos#timeout\r\n * @type {object}\r\n */\n\n/**\r\n * Mongos parseError event\r\n *\r\n * @event Mongos#parseError\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandStarted\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandSucceeded\r\n * @type {object}\r\n */\n\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandFailed\r\n * @type {object}\r\n */\n\nmodule.exports = Mongos;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/topologies/mongos.js"],"names":["TopologyBase","require","MongoError","CMongos","Mongos","Cursor","Server","Store","MAX_JS_INT","translateOptions","filterOptions","mergeOptions","legalOptionNames","constructor","servers","options","self","i","length","create","message","driver","storeOptions","force","bufferMaxEntries","store","seedlist","map","x","host","port","reconnect","auto_reconnect","autoReconnect","clonedOptions","disconnectHandler","cursorFactory","emitError","size","poolSize","monitorCommands","socketOptions","Object","keys","s","coreTopology","sCapabilities","debug","sessionPool","sessions","Set","promiseLibrary","Promise","connect","_options","callback","assign","connectErrorHandler","err","events","forEach","e","removeListener","close","process","nextTick","errorHandler","event","emit","reconnectHandler","execute","relay","t","server","connectHandler","removeAllListeners","on","once","defineProperty","prototype","enumerable","get","haInterval","module","exports"],"mappings":"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OC,YAAP,CAAoB+B,EAApB,CAAuB,MAAvB,EAA+BL,KAAK,CAAC,MAAD,CAApC,EApI0B,CAsI1B;;AACAvD,IAAAA,IAAI,CAAC4B,CAAL,CAAOC,YAAP,CAAoB+B,EAApB,CAAuB,WAAvB,EAAoCP,gBAApC,EAvI0B,CAyI1B;;AACArD,IAAAA,IAAI,CAAC4B,CAAL,CAAOC,YAAP,CAAoBQ,OAApB,CAA4BC,QAA5B;AACD;;AAtO+B;;AAyOlCZ,MAAM,CAACoC,cAAP,CAAsB1E,MAAM,CAAC2E,SAA7B,EAAwC,YAAxC,EAAsD;AACpDC,EAAAA,UAAU,EAAE,IADwC;AAEpDC,EAAAA,GAAG,EAAE,YAAW;AACd,WAAO,KAAKrC,CAAL,CAAOC,YAAP,CAAoBD,CAApB,CAAsBsC,UAA7B;AACD;AAJmD,CAAtD;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAP,GAAiBhF,MAAjB","sourcesContent":["'use strict';\r\n\r\nconst TopologyBase = require('./topology_base').TopologyBase;\r\nconst MongoError = require('../core').MongoError;\r\nconst CMongos = require('../core').Mongos;\r\nconst Cursor = require('../cursor');\r\nconst Server = require('./server');\r\nconst Store = require('./topology_base').Store;\r\nconst MAX_JS_INT = require('../utils').MAX_JS_INT;\r\nconst translateOptions = require('../utils').translateOptions;\r\nconst filterOptions = require('../utils').filterOptions;\r\nconst mergeOptions = require('../utils').mergeOptions;\r\n\r\n/**\r\n * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is\r\n * used to construct connections.\r\n *\r\n * **Mongos Should not be used, use MongoClient.connect**\r\n */\r\n\r\n// Allowed parameters\r\nvar legalOptionNames = [\r\n  'ha',\r\n  'haInterval',\r\n  'acceptableLatencyMS',\r\n  'poolSize',\r\n  'ssl',\r\n  'checkServerIdentity',\r\n  'sslValidate',\r\n  'sslCA',\r\n  'sslCRL',\r\n  'sslCert',\r\n  'ciphers',\r\n  'ecdhCurve',\r\n  'sslKey',\r\n  'sslPass',\r\n  'socketOptions',\r\n  'bufferMaxEntries',\r\n  'store',\r\n  'auto_reconnect',\r\n  'autoReconnect',\r\n  'emitError',\r\n  'keepAlive',\r\n  'keepAliveInitialDelay',\r\n  'noDelay',\r\n  'connectTimeoutMS',\r\n  'socketTimeoutMS',\r\n  'loggerLevel',\r\n  'logger',\r\n  'reconnectTries',\r\n  'appname',\r\n  'domainsEnabled',\r\n  'servername',\r\n  'promoteLongs',\r\n  'promoteValues',\r\n  'promoteBuffers',\r\n  'promiseLibrary',\r\n  'monitorCommands'\r\n];\r\n\r\n/**\r\n * Creates a new Mongos instance\r\n * @class\r\n * @deprecated\r\n * @param {Server[]} servers A seedlist of servers participating in the replicaset.\r\n * @param {object} [options] Optional settings.\r\n * @param {booelan} [options.ha=true] Turn on high availability monitoring.\r\n * @param {number} [options.haInterval=5000] Time between each replicaset status check.\r\n * @param {number} [options.poolSize=5] Number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.\r\n * @param {number} [options.acceptableLatencyMS=15] Cutoff latency point in MS for MongoS proxy selection\r\n * @param {boolean} [options.ssl=false] Use ssl connection (needs to have a mongod server with ssl support)\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {boolean} [options.sslValidate=false] Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {array} [options.sslCA] Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {array} [options.sslCRL] Array of revocation certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {string} [options.ciphers] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\r\n * @param {string} [options.ecdhCurve] Passed directly through to tls.createSecureContext. See https://nodejs.org/dist/latest-v9.x/docs/api/tls.html#tls_tls_createsecurecontext_options for more info.\r\n * @param {(Buffer|string)} [options.sslCert] String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {(Buffer|string)} [options.sslKey] String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {(Buffer|string)} [options.sslPass] String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)\r\n * @param {string} [options.servername] String containing the server name requested via TLS SNI.\r\n * @param {object} [options.socketOptions] Socket options\r\n * @param {boolean} [options.socketOptions.noDelay=true] TCP Socket NoDelay option.\r\n * @param {boolean} [options.socketOptions.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.socketOptions.keepAliveInitialDelay=120000] The number of milliseconds to wait before initiating keepAlive on the TCP socket\r\n * @param {number} [options.socketOptions.connectTimeoutMS=10000] How long to wait for a connection to be established before timing out\r\n * @param {number} [options.socketOptions.socketTimeoutMS=0] How long a send or receive on a socket can take before timing out\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @param {boolean} [options.monitorCommands=false] Enable command monitoring for this topology\r\n * @fires Mongos#connect\r\n * @fires Mongos#ha\r\n * @fires Mongos#joined\r\n * @fires Mongos#left\r\n * @fires Mongos#fullsetup\r\n * @fires Mongos#open\r\n * @fires Mongos#close\r\n * @fires Mongos#error\r\n * @fires Mongos#timeout\r\n * @fires Mongos#parseError\r\n * @fires Mongos#commandStarted\r\n * @fires Mongos#commandSucceeded\r\n * @fires Mongos#commandFailed\r\n * @property {string} parserType the parser type used (c++ or js).\r\n * @return {Mongos} a Mongos instance.\r\n */\r\nclass Mongos extends TopologyBase {\r\n  constructor(servers, options) {\r\n    super();\r\n\r\n    options = options || {};\r\n    var self = this;\r\n\r\n    // Filter the options\r\n    options = filterOptions(options, legalOptionNames);\r\n\r\n    // Ensure all the instances are Server\r\n    for (var i = 0; i < servers.length; i++) {\r\n      if (!(servers[i] instanceof Server)) {\r\n        throw MongoError.create({\r\n          message: 'all seed list instances must be of the Server type',\r\n          driver: true\r\n        });\r\n      }\r\n    }\r\n\r\n    // Stored options\r\n    var storeOptions = {\r\n      force: false,\r\n      bufferMaxEntries:\r\n        typeof options.bufferMaxEntries === 'number' ? options.bufferMaxEntries : MAX_JS_INT\r\n    };\r\n\r\n    // Shared global store\r\n    var store = options.store || new Store(self, storeOptions);\r\n\r\n    // Build seed list\r\n    var seedlist = servers.map(function(x) {\r\n      return { host: x.host, port: x.port };\r\n    });\r\n\r\n    // Get the reconnect option\r\n    var reconnect = typeof options.auto_reconnect === 'boolean' ? options.auto_reconnect : true;\r\n    reconnect = typeof options.autoReconnect === 'boolean' ? options.autoReconnect : reconnect;\r\n\r\n    // Clone options\r\n    var clonedOptions = mergeOptions(\r\n      {},\r\n      {\r\n        disconnectHandler: store,\r\n        cursorFactory: Cursor,\r\n        reconnect: reconnect,\r\n        emitError: typeof options.emitError === 'boolean' ? options.emitError : true,\r\n        size: typeof options.poolSize === 'number' ? options.poolSize : 5,\r\n        monitorCommands:\r\n          typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false\r\n      }\r\n    );\r\n\r\n    // Translate any SSL options and other connectivity options\r\n    clonedOptions = translateOptions(clonedOptions, options);\r\n\r\n    // Socket options\r\n    var socketOptions =\r\n      options.socketOptions && Object.keys(options.socketOptions).length > 0\r\n        ? options.socketOptions\r\n        : options;\r\n\r\n    // Translate all the options to the core types\r\n    clonedOptions = translateOptions(clonedOptions, socketOptions);\r\n\r\n    // Internal state\r\n    this.s = {\r\n      // Create the Mongos\r\n      coreTopology: new CMongos(seedlist, clonedOptions),\r\n      // Server capabilities\r\n      sCapabilities: null,\r\n      // Debug turned on\r\n      debug: clonedOptions.debug,\r\n      // Store option defaults\r\n      storeOptions: storeOptions,\r\n      // Cloned options\r\n      clonedOptions: clonedOptions,\r\n      // Actual store of callbacks\r\n      store: store,\r\n      // Options\r\n      options: options,\r\n      // Server Session Pool\r\n      sessionPool: null,\r\n      // Active client sessions\r\n      sessions: new Set(),\r\n      // Promise library\r\n      promiseLibrary: options.promiseLibrary || Promise\r\n    };\r\n  }\r\n\r\n  // Connect\r\n  connect(_options, callback) {\r\n    var self = this;\r\n    if ('function' === typeof _options) (callback = _options), (_options = {});\r\n    if (_options == null) _options = {};\r\n    if (!('function' === typeof callback)) callback = null;\r\n    _options = Object.assign({}, this.s.clonedOptions, _options);\r\n    self.s.options = _options;\r\n\r\n    // Update bufferMaxEntries\r\n    self.s.storeOptions.bufferMaxEntries =\r\n      typeof _options.bufferMaxEntries === 'number' ? _options.bufferMaxEntries : -1;\r\n\r\n    // Error handler\r\n    var connectErrorHandler = function() {\r\n      return function(err) {\r\n        // Remove all event handlers\r\n        var events = ['timeout', 'error', 'close'];\r\n        events.forEach(function(e) {\r\n          self.removeListener(e, connectErrorHandler);\r\n        });\r\n\r\n        self.s.coreTopology.removeListener('connect', connectErrorHandler);\r\n        // Force close the topology\r\n        self.close(true);\r\n\r\n        // Try to callback\r\n        try {\r\n          callback(err);\r\n        } catch (err) {\r\n          process.nextTick(function() {\r\n            throw err;\r\n          });\r\n        }\r\n      };\r\n    };\r\n\r\n    // Actual handler\r\n    var errorHandler = function(event) {\r\n      return function(err) {\r\n        if (event !== 'error') {\r\n          self.emit(event, err);\r\n        }\r\n      };\r\n    };\r\n\r\n    // Error handler\r\n    var reconnectHandler = function() {\r\n      self.emit('reconnect');\r\n      self.s.store.execute();\r\n    };\r\n\r\n    // relay the event\r\n    var relay = function(event) {\r\n      return function(t, server) {\r\n        self.emit(event, t, server);\r\n      };\r\n    };\r\n\r\n    // Connect handler\r\n    var connectHandler = function() {\r\n      // Clear out all the current handlers left over\r\n      var events = ['timeout', 'error', 'close', 'fullsetup'];\r\n      events.forEach(function(e) {\r\n        self.s.coreTopology.removeAllListeners(e);\r\n      });\r\n\r\n      // Set up listeners\r\n      self.s.coreTopology.on('timeout', errorHandler('timeout'));\r\n      self.s.coreTopology.on('error', errorHandler('error'));\r\n      self.s.coreTopology.on('close', errorHandler('close'));\r\n\r\n      // Set up serverConfig listeners\r\n      self.s.coreTopology.on('fullsetup', function() {\r\n        self.emit('fullsetup', self);\r\n      });\r\n\r\n      // Emit open event\r\n      self.emit('open', null, self);\r\n\r\n      // Return correctly\r\n      try {\r\n        callback(null, self);\r\n      } catch (err) {\r\n        process.nextTick(function() {\r\n          throw err;\r\n        });\r\n      }\r\n    };\r\n\r\n    // Clear out all the current handlers left over\r\n    var events = [\r\n      'timeout',\r\n      'error',\r\n      'close',\r\n      'serverOpening',\r\n      'serverDescriptionChanged',\r\n      'serverHeartbeatStarted',\r\n      'serverHeartbeatSucceeded',\r\n      'serverHeartbeatFailed',\r\n      'serverClosed',\r\n      'topologyOpening',\r\n      'topologyClosed',\r\n      'topologyDescriptionChanged',\r\n      'commandStarted',\r\n      'commandSucceeded',\r\n      'commandFailed'\r\n    ];\r\n    events.forEach(function(e) {\r\n      self.s.coreTopology.removeAllListeners(e);\r\n    });\r\n\r\n    // Set up SDAM listeners\r\n    self.s.coreTopology.on('serverDescriptionChanged', relay('serverDescriptionChanged'));\r\n    self.s.coreTopology.on('serverHeartbeatStarted', relay('serverHeartbeatStarted'));\r\n    self.s.coreTopology.on('serverHeartbeatSucceeded', relay('serverHeartbeatSucceeded'));\r\n    self.s.coreTopology.on('serverHeartbeatFailed', relay('serverHeartbeatFailed'));\r\n    self.s.coreTopology.on('serverOpening', relay('serverOpening'));\r\n    self.s.coreTopology.on('serverClosed', relay('serverClosed'));\r\n    self.s.coreTopology.on('topologyOpening', relay('topologyOpening'));\r\n    self.s.coreTopology.on('topologyClosed', relay('topologyClosed'));\r\n    self.s.coreTopology.on('topologyDescriptionChanged', relay('topologyDescriptionChanged'));\r\n    self.s.coreTopology.on('commandStarted', relay('commandStarted'));\r\n    self.s.coreTopology.on('commandSucceeded', relay('commandSucceeded'));\r\n    self.s.coreTopology.on('commandFailed', relay('commandFailed'));\r\n\r\n    // Set up listeners\r\n    self.s.coreTopology.once('timeout', connectErrorHandler('timeout'));\r\n    self.s.coreTopology.once('error', connectErrorHandler('error'));\r\n    self.s.coreTopology.once('close', connectErrorHandler('close'));\r\n    self.s.coreTopology.once('connect', connectHandler);\r\n    // Join and leave events\r\n    self.s.coreTopology.on('joined', relay('joined'));\r\n    self.s.coreTopology.on('left', relay('left'));\r\n\r\n    // Reconnect server\r\n    self.s.coreTopology.on('reconnect', reconnectHandler);\r\n\r\n    // Start connection\r\n    self.s.coreTopology.connect(_options);\r\n  }\r\n}\r\n\r\nObject.defineProperty(Mongos.prototype, 'haInterval', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.coreTopology.s.haInterval;\r\n  }\r\n});\r\n\r\n/**\r\n * A mongos connect event, used to verify that the connection is up and running\r\n *\r\n * @event Mongos#connect\r\n * @type {Mongos}\r\n */\r\n\r\n/**\r\n * The mongos high availability event\r\n *\r\n * @event Mongos#ha\r\n * @type {function}\r\n * @param {string} type The stage in the high availability event (start|end)\r\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\r\n * @param {number} data.id The id for this high availability request\r\n * @param {object} data.state An object containing the information about the current replicaset\r\n */\r\n\r\n/**\r\n * A server member left the mongos set\r\n *\r\n * @event Mongos#left\r\n * @type {function}\r\n * @param {string} type The type of member that left (primary|secondary|arbiter)\r\n * @param {Server} server The server object that left\r\n */\r\n\r\n/**\r\n * A server member joined the mongos set\r\n *\r\n * @event Mongos#joined\r\n * @type {function}\r\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\r\n * @param {Server} server The server object that joined\r\n */\r\n\r\n/**\r\n * Mongos fullsetup event, emitted when all proxies in the topology have been connected to.\r\n *\r\n * @event Mongos#fullsetup\r\n * @type {Mongos}\r\n */\r\n\r\n/**\r\n * Mongos open event, emitted when mongos can start processing commands.\r\n *\r\n * @event Mongos#open\r\n * @type {Mongos}\r\n */\r\n\r\n/**\r\n * Mongos close event\r\n *\r\n * @event Mongos#close\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * Mongos error event, emitted if there is an error listener.\r\n *\r\n * @event Mongos#error\r\n * @type {MongoError}\r\n */\r\n\r\n/**\r\n * Mongos timeout event\r\n *\r\n * @event Mongos#timeout\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * Mongos parseError event\r\n *\r\n * @event Mongos#parseError\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command was started, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandStarted\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command succeeded, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandSucceeded\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * An event emitted indicating a command failed, if command monitoring is enabled\r\n *\r\n * @event Mongos#commandFailed\r\n * @type {object}\r\n */\r\n\r\nmodule.exports = Mongos;\r\n"]},"metadata":{},"sourceType":"script"}