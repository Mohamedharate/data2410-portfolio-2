{"ast":null,"code":"'use strict';\n\nmodule.exports = function (modules) {\n  const tls = require('tls');\n\n  const MongoTimeoutError = modules.mongodb.MongoTimeoutError;\n\n  const common = require('./common');\n\n  const debug = common.debug;\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const MongoCryptError = common.MongoCryptError;\n\n  const BufferList = require('bl'); // libmongocrypt states\n\n\n  const MONGOCRYPT_CTX_ERROR = 0;\n  const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;\n  const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;\n  const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;\n  const MONGOCRYPT_CTX_NEED_KMS = 4;\n  const MONGOCRYPT_CTX_READY = 5;\n  const MONGOCRYPT_CTX_DONE = 6;\n  const HTTPS_PORT = 443;\n  const stateToString = new Map([[MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'], [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'], [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'], [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'], [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'], [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'], [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']]);\n  /**\n   * @ignore\n   * @callback StateMachine~executeCallback\n   * @param {Error} [err] If present, indicates that the execute call failed with the given error\n   * @param {object} [result] If present, is the result of executing the state machine.\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~fetchCollectionInfoCallback\n   * @param {Error} [err] If present, indicates that fetching the collection info failed with the given error\n   * @param {object} [result] If present, is the fetched collection info for the first collection to match the given filter\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~markCommandCallback\n   * @param {Error} [err] If present, indicates that marking the command failed with the given error\n   * @param {Buffer} [result] If present, is the marked command serialized into bson\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~fetchKeysCallback\n   * @param {Error} [err] If present, indicates that fetching the keys failed with the given error\n   * @param {object[]} [result] If present, is all the keys from the keyVault colleciton that matched the given filter\n   */\n\n  /**\n   * @ignore\n   * An internal class that executes across a MongoCryptContext until either\n   * a finishing state or an error is reached. Do not instantiate directly.\n   * @class StateMachine\n   */\n\n  class StateMachine {\n    constructor(options) {\n      this.options = options || {};\n      this.bson = options.bson;\n    }\n    /**\n     * @ignore\n     * Executes the state machine according to the specification\n     * @param {AutoEncrypter|ClientEncryption} autoEncrypter The JS encryption object\n     * @param {object} context The C++ context object returned from the bindings\n     * @param {StateMachine~executeCallback} callback Invoked with the result/error of executing the state machine\n     * @returns {void}\n     */\n\n\n    execute(autoEncrypter, context, callback) {\n      const bson = this.bson;\n      const keyVaultNamespace = autoEncrypter._keyVaultNamespace;\n      const keyVaultClient = autoEncrypter._keyVaultClient;\n      const metaDataClient = autoEncrypter._metaDataClient;\n      const mongocryptdClient = autoEncrypter._mongocryptdClient;\n      const mongocryptdManager = autoEncrypter._mongocryptdManager;\n      debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);\n\n      switch (context.state) {\n        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO:\n          {\n            const filter = bson.deserialize(context.nextMongoOperation());\n            this.fetchCollectionInfo(metaDataClient, context.ns, filter, (err, collInfo) => {\n              if (err) {\n                return callback(err, null);\n              }\n\n              if (collInfo) {\n                context.addMongoOperationResponse(collInfo);\n              }\n\n              context.finishMongoOperation();\n              this.execute(autoEncrypter, context, callback);\n            });\n            return;\n          }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS:\n          {\n            const command = context.nextMongoOperation();\n            this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {\n              if (err) {\n                // If we are not bypassing spawning, then we should retry once on a MongoTimeoutError (server selection error)\n                if (err instanceof MongoTimeoutError && mongocryptdManager && !mongocryptdManager.bypassSpawn) {\n                  mongocryptdManager.spawn(() => {\n                    // TODO: should we be shadowing the variables here?\n                    this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {\n                      if (err) return callback(err, null);\n                      context.addMongoOperationResponse(markedCommand);\n                      context.finishMongoOperation();\n                      this.execute(autoEncrypter, context, callback);\n                    });\n                  });\n                  return;\n                }\n\n                return callback(err, null);\n              }\n\n              context.addMongoOperationResponse(markedCommand);\n              context.finishMongoOperation();\n              this.execute(autoEncrypter, context, callback);\n            });\n            return;\n          }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_KEYS:\n          {\n            const filter = context.nextMongoOperation();\n            this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, (err, keys) => {\n              if (err) return callback(err, null);\n              keys.forEach(key => {\n                context.addMongoOperationResponse(bson.serialize(key));\n              });\n              context.finishMongoOperation();\n              this.execute(autoEncrypter, context, callback);\n            });\n            return;\n          }\n\n        case MONGOCRYPT_CTX_NEED_KMS:\n          {\n            const promises = [];\n            let request;\n\n            while (request = context.nextKMSRequest()) {\n              promises.push(this.kmsRequest(request));\n            }\n\n            Promise.all(promises).then(() => {\n              context.finishKMSRequests();\n              this.execute(autoEncrypter, context, callback);\n            }).catch(err => {\n              callback(err, null);\n            });\n            return;\n          }\n        // terminal states\n\n        case MONGOCRYPT_CTX_READY:\n          {\n            const finalizedContext = context.finalize(); // TODO: Maybe rework the logic here so that instead of doing\n            // the callback here, finalize stores the result, and then\n            // we wait to MONGOCRYPT_CTX_DONE to do the callback\n\n            if (context.state === MONGOCRYPT_CTX_ERROR) {\n              const message = context.status.message || 'Finalization error';\n              callback(new MongoCryptError(message));\n              return;\n            }\n\n            callback(null, bson.deserialize(finalizedContext, this.options));\n            return;\n          }\n\n        case MONGOCRYPT_CTX_ERROR:\n          {\n            const message = context.status.message;\n            callback(new MongoCryptError(message));\n            return;\n          }\n\n        case MONGOCRYPT_CTX_DONE:\n          return;\n\n        default:\n          callback(new MongoCryptError(`Unknown state: ${context.state}`));\n          return;\n      }\n    }\n    /**\n     * @ignore\n     * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.\n     * @param {*} kmsContext A C++ KMS context returned from the bindings\n     * @returns {Promise<void>} A promise that resolves when the KMS reply has be fully parsed\n     */\n\n\n    kmsRequest(request) {\n      const parsedUrl = request.endpoint.split(':');\n      const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;\n      const options = {\n        host: parsedUrl[0],\n        servername: parsedUrl[0],\n        port\n      };\n      const message = request.message;\n      return new Promise((resolve, reject) => {\n        const buffer = new BufferList();\n        const socket = tls.connect(options, () => {\n          socket.write(message);\n        });\n        socket.once('timeout', () => {\n          socket.removeAllListeners();\n          socket.destroy();\n          reject(new MongoCryptError('KMS request timed out'));\n        });\n        socket.once('error', err => {\n          socket.removeAllListeners();\n          socket.destroy();\n          const mcError = new MongoCryptError('KMS request failed');\n          mcError.originalError = err;\n          reject(mcError);\n        });\n        socket.on('data', data => {\n          buffer.append(data);\n\n          while (request.bytesNeeded > 0 && buffer.length) {\n            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);\n            request.addResponse(buffer.slice(0, bytesNeeded));\n            buffer.consume(bytesNeeded);\n          }\n\n          if (request.bytesNeeded <= 0) {\n            socket.end(resolve);\n          }\n        });\n      });\n    }\n    /**\n     * @ignore\n     * Fetches collection info for a provided namespace, when libmongocrypt\n     * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is\n     * used to inform libmongocrypt of the schema associated with this\n     * namespace. Exposed for testing purposes. Do not directly invoke.\n     *\n     * @param {MongoClient} client A MongoClient connected to the topology\n     * @param {string} ns The namespace to list collections from\n     * @param {object} filter A filter for the listCollections command\n     * @param {StateMachine~fetchCollectionInfoCallback} callback Invoked with the info of the requested collection, or with an error\n     */\n\n\n    fetchCollectionInfo(client, ns, filter, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(ns);\n      client.db(dbName).listCollections(filter).toArray((err, collections) => {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        const info = collections.length > 0 ? bson.serialize(collections[0]) : null;\n        callback(null, info);\n      });\n    }\n    /**\n     * @ignore\n     * Calls to the mongocryptd to provide markings for a command.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param {MongoClient} client A MongoClient connected to a mongocryptd\n     * @param {string} ns The namespace (database.collection) the command is being executed on\n     * @param {object} command The command to execute.\n     * @param {StateMachine~markCommandCallback} callback Invoked with the serialized and marked bson command, or with an error\n     * @returns {void}\n     */\n\n\n    markCommand(client, ns, command, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(ns);\n      const rawCommand = bson.deserialize(command, {\n        promoteLongs: false,\n        promoteValues: false\n      });\n      client.db(dbName).command(rawCommand, (err, response) => {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        callback(err, bson.serialize(response, this.options));\n      });\n    }\n    /**\n     * @ignore\n     * Requests keys from the keyVault collection on the topology.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param {MongoClient} client A MongoClient connected to the topology\n     * @param {string} keyVaultNamespace The namespace (database.collection) of the keyVault Collection\n     * @param {object} filter The filter for the find query against the keyVault Collection\n     * @param {StateMachine~fetchKeysCallback} callback Invoked with the found keys, or with an error\n     * @returns {void}\n     */\n\n\n    fetchKeys(client, keyVaultNamespace, filter, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(keyVaultNamespace);\n      const collectionName = collectionNamespace(keyVaultNamespace);\n      filter = bson.deserialize(filter);\n      client.db(dbName).collection(collectionName, {\n        readConcern: {\n          level: 'majority'\n        }\n      }).find(filter).toArray((err, keys) => {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        callback(null, keys);\n      });\n    }\n\n  }\n\n  return {\n    StateMachine\n  };\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb-client-encryption/lib/stateMachine.js"],"names":["module","exports","modules","tls","require","MongoTimeoutError","mongodb","common","debug","databaseNamespace","collectionNamespace","MongoCryptError","BufferList","MONGOCRYPT_CTX_ERROR","MONGOCRYPT_CTX_NEED_MONGO_COLLINFO","MONGOCRYPT_CTX_NEED_MONGO_MARKINGS","MONGOCRYPT_CTX_NEED_MONGO_KEYS","MONGOCRYPT_CTX_NEED_KMS","MONGOCRYPT_CTX_READY","MONGOCRYPT_CTX_DONE","HTTPS_PORT","stateToString","Map","StateMachine","constructor","options","bson","execute","autoEncrypter","context","callback","keyVaultNamespace","_keyVaultNamespace","keyVaultClient","_keyVaultClient","metaDataClient","_metaDataClient","mongocryptdClient","_mongocryptdClient","mongocryptdManager","_mongocryptdManager","id","get","state","filter","deserialize","nextMongoOperation","fetchCollectionInfo","ns","err","collInfo","addMongoOperationResponse","finishMongoOperation","command","markCommand","markedCommand","bypassSpawn","spawn","fetchKeys","keys","forEach","key","serialize","promises","request","nextKMSRequest","push","kmsRequest","Promise","all","then","finishKMSRequests","catch","finalizedContext","finalize","message","status","parsedUrl","endpoint","split","port","Number","parseInt","host","servername","resolve","reject","buffer","socket","connect","write","once","removeAllListeners","destroy","mcError","originalError","on","data","append","bytesNeeded","length","Math","min","addResponse","slice","consume","end","client","dbName","db","listCollections","toArray","collections","info","rawCommand","promoteLongs","promoteValues","response","collectionName","collection","readConcern","level","find"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(modules) {\n  const tls = require('tls');\n  const MongoTimeoutError = modules.mongodb.MongoTimeoutError;\n  const common = require('./common');\n  const debug = common.debug;\n  const databaseNamespace = common.databaseNamespace;\n  const collectionNamespace = common.collectionNamespace;\n  const MongoCryptError = common.MongoCryptError;\n  const BufferList = require('bl');\n\n  // libmongocrypt states\n  const MONGOCRYPT_CTX_ERROR = 0;\n  const MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;\n  const MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;\n  const MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;\n  const MONGOCRYPT_CTX_NEED_KMS = 4;\n  const MONGOCRYPT_CTX_READY = 5;\n  const MONGOCRYPT_CTX_DONE = 6;\n\n  const HTTPS_PORT = 443;\n\n  const stateToString = new Map([\n    [MONGOCRYPT_CTX_ERROR, 'MONGOCRYPT_CTX_ERROR'],\n    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, 'MONGOCRYPT_CTX_NEED_MONGO_COLLINFO'],\n    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, 'MONGOCRYPT_CTX_NEED_MONGO_MARKINGS'],\n    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, 'MONGOCRYPT_CTX_NEED_MONGO_KEYS'],\n    [MONGOCRYPT_CTX_NEED_KMS, 'MONGOCRYPT_CTX_NEED_KMS'],\n    [MONGOCRYPT_CTX_READY, 'MONGOCRYPT_CTX_READY'],\n    [MONGOCRYPT_CTX_DONE, 'MONGOCRYPT_CTX_DONE']\n  ]);\n\n  /**\n   * @ignore\n   * @callback StateMachine~executeCallback\n   * @param {Error} [err] If present, indicates that the execute call failed with the given error\n   * @param {object} [result] If present, is the result of executing the state machine.\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~fetchCollectionInfoCallback\n   * @param {Error} [err] If present, indicates that fetching the collection info failed with the given error\n   * @param {object} [result] If present, is the fetched collection info for the first collection to match the given filter\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~markCommandCallback\n   * @param {Error} [err] If present, indicates that marking the command failed with the given error\n   * @param {Buffer} [result] If present, is the marked command serialized into bson\n   * @returns {void}\n   */\n\n  /**\n   * @ignore\n   * @callback StateMachine~fetchKeysCallback\n   * @param {Error} [err] If present, indicates that fetching the keys failed with the given error\n   * @param {object[]} [result] If present, is all the keys from the keyVault colleciton that matched the given filter\n   */\n\n  /**\n   * @ignore\n   * An internal class that executes across a MongoCryptContext until either\n   * a finishing state or an error is reached. Do not instantiate directly.\n   * @class StateMachine\n   */\n  class StateMachine {\n    constructor(options) {\n      this.options = options || {};\n      this.bson = options.bson;\n    }\n\n    /**\n     * @ignore\n     * Executes the state machine according to the specification\n     * @param {AutoEncrypter|ClientEncryption} autoEncrypter The JS encryption object\n     * @param {object} context The C++ context object returned from the bindings\n     * @param {StateMachine~executeCallback} callback Invoked with the result/error of executing the state machine\n     * @returns {void}\n     */\n    execute(autoEncrypter, context, callback) {\n      const bson = this.bson;\n      const keyVaultNamespace = autoEncrypter._keyVaultNamespace;\n      const keyVaultClient = autoEncrypter._keyVaultClient;\n      const metaDataClient = autoEncrypter._metaDataClient;\n      const mongocryptdClient = autoEncrypter._mongocryptdClient;\n      const mongocryptdManager = autoEncrypter._mongocryptdManager;\n\n      debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);\n      switch (context.state) {\n        case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {\n          const filter = bson.deserialize(context.nextMongoOperation());\n          this.fetchCollectionInfo(metaDataClient, context.ns, filter, (err, collInfo) => {\n            if (err) {\n              return callback(err, null);\n            }\n\n            if (collInfo) {\n              context.addMongoOperationResponse(collInfo);\n            }\n\n            context.finishMongoOperation();\n            this.execute(autoEncrypter, context, callback);\n          });\n\n          return;\n        }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {\n          const command = context.nextMongoOperation();\n          this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {\n            if (err) {\n              // If we are not bypassing spawning, then we should retry once on a MongoTimeoutError (server selection error)\n              if (\n                err instanceof MongoTimeoutError &&\n                mongocryptdManager &&\n                !mongocryptdManager.bypassSpawn\n              ) {\n                mongocryptdManager.spawn(() => {\n                  // TODO: should we be shadowing the variables here?\n                  this.markCommand(mongocryptdClient, context.ns, command, (err, markedCommand) => {\n                    if (err) return callback(err, null);\n\n                    context.addMongoOperationResponse(markedCommand);\n                    context.finishMongoOperation();\n\n                    this.execute(autoEncrypter, context, callback);\n                  });\n                });\n                return;\n              }\n              return callback(err, null);\n            }\n            context.addMongoOperationResponse(markedCommand);\n            context.finishMongoOperation();\n\n            this.execute(autoEncrypter, context, callback);\n          });\n\n          return;\n        }\n\n        case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {\n          const filter = context.nextMongoOperation();\n          this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, (err, keys) => {\n            if (err) return callback(err, null);\n            keys.forEach(key => {\n              context.addMongoOperationResponse(bson.serialize(key));\n            });\n\n            context.finishMongoOperation();\n            this.execute(autoEncrypter, context, callback);\n          });\n\n          return;\n        }\n\n        case MONGOCRYPT_CTX_NEED_KMS: {\n          const promises = [];\n\n          let request;\n          while ((request = context.nextKMSRequest())) {\n            promises.push(this.kmsRequest(request));\n          }\n\n          Promise.all(promises)\n            .then(() => {\n              context.finishKMSRequests();\n              this.execute(autoEncrypter, context, callback);\n            })\n            .catch(err => {\n              callback(err, null);\n            });\n\n          return;\n        }\n\n        // terminal states\n        case MONGOCRYPT_CTX_READY: {\n          const finalizedContext = context.finalize();\n          // TODO: Maybe rework the logic here so that instead of doing\n          // the callback here, finalize stores the result, and then\n          // we wait to MONGOCRYPT_CTX_DONE to do the callback\n          if (context.state === MONGOCRYPT_CTX_ERROR) {\n            const message = context.status.message || 'Finalization error';\n            callback(new MongoCryptError(message));\n            return;\n          }\n          callback(null, bson.deserialize(finalizedContext, this.options));\n          return;\n        }\n        case MONGOCRYPT_CTX_ERROR: {\n          const message = context.status.message;\n          callback(new MongoCryptError(message));\n          return;\n        }\n\n        case MONGOCRYPT_CTX_DONE:\n          return;\n\n        default:\n          callback(new MongoCryptError(`Unknown state: ${context.state}`));\n          return;\n      }\n    }\n\n    /**\n     * @ignore\n     * Handles the request to the KMS service. Exposed for testing purposes. Do not directly invoke.\n     * @param {*} kmsContext A C++ KMS context returned from the bindings\n     * @returns {Promise<void>} A promise that resolves when the KMS reply has be fully parsed\n     */\n    kmsRequest(request) {\n      const parsedUrl = request.endpoint.split(':');\n      const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;\n      const options = { host: parsedUrl[0], servername: parsedUrl[0], port };\n      const message = request.message;\n\n      return new Promise((resolve, reject) => {\n        const buffer = new BufferList();\n        const socket = tls.connect(options, () => {\n          socket.write(message);\n        });\n\n        socket.once('timeout', () => {\n          socket.removeAllListeners();\n          socket.destroy();\n          reject(new MongoCryptError('KMS request timed out'));\n        });\n\n        socket.once('error', err => {\n          socket.removeAllListeners();\n          socket.destroy();\n\n          const mcError = new MongoCryptError('KMS request failed');\n          mcError.originalError = err;\n          reject(mcError);\n        });\n\n        socket.on('data', data => {\n          buffer.append(data);\n          while (request.bytesNeeded > 0 && buffer.length) {\n            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);\n            request.addResponse(buffer.slice(0, bytesNeeded));\n            buffer.consume(bytesNeeded);\n          }\n\n          if (request.bytesNeeded <= 0) {\n            socket.end(resolve);\n          }\n        });\n      });\n    }\n\n    /**\n     * @ignore\n     * Fetches collection info for a provided namespace, when libmongocrypt\n     * enters the `MONGOCRYPT_CTX_NEED_MONGO_COLLINFO` state. The result is\n     * used to inform libmongocrypt of the schema associated with this\n     * namespace. Exposed for testing purposes. Do not directly invoke.\n     *\n     * @param {MongoClient} client A MongoClient connected to the topology\n     * @param {string} ns The namespace to list collections from\n     * @param {object} filter A filter for the listCollections command\n     * @param {StateMachine~fetchCollectionInfoCallback} callback Invoked with the info of the requested collection, or with an error\n     */\n    fetchCollectionInfo(client, ns, filter, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(ns);\n\n      client\n        .db(dbName)\n        .listCollections(filter)\n        .toArray((err, collections) => {\n          if (err) {\n            callback(err, null);\n            return;\n          }\n\n          const info = collections.length > 0 ? bson.serialize(collections[0]) : null;\n          callback(null, info);\n        });\n    }\n\n    /**\n     * @ignore\n     * Calls to the mongocryptd to provide markings for a command.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param {MongoClient} client A MongoClient connected to a mongocryptd\n     * @param {string} ns The namespace (database.collection) the command is being executed on\n     * @param {object} command The command to execute.\n     * @param {StateMachine~markCommandCallback} callback Invoked with the serialized and marked bson command, or with an error\n     * @returns {void}\n     */\n    markCommand(client, ns, command, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(ns);\n      const rawCommand = bson.deserialize(command, { promoteLongs: false, promoteValues: false });\n\n      client.db(dbName).command(rawCommand, (err, response) => {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        callback(err, bson.serialize(response, this.options));\n      });\n    }\n\n    /**\n     * @ignore\n     * Requests keys from the keyVault collection on the topology.\n     * Exposed for testing purposes. Do not directly invoke.\n     * @param {MongoClient} client A MongoClient connected to the topology\n     * @param {string} keyVaultNamespace The namespace (database.collection) of the keyVault Collection\n     * @param {object} filter The filter for the find query against the keyVault Collection\n     * @param {StateMachine~fetchKeysCallback} callback Invoked with the found keys, or with an error\n     * @returns {void}\n     */\n    fetchKeys(client, keyVaultNamespace, filter, callback) {\n      const bson = this.bson;\n      const dbName = databaseNamespace(keyVaultNamespace);\n      const collectionName = collectionNamespace(keyVaultNamespace);\n      filter = bson.deserialize(filter);\n\n      client\n        .db(dbName)\n        .collection(collectionName, { readConcern: { level: 'majority' } })\n        .find(filter)\n        .toArray((err, keys) => {\n          if (err) {\n            callback(err, null);\n            return;\n          }\n\n          callback(null, keys);\n        });\n    }\n  }\n\n  return { StateMachine };\n};\n"]},"metadata":{},"sourceType":"script"}