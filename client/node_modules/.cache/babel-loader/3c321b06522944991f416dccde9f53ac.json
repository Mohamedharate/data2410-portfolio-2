{"ast":null,"code":"'use strict';\n\nconst maybePromise = require('../utils').maybePromise;\n\nconst MongoError = require('../core/error').MongoError;\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core/topologies/read_preference');\n\nconst isRetryableError = require('../core/error').isRetryableError;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\n\n\nfunction executeOperation(topology, operation, cb) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(topology, cb, callback => {\n    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n      // Recursive call to executeOperation after a server selection\n      return selectServerForSessionSupport(topology, operation, callback);\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session, owner;\n\n    if (topology.hasSessionSupport()) {\n      if (operation.session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner\n        });\n        operation.session = session;\n      } else if (operation.session.hasEnded) {\n        return callback(new MongoError('Use of expired sessions is not permitted'));\n      }\n    } else if (operation.session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return callback(new MongoError('Current topology does not support sessions'));\n    }\n\n    function executeCallback(err, result) {\n      if (session && session.owner === owner) {\n        session.endSession();\n\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(err, result);\n    }\n\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        executeWithServerSelection(topology, operation, executeCallback);\n      } else {\n        operation.execute(executeCallback);\n      }\n    } catch (error) {\n      if (session && session.owner === owner) {\n        session.endSession();\n\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(error);\n    }\n  });\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n} // The Unified Topology runs serverSelection before executing every operation\n// Session support is determined by the result of a monitoring check triggered by this selection\n\n\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      return callback(err);\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n}\n\nmodule.exports = executeOperation;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb/lib/operations/execute_operation.js"],"names":["maybePromise","require","MongoError","Aspect","OperationBase","ReadPreference","isRetryableError","maxWireVersion","isUnifiedTopology","executeOperation","topology","operation","cb","TypeError","callback","shouldCheckForSessionSupport","selectServerForSessionSupport","session","owner","hasSessionSupport","Symbol","startSession","hasEnded","executeCallback","err","result","endSession","clearSession","hasAspect","EXECUTE_WITH_SELECTION","executeWithServerSelection","execute","error","supportsRetryableReads","server","readPreference","primary","inTransaction","equals","mode","serverSelectionOptions","callbackWithRetry","selectServer","shouldRetryReads","s","options","retryReads","canRetryRead","RETRYABLE","primaryPreferred","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst maybePromise = require('../utils').maybePromise;\nconst MongoError = require('../core/error').MongoError;\nconst Aspect = require('./operation').Aspect;\nconst OperationBase = require('./operation').OperationBase;\nconst ReadPreference = require('../core/topologies/read_preference');\nconst isRetryableError = require('../core/error').isRetryableError;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\nfunction executeOperation(topology, operation, cb) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  return maybePromise(topology, cb, callback => {\n    if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n      // Recursive call to executeOperation after a server selection\n      return selectServerForSessionSupport(topology, operation, callback);\n    }\n\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session, owner;\n    if (topology.hasSessionSupport()) {\n      if (operation.session == null) {\n        owner = Symbol();\n        session = topology.startSession({ owner });\n        operation.session = session;\n      } else if (operation.session.hasEnded) {\n        return callback(new MongoError('Use of expired sessions is not permitted'));\n      }\n    } else if (operation.session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return callback(new MongoError('Current topology does not support sessions'));\n    }\n\n    function executeCallback(err, result) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(err, result);\n    }\n\n    try {\n      if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n        executeWithServerSelection(topology, operation, executeCallback);\n      } else {\n        operation.execute(executeCallback);\n      }\n    } catch (error) {\n      if (session && session.owner === owner) {\n        session.endSession();\n        if (operation.session === session) {\n          operation.clearSession();\n        }\n      }\n\n      callback(error);\n    }\n  });\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(\n      new MongoError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n    const shouldRetryReads =\n      topology.s.options.retryReads !== false &&\n      operation.session &&\n      !inTransaction &&\n      supportsRetryableReads(server) &&\n      operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n}\n\n// The Unified Topology runs serverSelection before executing every operation\n// Session support is determined by the result of a monitoring check triggered by this selection\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      return callback(err);\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n}\n\nmodule.exports = executeOperation;\n"]},"metadata":{},"sourceType":"script"}