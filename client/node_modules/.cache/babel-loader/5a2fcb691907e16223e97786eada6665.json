{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar fs = require('fs'),\n    path = require('path'),\n    fileURLToPath = require('file-uri-to-path'),\n    join = path.join,\n    dirname = path.dirname,\n    exists = fs.accessSync && function (path) {\n  try {\n    fs.accessSync(path);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n} || fs.existsSync || path.existsSync,\n    defaults = {\n  arrow: process.env.NODE_BINDINGS_ARROW || ' → ',\n  compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',\n  platform: process.platform,\n  arch: process.arch,\n  nodePreGyp: 'node-v' + process.versions.modules + '-' + process.platform + '-' + process.arch,\n  version: process.versions.node,\n  bindings: 'bindings.node',\n  try: [// node-gyp's linked version in the \"build\" dir\n  ['module_root', 'build', 'bindings'], // node-waf and gyp_addon (a.k.a node-gyp)\n  ['module_root', 'build', 'Debug', 'bindings'], ['module_root', 'build', 'Release', 'bindings'], // Debug files, for development (legacy behavior, remove for node v0.9)\n  ['module_root', 'out', 'Debug', 'bindings'], ['module_root', 'Debug', 'bindings'], // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n  ['module_root', 'out', 'Release', 'bindings'], ['module_root', 'Release', 'bindings'], // Legacy from node-waf, node <= 0.4.x\n  ['module_root', 'build', 'default', 'bindings'], // Production \"Release\" buildtype binary (meh...)\n  ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'], // node-qbs builds\n  ['module_root', 'addon-build', 'release', 'install-root', 'bindings'], ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'], ['module_root', 'addon-build', 'default', 'install-root', 'bindings'], // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}\n  ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']]\n};\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\n\nfunction bindings(opts) {\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = {\n      bindings: opts\n    };\n  } else if (!opts) {\n    opts = {};\n  } // maps `defaults` onto `opts` object\n\n\n  Object.keys(defaults).map(function (i) {\n    if (!(i in opts)) opts[i] = defaults[i];\n  }); // Get the module root\n\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName());\n  } // Ensure the given bindings name ends with .node\n\n\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node';\n  } // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035\n\n\n  var requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;\n  var tries = [],\n      i = 0,\n      l = opts.try.length,\n      n,\n      b,\n      err;\n\n  for (; i < l; i++) {\n    n = join.apply(null, opts.try[i].map(function (p) {\n      return opts[p] || p;\n    }));\n    tries.push(n);\n\n    try {\n      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);\n\n      if (!opts.path) {\n        b.path = n;\n      }\n\n      return b;\n    } catch (e) {\n      if (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' && !/not find/i.test(e.message)) {\n        throw e;\n      }\n    }\n  }\n\n  err = new Error('Could not locate the bindings file. Tried:\\n' + tries.map(function (a) {\n    return opts.arrow + a;\n  }).join('\\n'));\n  err.tries = tries;\n  throw err;\n}\n\nmodule.exports = exports = bindings;\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName(calling_file) {\n  var origPST = Error.prepareStackTrace,\n      origSTL = Error.stackTraceLimit,\n      dummy = {},\n      fileName;\n  Error.stackTraceLimit = 10;\n\n  Error.prepareStackTrace = function (e, st) {\n    for (var i = 0, l = st.length; i < l; i++) {\n      fileName = st[i].getFileName();\n\n      if (fileName !== __filename) {\n        if (calling_file) {\n          if (fileName !== calling_file) {\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  }; // run the 'prepareStackTrace' function above\n\n\n  Error.captureStackTrace(dummy);\n  dummy.stack; // cleanup\n\n  Error.prepareStackTrace = origPST;\n  Error.stackTraceLimit = origSTL; // handle filename that starts with \"file://\"\n\n  var fileSchema = 'file://';\n\n  if (fileName.indexOf(fileSchema) === 0) {\n    fileName = fileURLToPath(fileName);\n  }\n\n  return fileName;\n};\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\n\nexports.getRoot = function getRoot(file) {\n  var dir = dirname(file),\n      prev;\n\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd();\n    }\n\n    if (exists(join(dir, 'package.json')) || exists(join(dir, 'node_modules'))) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir;\n    }\n\n    if (prev === dir) {\n      // Got to the top\n      throw new Error('Could not find module root given file: \"' + file + '\". Do you have a `package.json` file? ');\n    } // Try the parent dir next\n\n\n    prev = dir;\n    dir = join(dir, '..');\n  }\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/bindings/bindings.js"],"names":["fs","require","path","fileURLToPath","join","dirname","exists","accessSync","e","existsSync","defaults","arrow","process","env","NODE_BINDINGS_ARROW","compiled","NODE_BINDINGS_COMPILED_DIR","platform","arch","nodePreGyp","versions","modules","version","node","bindings","try","opts","Object","keys","map","i","module_root","exports","getRoot","getFileName","extname","requireFunc","__webpack_require__","__non_webpack_require__","tries","l","length","n","b","err","apply","p","push","resolve","code","test","message","Error","a","module","calling_file","origPST","prepareStackTrace","origSTL","stackTraceLimit","dummy","fileName","st","__filename","captureStackTrace","stack","fileSchema","indexOf","file","dir","prev","cwd"],"mappings":"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","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  fileURLToPath = require('file-uri-to-path'),\n  join = path.join,\n  dirname = path.dirname,\n  exists =\n    (fs.accessSync &&\n      function(path) {\n        try {\n          fs.accessSync(path);\n        } catch (e) {\n          return false;\n        }\n        return true;\n      }) ||\n    fs.existsSync ||\n    path.existsSync,\n  defaults = {\n    arrow: process.env.NODE_BINDINGS_ARROW || ' → ',\n    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',\n    platform: process.platform,\n    arch: process.arch,\n    nodePreGyp:\n      'node-v' +\n      process.versions.modules +\n      '-' +\n      process.platform +\n      '-' +\n      process.arch,\n    version: process.versions.node,\n    bindings: 'bindings.node',\n    try: [\n      // node-gyp's linked version in the \"build\" dir\n      ['module_root', 'build', 'bindings'],\n      // node-waf and gyp_addon (a.k.a node-gyp)\n      ['module_root', 'build', 'Debug', 'bindings'],\n      ['module_root', 'build', 'Release', 'bindings'],\n      // Debug files, for development (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Debug', 'bindings'],\n      ['module_root', 'Debug', 'bindings'],\n      // Release files, but manually compiled (legacy behavior, remove for node v0.9)\n      ['module_root', 'out', 'Release', 'bindings'],\n      ['module_root', 'Release', 'bindings'],\n      // Legacy from node-waf, node <= 0.4.x\n      ['module_root', 'build', 'default', 'bindings'],\n      // Production \"Release\" buildtype binary (meh...)\n      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],\n      // node-qbs builds\n      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],\n      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],\n      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}\n      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']\n    ]\n  };\n\n/**\n * The main `bindings()` function loads the compiled bindings for a given module.\n * It uses V8's Error API to determine the parent filename that this function is\n * being invoked from, which is then used to find the root directory.\n */\n\nfunction bindings(opts) {\n  // Argument surgery\n  if (typeof opts == 'string') {\n    opts = { bindings: opts };\n  } else if (!opts) {\n    opts = {};\n  }\n\n  // maps `defaults` onto `opts` object\n  Object.keys(defaults).map(function(i) {\n    if (!(i in opts)) opts[i] = defaults[i];\n  });\n\n  // Get the module root\n  if (!opts.module_root) {\n    opts.module_root = exports.getRoot(exports.getFileName());\n  }\n\n  // Ensure the given bindings name ends with .node\n  if (path.extname(opts.bindings) != '.node') {\n    opts.bindings += '.node';\n  }\n\n  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035\n  var requireFunc =\n    typeof __webpack_require__ === 'function'\n      ? __non_webpack_require__\n      : require;\n\n  var tries = [],\n    i = 0,\n    l = opts.try.length,\n    n,\n    b,\n    err;\n\n  for (; i < l; i++) {\n    n = join.apply(\n      null,\n      opts.try[i].map(function(p) {\n        return opts[p] || p;\n      })\n    );\n    tries.push(n);\n    try {\n      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);\n      if (!opts.path) {\n        b.path = n;\n      }\n      return b;\n    } catch (e) {\n      if (e.code !== 'MODULE_NOT_FOUND' &&\n          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&\n          !/not find/i.test(e.message)) {\n        throw e;\n      }\n    }\n  }\n\n  err = new Error(\n    'Could not locate the bindings file. Tried:\\n' +\n      tries\n        .map(function(a) {\n          return opts.arrow + a;\n        })\n        .join('\\n')\n  );\n  err.tries = tries;\n  throw err;\n}\nmodule.exports = exports = bindings;\n\n/**\n * Gets the filename of the JavaScript file that invokes this function.\n * Used to help find the root directory of a module.\n * Optionally accepts an filename argument to skip when searching for the invoking filename\n */\n\nexports.getFileName = function getFileName(calling_file) {\n  var origPST = Error.prepareStackTrace,\n    origSTL = Error.stackTraceLimit,\n    dummy = {},\n    fileName;\n\n  Error.stackTraceLimit = 10;\n\n  Error.prepareStackTrace = function(e, st) {\n    for (var i = 0, l = st.length; i < l; i++) {\n      fileName = st[i].getFileName();\n      if (fileName !== __filename) {\n        if (calling_file) {\n          if (fileName !== calling_file) {\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n    }\n  };\n\n  // run the 'prepareStackTrace' function above\n  Error.captureStackTrace(dummy);\n  dummy.stack;\n\n  // cleanup\n  Error.prepareStackTrace = origPST;\n  Error.stackTraceLimit = origSTL;\n\n  // handle filename that starts with \"file://\"\n  var fileSchema = 'file://';\n  if (fileName.indexOf(fileSchema) === 0) {\n    fileName = fileURLToPath(fileName);\n  }\n\n  return fileName;\n};\n\n/**\n * Gets the root directory of a module, given an arbitrary filename\n * somewhere in the module tree. The \"root directory\" is the directory\n * containing the `package.json` file.\n *\n *   In:  /home/nate/node-native-module/lib/index.js\n *   Out: /home/nate/node-native-module\n */\n\nexports.getRoot = function getRoot(file) {\n  var dir = dirname(file),\n    prev;\n  while (true) {\n    if (dir === '.') {\n      // Avoids an infinite loop in rare cases, like the REPL\n      dir = process.cwd();\n    }\n    if (\n      exists(join(dir, 'package.json')) ||\n      exists(join(dir, 'node_modules'))\n    ) {\n      // Found the 'package.json' file or 'node_modules' dir; we're done\n      return dir;\n    }\n    if (prev === dir) {\n      // Got to the top\n      throw new Error(\n        'Could not find module root given file: \"' +\n          file +\n          '\". Do you have a `package.json` file? '\n      );\n    }\n    // Try the parent dir next\n    prev = dir;\n    dir = join(dir, '..');\n  }\n};\n"]},"metadata":{},"sourceType":"script"}