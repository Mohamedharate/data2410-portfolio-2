{"ast":null,"code":"'use strict';\n/**\r\n * @fileOverview GridFS is a tool for MongoDB to store files to the database.\r\n * Because of the restrictions of the object size the database can hold, a\r\n * facility to split a file into several chunks is needed. The {@link GridStore}\r\n * class offers a simplified api to interact with files while managing the\r\n * chunks of split files behind the scenes. More information about GridFS can be\r\n * found <a href=\"http://www.mongodb.org/display/DOCS/GridFS\">here</a>.\r\n *\r\n * @example\r\n * const MongoClient = require('mongodb').MongoClient;\r\n * const GridStore = require('mongodb').GridStore;\r\n * const ObjectID = require('mongodb').ObjectID;\r\n * const test = require('assert');\r\n * // Connection url\r\n * const url = 'mongodb://localhost:27017';\r\n * // Database Name\r\n * const dbName = 'test';\r\n * // Connect using MongoClient\r\n * MongoClient.connect(url, function(err, client) {\r\n *   const db = client.db(dbName);\r\n *   const gridStore = new GridStore(db, null, \"w\");\r\n *   gridStore.open(function(err, gridStore) {\r\n *     gridStore.write(\"hello world!\", function(err, gridStore) {\r\n *       gridStore.close(function(err, result) {\r\n *         // Let's read the file using object Id\r\n *         GridStore.read(db, result._id, function(err, data) {\r\n *           test.equal('hello world!', data);\r\n *           client.close();\r\n *           test.done();\r\n *         });\r\n *       });\r\n *     });\r\n *   });\r\n * });\r\n */\n\nconst Chunk = require('./chunk');\n\nconst ObjectID = require('../core').BSON.ObjectID;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst fs = require('fs');\n\nconst f = require('util').format;\n\nconst util = require('util');\n\nconst MongoError = require('../core').MongoError;\n\nconst inherits = util.inherits;\n\nconst Duplex = require('stream').Duplex;\n\nconst shallowClone = require('../utils').shallowClone;\n\nconst executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nconst deprecate = require('util').deprecate;\n\nvar REFERENCE_BY_FILENAME = 0,\n    REFERENCE_BY_ID = 1;\nconst deprecationFn = deprecate(() => {}, 'GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead');\n/**\r\n * Namespace provided by the core module\r\n * @external Duplex\r\n */\n\n/**\r\n * Create a new GridStore instance\r\n *\r\n * Modes\r\n *  - **\"r\"** - read only. This is the default mode.\r\n *  - **\"w\"** - write in truncate mode. Existing data will be overwritten.\r\n *\r\n * @class\r\n * @param {Db} db A database instance to interact with.\r\n * @param {object} [id] optional unique id for this file\r\n * @param {string} [filename] optional filename for this file, no unique constrain on the field\r\n * @param {string} mode set the mode for this file.\r\n * @param {object} [options] Optional settings.\r\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\r\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\r\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\r\n * @param {boolean} [options.fsync=false] **Deprecated** Specify a file sync write concern. Use writeConcern instead.\r\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\r\n * @param {string} [options.root] Root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {string} [options.content_type] MIME type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.\r\n * @param {number} [options.chunk_size=261120] Size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.\r\n * @param {object} [options.metadata] Arbitrary data the user wants to store.\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @property {number} chunkSize Get the gridstore chunk size.\r\n * @property {number} md5 The md5 checksum for this file.\r\n * @property {number} chunkNumber The current chunk number the gridstore has materialized into memory\r\n * @return {GridStore} a GridStore instance.\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\nvar GridStore = function GridStore(db, id, filename, mode, options) {\n  deprecationFn();\n  if (!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);\n  this.db = db; // Handle options\n\n  if (typeof options === 'undefined') options = {}; // Handle mode\n\n  if (typeof mode === 'undefined') {\n    mode = filename;\n    filename = undefined;\n  } else if (typeof mode === 'object') {\n    options = mode;\n    mode = filename;\n    filename = undefined;\n  }\n\n  if (id && id._bsontype === 'ObjectID') {\n    this.referenceBy = REFERENCE_BY_ID;\n    this.fileId = id;\n    this.filename = filename;\n  } else if (typeof filename === 'undefined') {\n    this.referenceBy = REFERENCE_BY_FILENAME;\n    this.filename = id;\n\n    if (mode.indexOf('w') != null) {\n      this.fileId = new ObjectID();\n    }\n  } else {\n    this.referenceBy = REFERENCE_BY_ID;\n    this.fileId = id;\n    this.filename = filename;\n  } // Set up the rest\n\n\n  this.mode = mode == null ? 'r' : mode;\n  this.options = options || {}; // Opened\n\n  this.isOpen = false; // Set the root if overridden\n\n  this.root = this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];\n  this.position = 0;\n  this.readPreference = this.options.readPreference || db.options.readPreference || ReadPreference.primary;\n  this.writeConcern = _getWriteConcern(db, this.options); // Set default chunk size\n\n  this.internalChunkSize = this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize']; // Get the promiseLibrary\n\n  var promiseLibrary = this.options.promiseLibrary || Promise; // Set the promiseLibrary\n\n  this.promiseLibrary = promiseLibrary;\n  Object.defineProperty(this, 'chunkSize', {\n    enumerable: true,\n    get: function () {\n      return this.internalChunkSize;\n    },\n    set: function (value) {\n      if (!(this.mode[0] === 'w' && this.position === 0 && this.uploadDate == null)) {\n        // eslint-disable-next-line no-self-assign\n        this.internalChunkSize = this.internalChunkSize;\n      } else {\n        this.internalChunkSize = value;\n      }\n    }\n  });\n  Object.defineProperty(this, 'md5', {\n    enumerable: true,\n    get: function () {\n      return this.internalMd5;\n    }\n  });\n  Object.defineProperty(this, 'chunkNumber', {\n    enumerable: true,\n    get: function () {\n      return this.currentChunk && this.currentChunk.chunkNumber ? this.currentChunk.chunkNumber : null;\n    }\n  });\n};\n/**\r\n * The callback format for the Gridstore.open method\r\n * @callback GridStore~openCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {GridStore} gridStore The GridStore instance if the open method was successful.\r\n */\n\n/**\r\n * Opens the file from the database and initialize this object. Also creates a\r\n * new one if file does not exist.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~openCallback} [callback] this will be called after executing this method\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.open = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n\n  if (this.mode !== 'w' && this.mode !== 'w+' && this.mode !== 'r') {\n    throw MongoError.create({\n      message: 'Illegal mode ' + this.mode,\n      driver: true\n    });\n  }\n\n  return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar open = function (self, options, callback) {\n  // Get the write concern\n  var writeConcern = _getWriteConcern(self.db, self.options); // If we are writing we need to ensure we have the right indexes for md5's\n\n\n  if (self.mode === 'w' || self.mode === 'w+') {\n    // Get files collection\n    var collection = self.collection(); // Put index on filename\n\n    collection.ensureIndex([['filename', 1]], writeConcern, function () {\n      // Get chunk collection\n      var chunkCollection = self.chunkCollection(); // Make an unique index for compatibility with mongo-cxx-driver:legacy\n\n      var chunkIndexOptions = shallowClone(writeConcern);\n      chunkIndexOptions.unique = true; // Ensure index on chunk collection\n\n      chunkCollection.ensureIndex([['files_id', 1], ['n', 1]], chunkIndexOptions, function () {\n        // Open the connection\n        _open(self, writeConcern, function (err, r) {\n          if (err) return callback(err);\n          self.isOpen = true;\n          callback(err, r);\n        });\n      });\n    });\n  } else {\n    // Open the gridstore\n    _open(self, writeConcern, function (err, r) {\n      if (err) return callback(err);\n      self.isOpen = true;\n      callback(err, r);\n    });\n  }\n};\n/**\r\n * Verify if the file is at EOF.\r\n *\r\n * @method\r\n * @return {boolean} true if the read/write head is at the end of this file.\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.eof = function () {\n  return this.position === this.length ? true : false;\n};\n/**\r\n * The callback result format.\r\n * @callback GridStore~resultCallback\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {object} result The result from the callback.\r\n */\n\n/**\r\n * Retrieves a single character from this file.\r\n *\r\n * @method\r\n * @param {GridStore~resultCallback} [callback] this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.getc = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar getc = function (self, options, callback) {\n  if (self.eof()) {\n    callback(null, null);\n  } else if (self.currentChunk.eof()) {\n    nthChunk(self, self.currentChunk.chunkNumber + 1, function (err, chunk) {\n      self.currentChunk = chunk;\n      self.position = self.position + 1;\n      callback(err, self.currentChunk.getc());\n    });\n  } else {\n    self.position = self.position + 1;\n    callback(null, self.currentChunk.getc());\n  }\n};\n/**\r\n * Writes a string to the file with a newline character appended at the end if\r\n * the given string does not have one.\r\n *\r\n * @method\r\n * @param {string} string the string to write.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.puts = function (string, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  var finalString = string.match(/\\n$/) == null ? string + '\\n' : string;\n  return executeLegacyOperation(this.db.s.topology, this.write.bind(this), [finalString, options, callback], {\n    skipSessions: true\n  });\n};\n/**\r\n * Return a modified Readable stream including a possible transform method.\r\n *\r\n * @method\r\n * @return {GridStoreStream}\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.stream = function () {\n  return new GridStoreStream(this);\n};\n/**\r\n * Writes some data. This method will work properly only if initialized with mode \"w\" or \"w+\".\r\n *\r\n * @method\r\n * @param {(string|Buffer)} data the data to write.\r\n * @param {boolean} [close] closes this file after writing if set to true.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.write = function write(data, close, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, _writeNormal, [this, data, close, options, callback], {\n    skipSessions: true\n  });\n};\n/**\r\n * Handles the destroy part of a stream\r\n *\r\n * @method\r\n * @result {null}\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.destroy = function destroy() {\n  // close and do not emit any more events. queued data is not sent.\n  if (!this.writable) return;\n  this.readable = false;\n\n  if (this.writable) {\n    this.writable = false;\n    this._q.length = 0;\n    this.emit('close');\n  }\n};\n/**\r\n * Stores a file from the file system to the GridFS database.\r\n *\r\n * @method\r\n * @param {(string|Buffer|FileHandle)} file the file to store.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.writeFile = function (file, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar writeFile = function (self, file, options, callback) {\n  if (typeof file === 'string') {\n    fs.open(file, 'r', function (err, fd) {\n      if (err) return callback(err);\n      self.writeFile(fd, callback);\n    });\n    return;\n  }\n\n  self.open(function (err, self) {\n    if (err) return callback(err, self);\n    fs.fstat(file, function (err, stats) {\n      if (err) return callback(err, self);\n      var offset = 0;\n      var index = 0; // Write a chunk\n\n      var writeChunk = function () {\n        // Allocate the buffer\n        var _buffer = Buffer.alloc(self.chunkSize); // Read the file\n\n\n        fs.read(file, _buffer, 0, _buffer.length, offset, function (err, bytesRead, data) {\n          if (err) return callback(err, self);\n          offset = offset + bytesRead; // Create a new chunk for the data\n\n          var chunk = new Chunk(self, {\n            n: index++\n          }, self.writeConcern);\n          chunk.write(data.slice(0, bytesRead), function (err, chunk) {\n            if (err) return callback(err, self);\n            chunk.save({}, function (err) {\n              if (err) return callback(err, self);\n              self.position = self.position + bytesRead; // Point to current chunk\n\n              self.currentChunk = chunk;\n\n              if (offset >= stats.size) {\n                fs.close(file, function (err) {\n                  if (err) return callback(err);\n                  self.close(function (err) {\n                    if (err) return callback(err, self);\n                    return callback(null, self);\n                  });\n                });\n              } else {\n                return process.nextTick(writeChunk);\n              }\n            });\n          });\n        });\n      }; // Process the first write\n\n\n      process.nextTick(writeChunk);\n    });\n  });\n};\n/**\r\n * Saves this file to the database. This will overwrite the old entry if it\r\n * already exists. This will work properly only if mode was initialized to\r\n * \"w\" or \"w+\".\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.close = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar close = function (self, options, callback) {\n  if (self.mode[0] === 'w') {\n    // Set up options\n    options = Object.assign({}, self.writeConcern, options);\n\n    if (self.currentChunk != null && self.currentChunk.position > 0) {\n      self.currentChunk.save({}, function (err) {\n        if (err && typeof callback === 'function') return callback(err);\n        self.collection(function (err, files) {\n          if (err && typeof callback === 'function') return callback(err); // Build the mongo object\n\n          if (self.uploadDate != null) {\n            buildMongoObject(self, function (err, mongoObject) {\n              if (err) {\n                if (typeof callback === 'function') return callback(err);else throw err;\n              }\n\n              files.save(mongoObject, options, function (err) {\n                if (typeof callback === 'function') callback(err, mongoObject);\n              });\n            });\n          } else {\n            self.uploadDate = new Date();\n            buildMongoObject(self, function (err, mongoObject) {\n              if (err) {\n                if (typeof callback === 'function') return callback(err);else throw err;\n              }\n\n              files.save(mongoObject, options, function (err) {\n                if (typeof callback === 'function') callback(err, mongoObject);\n              });\n            });\n          }\n        });\n      });\n    } else {\n      self.collection(function (err, files) {\n        if (err && typeof callback === 'function') return callback(err);\n        self.uploadDate = new Date();\n        buildMongoObject(self, function (err, mongoObject) {\n          if (err) {\n            if (typeof callback === 'function') return callback(err);else throw err;\n          }\n\n          files.save(mongoObject, options, function (err) {\n            if (typeof callback === 'function') callback(err, mongoObject);\n          });\n        });\n      });\n    }\n  } else if (self.mode[0] === 'r') {\n    if (typeof callback === 'function') callback(null, null);\n  } else {\n    if (typeof callback === 'function') callback(MongoError.create({\n      message: f('Illegal mode %s', self.mode),\n      driver: true\n    }));\n  }\n};\n/**\r\n * The collection callback format.\r\n * @callback GridStore~collectionCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {Collection} collection The collection from the command execution.\r\n */\n\n/**\r\n * Retrieve this file's chunks collection.\r\n *\r\n * @method\r\n * @param {GridStore~collectionCallback} callback the command callback.\r\n * @return {Collection}\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.chunkCollection = function (callback) {\n  if (typeof callback === 'function') return this.db.collection(this.root + '.chunks', callback);\n  return this.db.collection(this.root + '.chunks');\n};\n/**\r\n * Deletes all the chunks of this file in the database.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.unlink = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar unlink = function (self, options, callback) {\n  deleteChunks(self, function (err) {\n    if (err !== null) {\n      err.message = 'at deleteChunks: ' + err.message;\n      return callback(err);\n    }\n\n    self.collection(function (err, collection) {\n      if (err !== null) {\n        err.message = 'at collection: ' + err.message;\n        return callback(err);\n      }\n\n      collection.remove({\n        _id: self.fileId\n      }, self.writeConcern, function (err) {\n        callback(err, self);\n      });\n    });\n  });\n};\n/**\r\n * Retrieves the file collection associated with this object.\r\n *\r\n * @method\r\n * @param {GridStore~collectionCallback} callback the command callback.\r\n * @return {Collection}\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.collection = function (callback) {\n  if (typeof callback === 'function') this.db.collection(this.root + '.files', callback);\n  return this.db.collection(this.root + '.files');\n};\n/**\r\n * The readlines callback format.\r\n * @callback GridStore~readlinesCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {string[]} strings The array of strings returned.\r\n */\n\n/**\r\n * Read the entire file as a list of strings splitting by the provided separator.\r\n *\r\n * @method\r\n * @param {string} [separator] The character to be recognized as the newline separator.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readlinesCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.readlines = function (separator, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  separator = args.length ? args.shift() : '\\n';\n  separator = separator || '\\n';\n  options = args.length ? args.shift() : {};\n  return executeLegacyOperation(this.db.s.topology, readlines, [this, separator, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar readlines = function (self, separator, options, callback) {\n  self.read(function (err, data) {\n    if (err) return callback(err);\n    var items = data.toString().split(separator);\n    items = items.length > 0 ? items.splice(0, items.length - 1) : [];\n\n    for (var i = 0; i < items.length; i++) {\n      items[i] = items[i] + separator;\n    }\n\n    callback(null, items);\n  });\n};\n/**\r\n * Deletes all the chunks of this file in the database if mode was set to \"w\" or\r\n * \"w+\" and resets the read/write head to the initial position.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.rewind = function (options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {};\n  return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar rewind = function (self, options, callback) {\n  if (self.currentChunk.chunkNumber !== 0) {\n    if (self.mode[0] === 'w') {\n      deleteChunks(self, function (err) {\n        if (err) return callback(err);\n        self.currentChunk = new Chunk(self, {\n          n: 0\n        }, self.writeConcern);\n        self.position = 0;\n        callback(null, self);\n      });\n    } else {\n      self.currentChunk(0, function (err, chunk) {\n        if (err) return callback(err);\n        self.currentChunk = chunk;\n        self.currentChunk.rewind();\n        self.position = 0;\n        callback(null, self);\n      });\n    }\n  } else {\n    self.currentChunk.rewind();\n    self.position = 0;\n    callback(null, self);\n  }\n};\n/**\r\n * The read callback format.\r\n * @callback GridStore~readCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {Buffer} data The data read from the GridStore object\r\n */\n\n/**\r\n * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.\r\n *\r\n * There are 3 signatures for this method:\r\n *\r\n * (callback)\r\n * (length, callback)\r\n * (length, buffer, callback)\r\n *\r\n * @method\r\n * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.\r\n * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.read = function (length, buffer, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  length = args.length ? args.shift() : null;\n  buffer = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  return executeLegacyOperation(this.db.s.topology, read, [this, length, buffer, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar read = function (self, length, buffer, options, callback) {\n  // The data is a c-terminated string and thus the length - 1\n  var finalLength = length == null ? self.length - self.position : length;\n  var finalBuffer = buffer == null ? Buffer.alloc(finalLength) : buffer; // Add a index to buffer to keep track of writing position or apply current index\n\n  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;\n\n  if (self.currentChunk.length() - self.currentChunk.position + finalBuffer._index >= finalLength) {\n    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index); // Copy content to final buffer\n\n    slice.copy(finalBuffer, finalBuffer._index); // Update internal position\n\n    self.position = self.position + finalBuffer.length; // Check if we don't have a file at all\n\n    if (finalLength === 0 && finalBuffer.length === 0) return callback(MongoError.create({\n      message: 'File does not exist',\n      driver: true\n    }), null); // Else return data\n\n    return callback(null, finalBuffer);\n  } // Read the next chunk\n\n\n  slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position); // Copy content to final buffer\n\n  slice.copy(finalBuffer, finalBuffer._index); // Update index position\n\n  finalBuffer._index += slice.length; // Load next chunk and read more\n\n  nthChunk(self, self.currentChunk.chunkNumber + 1, function (err, chunk) {\n    if (err) return callback(err);\n\n    if (chunk.length() > 0) {\n      self.currentChunk = chunk;\n      self.read(length, finalBuffer, callback);\n    } else {\n      if (finalBuffer._index > 0) {\n        callback(null, finalBuffer);\n      } else {\n        callback(MongoError.create({\n          message: 'no chunks found for file, possibly corrupt',\n          driver: true\n        }), null);\n      }\n    }\n  });\n};\n/**\r\n * The tell callback format.\r\n * @callback GridStore~tellCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {number} position The current read position in the GridStore.\r\n */\n\n/**\r\n * Retrieves the position of the read/write head of this file.\r\n *\r\n * @method\r\n * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.\r\n * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~tellCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.tell = function (callback) {\n  var self = this; // We provided a callback leg\n\n  if (typeof callback === 'function') return callback(null, this.position); // Return promise\n\n  return new self.promiseLibrary(function (resolve) {\n    resolve(self.position);\n  });\n};\n/**\r\n * The tell callback format.\r\n * @callback GridStore~gridStoreCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {GridStore} gridStore The gridStore.\r\n */\n\n/**\r\n * Moves the read/write head to a new location.\r\n *\r\n * There are 3 signatures for this method\r\n *\r\n * Seek Location Modes\r\n *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.\r\n *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.\r\n *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.\r\n *\r\n * @method\r\n * @param {number} [position] the position to seek to\r\n * @param {number} [seekLocation] seek mode. Use one of the Seek Location modes.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~gridStoreCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.prototype.seek = function (position, seekLocation, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  seekLocation = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  return executeLegacyOperation(this.db.s.topology, seek, [this, position, seekLocation, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar seek = function (self, position, seekLocation, options, callback) {\n  // Seek only supports read mode\n  if (self.mode !== 'r') {\n    return callback(MongoError.create({\n      message: 'seek is only supported for mode r',\n      driver: true\n    }));\n  }\n\n  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;\n  var finalPosition = position;\n  var targetPosition = 0; // Calculate the position\n\n  if (seekLocationFinal === GridStore.IO_SEEK_CUR) {\n    targetPosition = self.position + finalPosition;\n  } else if (seekLocationFinal === GridStore.IO_SEEK_END) {\n    targetPosition = self.length + finalPosition;\n  } else {\n    targetPosition = finalPosition;\n  } // Get the chunk\n\n\n  var newChunkNumber = Math.floor(targetPosition / self.chunkSize);\n\n  var seekChunk = function () {\n    nthChunk(self, newChunkNumber, function (err, chunk) {\n      if (err) return callback(err, null);\n      if (chunk == null) return callback(new Error('no chunk found')); // Set the current chunk\n\n      self.currentChunk = chunk;\n      self.position = targetPosition;\n      self.currentChunk.position = self.position % self.chunkSize;\n      callback(err, self);\n    });\n  };\n\n  seekChunk();\n};\n/**\r\n * @ignore\r\n */\n\n\nvar _open = function (self, options, callback) {\n  var collection = self.collection(); // Create the query\n\n  var query = self.referenceBy === REFERENCE_BY_ID ? {\n    _id: self.fileId\n  } : {\n    filename: self.filename\n  };\n  query = null == self.fileId && self.filename == null ? null : query;\n  options.readPreference = self.readPreference; // Fetch the chunks\n\n  if (query != null) {\n    collection.findOne(query, options, function (err, doc) {\n      if (err) {\n        return error(err);\n      } // Check if the collection for the files exists otherwise prepare the new one\n\n\n      if (doc != null) {\n        self.fileId = doc._id; // Prefer a new filename over the existing one if this is a write\n\n        self.filename = self.mode === 'r' || self.filename === undefined ? doc.filename : self.filename;\n        self.contentType = doc.contentType;\n        self.internalChunkSize = doc.chunkSize;\n        self.uploadDate = doc.uploadDate;\n        self.aliases = doc.aliases;\n        self.length = doc.length;\n        self.metadata = doc.metadata;\n        self.internalMd5 = doc.md5;\n      } else if (self.mode !== 'r') {\n        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;\n        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;\n        self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;\n        self.length = 0;\n      } else {\n        self.length = 0;\n        var txtId = self.fileId._bsontype === 'ObjectID' ? self.fileId.toHexString() : self.fileId;\n        return error(MongoError.create({\n          message: f('file with id %s not opened for writing', self.referenceBy === REFERENCE_BY_ID ? txtId : self.filename),\n          driver: true\n        }), self);\n      } // Process the mode of the object\n\n\n      if (self.mode === 'r') {\n        nthChunk(self, 0, options, function (err, chunk) {\n          if (err) return error(err);\n          self.currentChunk = chunk;\n          self.position = 0;\n          callback(null, self);\n        });\n      } else if (self.mode === 'w' && doc) {\n        // Delete any existing chunks\n        deleteChunks(self, options, function (err) {\n          if (err) return error(err);\n          self.currentChunk = new Chunk(self, {\n            n: 0\n          }, self.writeConcern);\n          self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];\n          self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];\n          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\n          self.position = 0;\n          callback(null, self);\n        });\n      } else if (self.mode === 'w') {\n        self.currentChunk = new Chunk(self, {\n          n: 0\n        }, self.writeConcern);\n        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];\n        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\n        self.position = 0;\n        callback(null, self);\n      } else if (self.mode === 'w+') {\n        nthChunk(self, lastChunkNumber(self), options, function (err, chunk) {\n          if (err) return error(err); // Set the current chunk\n\n          self.currentChunk = chunk == null ? new Chunk(self, {\n            n: 0\n          }, self.writeConcern) : chunk;\n          self.currentChunk.position = self.currentChunk.data.length();\n          self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\n          self.position = self.length;\n          callback(null, self);\n        });\n      }\n    });\n  } else {\n    // Write only mode\n    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;\n    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;\n    self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;\n    self.length = 0; // No file exists set up write mode\n\n    if (self.mode === 'w') {\n      // Delete any existing chunks\n      deleteChunks(self, options, function (err) {\n        if (err) return error(err);\n        self.currentChunk = new Chunk(self, {\n          n: 0\n        }, self.writeConcern);\n        self.contentType = self.options['content_type'] == null ? self.contentType : self.options['content_type'];\n        self.internalChunkSize = self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\n        self.position = 0;\n        callback(null, self);\n      });\n    } else if (self.mode === 'w+') {\n      nthChunk(self, lastChunkNumber(self), options, function (err, chunk) {\n        if (err) return error(err); // Set the current chunk\n\n        self.currentChunk = chunk == null ? new Chunk(self, {\n          n: 0\n        }, self.writeConcern) : chunk;\n        self.currentChunk.position = self.currentChunk.data.length();\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\n        self.position = self.length;\n        callback(null, self);\n      });\n    }\n  } // only pass error to callback once\n\n\n  function error(err) {\n    if (error.err) return;\n    callback(error.err = err);\n  }\n};\n/**\r\n * @ignore\r\n */\n\n\nvar writeBuffer = function (self, buffer, close, callback) {\n  if (typeof close === 'function') {\n    callback = close;\n    close = null;\n  }\n\n  var finalClose = typeof close === 'boolean' ? close : false;\n\n  if (self.mode !== 'w') {\n    callback(MongoError.create({\n      message: f('file with id %s not opened for writing', self.referenceBy === REFERENCE_BY_ID ? self.referenceBy : self.filename),\n      driver: true\n    }), null);\n  } else {\n    if (self.currentChunk.position + buffer.length >= self.chunkSize) {\n      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left\n      // to a new chunk (recursively)\n      var previousChunkNumber = self.currentChunk.chunkNumber;\n      var leftOverDataSize = self.chunkSize - self.currentChunk.position;\n      var firstChunkData = buffer.slice(0, leftOverDataSize);\n      var leftOverData = buffer.slice(leftOverDataSize); // A list of chunks to write out\n\n      var chunksToWrite = [self.currentChunk.write(firstChunkData)]; // If we have more data left than the chunk size let's keep writing new chunks\n\n      while (leftOverData.length >= self.chunkSize) {\n        // Create a new chunk and write to it\n        var newChunk = new Chunk(self, {\n          n: previousChunkNumber + 1\n        }, self.writeConcern);\n        firstChunkData = leftOverData.slice(0, self.chunkSize);\n        leftOverData = leftOverData.slice(self.chunkSize); // Update chunk number\n\n        previousChunkNumber = previousChunkNumber + 1; // Write data\n\n        newChunk.write(firstChunkData); // Push chunk to save list\n\n        chunksToWrite.push(newChunk);\n      } // Set current chunk with remaining data\n\n\n      self.currentChunk = new Chunk(self, {\n        n: previousChunkNumber + 1\n      }, self.writeConcern); // If we have left over data write it\n\n      if (leftOverData.length > 0) self.currentChunk.write(leftOverData); // Update the position for the gridstore\n\n      self.position = self.position + buffer.length; // Total number of chunks to write\n\n      var numberOfChunksToWrite = chunksToWrite.length;\n\n      for (var i = 0; i < chunksToWrite.length; i++) {\n        chunksToWrite[i].save({}, function (err) {\n          if (err) return callback(err);\n          numberOfChunksToWrite = numberOfChunksToWrite - 1;\n\n          if (numberOfChunksToWrite <= 0) {\n            // We care closing the file before returning\n            if (finalClose) {\n              return self.close(function (err) {\n                callback(err, self);\n              });\n            } // Return normally\n\n\n            return callback(null, self);\n          }\n        });\n      }\n    } else {\n      // Update the position for the gridstore\n      self.position = self.position + buffer.length; // We have less data than the chunk size just write it and callback\n\n      self.currentChunk.write(buffer); // We care closing the file before returning\n\n      if (finalClose) {\n        return self.close(function (err) {\n          callback(err, self);\n        });\n      } // Return normally\n\n\n      return callback(null, self);\n    }\n  }\n};\n/**\r\n * Creates a mongoDB object representation of this object.\r\n *\r\n *        <pre><code>\r\n *        {\r\n *          '_id' : , // {number} id for this file\r\n *          'filename' : , // {string} name for this file\r\n *          'contentType' : , // {string} mime type for this file\r\n *          'length' : , // {number} size of this file?\r\n *          'chunksize' : , // {number} chunk size used by this file\r\n *          'uploadDate' : , // {Date}\r\n *          'aliases' : , // {array of string}\r\n *          'metadata' : , // {string}\r\n *        }\r\n *        </code></pre>\r\n *\r\n * @ignore\r\n */\n\n\nvar buildMongoObject = function (self, callback) {\n  // Calcuate the length\n  var mongoObject = {\n    _id: self.fileId,\n    filename: self.filename,\n    contentType: self.contentType,\n    length: self.position ? self.position : 0,\n    chunkSize: self.chunkSize,\n    uploadDate: self.uploadDate,\n    aliases: self.aliases,\n    metadata: self.metadata\n  };\n  var md5Command = {\n    filemd5: self.fileId,\n    root: self.root\n  };\n  self.db.command(md5Command, function (err, results) {\n    if (err) return callback(err);\n    mongoObject.md5 = results.md5;\n    callback(null, mongoObject);\n  });\n};\n/**\r\n * Gets the nth chunk of this file.\r\n * @ignore\r\n */\n\n\nvar nthChunk = function (self, chunkNumber, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || self.writeConcern;\n  options.readPreference = self.readPreference; // Get the nth chunk\n\n  self.chunkCollection().findOne({\n    files_id: self.fileId,\n    n: chunkNumber\n  }, options, function (err, chunk) {\n    if (err) return callback(err);\n    var finalChunk = chunk == null ? {} : chunk;\n    callback(null, new Chunk(self, finalChunk, self.writeConcern));\n  });\n};\n/**\r\n * @ignore\r\n */\n\n\nvar lastChunkNumber = function (self) {\n  return Math.floor((self.length ? self.length - 1 : 0) / self.chunkSize);\n};\n/**\r\n * Deletes all the chunks of this file in the database.\r\n *\r\n * @ignore\r\n */\n\n\nvar deleteChunks = function (self, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || self.writeConcern;\n\n  if (self.fileId != null) {\n    self.chunkCollection().remove({\n      files_id: self.fileId\n    }, options, function (err) {\n      if (err) return callback(err, false);\n      callback(null, true);\n    });\n  } else {\n    callback(null, true);\n  }\n};\n/**\r\n * The collection to be used for holding the files and chunks collection.\r\n *\r\n * @classconstant DEFAULT_ROOT_COLLECTION\r\n */\n\n\nGridStore.DEFAULT_ROOT_COLLECTION = 'fs';\n/**\r\n * Default file mime type\r\n *\r\n * @classconstant DEFAULT_CONTENT_TYPE\r\n */\n\nGridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';\n/**\r\n * Seek mode where the given length is absolute.\r\n *\r\n * @classconstant IO_SEEK_SET\r\n */\n\nGridStore.IO_SEEK_SET = 0;\n/**\r\n * Seek mode where the given length is an offset to the current read/write head.\r\n *\r\n * @classconstant IO_SEEK_CUR\r\n */\n\nGridStore.IO_SEEK_CUR = 1;\n/**\r\n * Seek mode where the given length is an offset to the end of the file.\r\n *\r\n * @classconstant IO_SEEK_END\r\n */\n\nGridStore.IO_SEEK_END = 2;\n/**\r\n * Checks if a file exists in the database.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} name The name of the file to look for.\r\n * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] result from exists.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\nGridStore.exist = function (db, fileIdObject, rootCollection, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  rootCollection = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  options = options || {};\n  return executeLegacyOperation(db.s.topology, exists, [db, fileIdObject, rootCollection, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar exists = function (db, fileIdObject, rootCollection, options, callback) {\n  // Establish read preference\n  var readPreference = options.readPreference || ReadPreference.PRIMARY; // Fetch collection\n\n  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;\n  db.collection(rootCollectionFinal + '.files', function (err, collection) {\n    if (err) return callback(err); // Build query\n\n    var query = typeof fileIdObject === 'string' || Object.prototype.toString.call(fileIdObject) === '[object RegExp]' ? {\n      filename: fileIdObject\n    } : {\n      _id: fileIdObject\n    }; // Attempt to locate file\n    // We have a specific query\n\n    if (fileIdObject != null && typeof fileIdObject === 'object' && Object.prototype.toString.call(fileIdObject) !== '[object RegExp]') {\n      query = fileIdObject;\n    } // Check if the entry exists\n\n\n    collection.findOne(query, {\n      readPreference: readPreference\n    }, function (err, item) {\n      if (err) return callback(err);\n      callback(null, item == null ? false : true);\n    });\n  });\n};\n/**\r\n * Gets the list of files stored in the GridFS.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] result from exists.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.list = function (db, rootCollection, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  rootCollection = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : {};\n  options = options || {};\n  return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar list = function (db, rootCollection, options, callback) {\n  // Ensure we have correct values\n  if (rootCollection != null && typeof rootCollection === 'object') {\n    options = rootCollection;\n    rootCollection = null;\n  } // Establish read preference\n\n\n  var readPreference = options.readPreference || ReadPreference.primary; // Check if we are returning by id not filename\n\n  var byId = options['id'] != null ? options['id'] : false; // Fetch item\n\n  var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;\n  var items = [];\n  db.collection(rootCollectionFinal + '.files', function (err, collection) {\n    if (err) return callback(err);\n    collection.find({}, {\n      readPreference: readPreference\n    }, function (err, cursor) {\n      if (err) return callback(err);\n      cursor.each(function (err, item) {\n        if (item != null) {\n          items.push(byId ? item._id : item.filename);\n        } else {\n          callback(err, items);\n        }\n      });\n    });\n  });\n};\n/**\r\n * Reads the contents of a file.\r\n *\r\n * This method has the following signatures\r\n *\r\n * (db, name, callback)\r\n * (db, name, length, callback)\r\n * (db, name, length, offset, callback)\r\n * (db, name, length, offset, options, callback)\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} name The name of the file.\r\n * @param {number} [length] The size of data to read.\r\n * @param {number} [offset] The offset from the head of the file of which to start reading from.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.read = function (db, name, length, offset, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  length = args.length ? args.shift() : null;\n  offset = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : null;\n  options = options || {};\n  return executeLegacyOperation(db.s.topology, readStatic, [db, name, length, offset, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar readStatic = function (db, name, length, offset, options, callback) {\n  new GridStore(db, name, 'r', options).open(function (err, gridStore) {\n    if (err) return callback(err); // Make sure we are not reading out of bounds\n\n    if (offset && offset >= gridStore.length) return callback('offset larger than size of file', null);\n    if (length && length > gridStore.length) return callback('length is larger than the size of the file', null);\n    if (offset && length && offset + length > gridStore.length) return callback('offset and length is larger than the size of the file', null);\n\n    if (offset != null) {\n      gridStore.seek(offset, function (err, gridStore) {\n        if (err) return callback(err);\n        gridStore.read(length, callback);\n      });\n    } else {\n      gridStore.read(length, callback);\n    }\n  });\n};\n/**\r\n * Read the entire file as a list of strings splitting by the provided separator.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {(String|object)} name the name of the file.\r\n * @param {string} [separator] The character to be recognized as the newline separator.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readlinesCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.readlines = function (db, name, separator, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  separator = args.length ? args.shift() : null;\n  options = args.length ? args.shift() : null;\n  options = options || {};\n  return executeLegacyOperation(db.s.topology, readlinesStatic, [db, name, separator, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar readlinesStatic = function (db, name, separator, options, callback) {\n  var finalSeperator = separator == null ? '\\n' : separator;\n  new GridStore(db, name, 'r', options).open(function (err, gridStore) {\n    if (err) return callback(err);\n    gridStore.readlines(finalSeperator, callback);\n  });\n};\n/**\r\n * Deletes the chunks and metadata information of a file from GridFS.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db The database to query.\r\n * @param {(string|array)} names The name/names of the files to delete.\r\n * @param {object} [options] Optional settings.\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nGridStore.unlink = function (db, names, options, callback) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  options = args.length ? args.shift() : {};\n  options = options || {};\n  return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {\n    skipSessions: true\n  });\n};\n\nvar unlinkStatic = function (self, db, names, options, callback) {\n  // Get the write concern\n  var writeConcern = _getWriteConcern(db, options); // List of names\n\n\n  if (names.constructor === Array) {\n    var tc = 0;\n\n    for (var i = 0; i < names.length; i++) {\n      ++tc;\n      GridStore.unlink(db, names[i], options, function () {\n        if (--tc === 0) {\n          callback(null, self);\n        }\n      });\n    }\n  } else {\n    new GridStore(db, names, 'w', options).open(function (err, gridStore) {\n      if (err) return callback(err);\n      deleteChunks(gridStore, function (err) {\n        if (err) return callback(err);\n        gridStore.collection(function (err, collection) {\n          if (err) return callback(err);\n          collection.remove({\n            _id: gridStore.fileId\n          }, writeConcern, function (err) {\n            callback(err, self);\n          });\n        });\n      });\n    });\n  }\n};\n/**\r\n *  @ignore\r\n */\n\n\nvar _writeNormal = function (self, data, close, options, callback) {\n  // If we have a buffer write it using the writeBuffer method\n  if (Buffer.isBuffer(data)) {\n    return writeBuffer(self, data, close, callback);\n  } else {\n    return writeBuffer(self, Buffer.from(data, 'binary'), close, callback);\n  }\n};\n/**\r\n * @ignore\r\n */\n\n\nvar _setWriteConcernHash = function (options) {\n  const baseOptions = Object.assign(options, options.writeConcern);\n  var finalOptions = {};\n  if (baseOptions.w != null) finalOptions.w = baseOptions.w;\n  if (baseOptions.journal === true) finalOptions.j = baseOptions.journal;\n  if (baseOptions.j === true) finalOptions.j = baseOptions.j;\n  if (baseOptions.fsync === true) finalOptions.fsync = baseOptions.fsync;\n  if (baseOptions.wtimeout != null) finalOptions.wtimeout = baseOptions.wtimeout;\n  return finalOptions;\n};\n/**\r\n * @ignore\r\n */\n\n\nvar _getWriteConcern = function (self, options) {\n  // Final options\n  var finalOptions = {\n    w: 1\n  };\n  options = options || {}; // Local options verification\n\n  if (options.writeConcern != null || options.w != null || typeof options.j === 'boolean' || typeof options.journal === 'boolean' || typeof options.fsync === 'boolean') {\n    finalOptions = _setWriteConcernHash(options);\n  } else if (options.safe != null && typeof options.safe === 'object') {\n    finalOptions = _setWriteConcernHash(options.safe);\n  } else if (typeof options.safe === 'boolean') {\n    finalOptions = {\n      w: options.safe ? 1 : 0\n    };\n  } else if (self.options.writeConcern != null || self.options.w != null || typeof self.options.j === 'boolean' || typeof self.options.journal === 'boolean' || typeof self.options.fsync === 'boolean') {\n    finalOptions = _setWriteConcernHash(self.options);\n  } else if (self.safe && (self.safe.w != null || typeof self.safe.j === 'boolean' || typeof self.safe.journal === 'boolean' || typeof self.safe.fsync === 'boolean')) {\n    finalOptions = _setWriteConcernHash(self.safe);\n  } else if (typeof self.safe === 'boolean') {\n    finalOptions = {\n      w: self.safe ? 1 : 0\n    };\n  } // Ensure we don't have an invalid combination of write concerns\n\n\n  if (finalOptions.w < 1 && (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true)) throw MongoError.create({\n    message: 'No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true',\n    driver: true\n  }); // Return the options\n\n  return finalOptions;\n};\n/**\r\n * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)\r\n *\r\n * @class\r\n * @extends external:Duplex\r\n * @return {GridStoreStream} a GridStoreStream instance.\r\n * @deprecated Use GridFSBucket API instead\r\n */\n\n\nvar GridStoreStream = function (gs) {\n  // Initialize the duplex stream\n  Duplex.call(this); // Get the gridstore\n\n  this.gs = gs; // End called\n\n  this.endCalled = false; // If we have a seek\n\n  this.totalBytesToRead = this.gs.length - this.gs.position;\n  this.seekPosition = this.gs.position;\n}; //\n// Inherit duplex\n\n\ninherits(GridStoreStream, Duplex);\nGridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe; // Set up override\n\nGridStoreStream.prototype.pipe = function (destination) {\n  var self = this; // Only open gridstore if not already open\n\n  if (!self.gs.isOpen) {\n    self.gs.open(function (err) {\n      if (err) return self.emit('error', err);\n      self.totalBytesToRead = self.gs.length - self.gs.position;\n\n      self._pipe.apply(self, [destination]);\n    });\n  } else {\n    self.totalBytesToRead = self.gs.length - self.gs.position;\n\n    self._pipe.apply(self, [destination]);\n  }\n\n  return destination;\n}; // Called by stream\n\n\nGridStoreStream.prototype._read = function () {\n  var self = this;\n\n  var read = function () {\n    // Read data\n    self.gs.read(length, function (err, buffer) {\n      if (err && !self.endCalled) return self.emit('error', err); // Stream is closed\n\n      if (self.endCalled || buffer == null) return self.push(null); // Remove bytes read\n\n      if (buffer.length <= self.totalBytesToRead) {\n        self.totalBytesToRead = self.totalBytesToRead - buffer.length;\n        self.push(buffer);\n      } else if (buffer.length > self.totalBytesToRead) {\n        self.totalBytesToRead = self.totalBytesToRead - buffer._index;\n        self.push(buffer.slice(0, buffer._index));\n      } // Finished reading\n\n\n      if (self.totalBytesToRead <= 0) {\n        self.endCalled = true;\n      }\n    });\n  }; // Set read length\n\n\n  var length = self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;\n\n  if (!self.gs.isOpen) {\n    self.gs.open(function (err) {\n      self.totalBytesToRead = self.gs.length - self.gs.position;\n      if (err) return self.emit('error', err);\n      read();\n    });\n  } else {\n    read();\n  }\n};\n\nGridStoreStream.prototype.destroy = function () {\n  this.pause();\n  this.endCalled = true;\n  this.gs.close();\n  this.emit('end');\n};\n\nGridStoreStream.prototype.write = function (chunk) {\n  var self = this;\n  if (self.endCalled) return self.emit('error', MongoError.create({\n    message: 'attempting to write to stream after end called',\n    driver: true\n  })); // Do we have to open the gridstore\n\n  if (!self.gs.isOpen) {\n    self.gs.open(function () {\n      self.gs.isOpen = true;\n      self.gs.write(chunk, function () {\n        process.nextTick(function () {\n          self.emit('drain');\n        });\n      });\n    });\n    return false;\n  } else {\n    self.gs.write(chunk, function () {\n      self.emit('drain');\n    });\n    return true;\n  }\n};\n\nGridStoreStream.prototype.end = function (chunk, encoding, callback) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 0);\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\n  chunk = args.length ? args.shift() : null;\n  encoding = args.length ? args.shift() : null;\n  self.endCalled = true;\n\n  if (chunk) {\n    self.gs.write(chunk, function () {\n      self.gs.close(function () {\n        if (typeof callback === 'function') callback();\n        self.emit('end');\n      });\n    });\n  }\n\n  self.gs.close(function () {\n    if (typeof callback === 'function') callback();\n    self.emit('end');\n  });\n};\n/**\r\n * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.\r\n * @function external:Duplex#read\r\n * @param {number} size Optional argument to specify how much data to read.\r\n * @return {(String | Buffer | null)}\r\n */\n\n/**\r\n * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.\r\n * @function external:Duplex#setEncoding\r\n * @param {string} encoding The encoding to use.\r\n * @return {null}\r\n */\n\n/**\r\n * This method will cause the readable stream to resume emitting data events.\r\n * @function external:Duplex#resume\r\n * @return {null}\r\n */\n\n/**\r\n * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\r\n * @function external:Duplex#pause\r\n * @return {null}\r\n */\n\n/**\r\n * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\r\n * @function external:Duplex#pipe\r\n * @param {Writable} destination The destination for writing data\r\n * @param {object} [options] Pipe options\r\n * @return {null}\r\n */\n\n/**\r\n * This method will remove the hooks set up for a previous pipe() call.\r\n * @function external:Duplex#unpipe\r\n * @param {Writable} [destination] The destination for writing data\r\n * @return {null}\r\n */\n\n/**\r\n * This is useful in certain cases where a stream is being consumed by a parser, which needs to \"un-consume\" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.\r\n * @function external:Duplex#unshift\r\n * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.\r\n * @return {null}\r\n */\n\n/**\r\n * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See \"Compatibility\" below for more information.)\r\n * @function external:Duplex#wrap\r\n * @param {Stream} stream An \"old style\" readable stream.\r\n * @return {null}\r\n */\n\n/**\r\n * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.\r\n * @function external:Duplex#write\r\n * @param {(string|Buffer)} chunk The data to write\r\n * @param {string} encoding The encoding, if chunk is a String\r\n * @param {function} callback Callback for when this chunk of data is flushed\r\n * @return {boolean}\r\n */\n\n/**\r\n * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.\r\n * @function external:Duplex#end\r\n * @param {(string|Buffer)} chunk The data to write\r\n * @param {string} encoding The encoding, if chunk is a String\r\n * @param {function} callback Callback for when this chunk of data is flushed\r\n * @return {null}\r\n */\n\n/**\r\n * GridStoreStream stream data event, fired for each document in the cursor.\r\n *\r\n * @event GridStoreStream#data\r\n * @type {object}\r\n */\n\n/**\r\n * GridStoreStream stream end event\r\n *\r\n * @event GridStoreStream#end\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream close event\r\n *\r\n * @event GridStoreStream#close\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream readable event\r\n *\r\n * @event GridStoreStream#readable\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream drain event\r\n *\r\n * @event GridStoreStream#drain\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream finish event\r\n *\r\n * @event GridStoreStream#finish\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream pipe event\r\n *\r\n * @event GridStoreStream#pipe\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream unpipe event\r\n *\r\n * @event GridStoreStream#unpipe\r\n * @type {null}\r\n */\n\n/**\r\n * GridStoreStream stream error event\r\n *\r\n * @event GridStoreStream#error\r\n * @type {null}\r\n */\n\n/**\r\n * @ignore\r\n */\n\n\nmodule.exports = GridStore;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/gridfs/grid_store.js"],"names":["Chunk","require","ObjectID","BSON","ReadPreference","Buffer","fs","f","format","util","MongoError","inherits","Duplex","shallowClone","executeLegacyOperation","deprecate","REFERENCE_BY_FILENAME","REFERENCE_BY_ID","deprecationFn","GridStore","db","id","filename","mode","options","undefined","_bsontype","referenceBy","fileId","indexOf","isOpen","root","DEFAULT_ROOT_COLLECTION","position","readPreference","primary","writeConcern","_getWriteConcern","internalChunkSize","DEFAULT_CHUNK_SIZE","promiseLibrary","Promise","Object","defineProperty","enumerable","get","set","value","uploadDate","internalMd5","currentChunk","chunkNumber","prototype","open","callback","create","message","driver","s","topology","skipSessions","self","collection","ensureIndex","chunkCollection","chunkIndexOptions","unique","_open","err","r","eof","length","getc","nthChunk","chunk","puts","string","finalString","match","write","bind","stream","GridStoreStream","data","close","_writeNormal","destroy","writable","readable","_q","emit","writeFile","file","fd","fstat","stats","offset","index","writeChunk","_buffer","alloc","chunkSize","read","bytesRead","n","slice","save","size","process","nextTick","assign","files","buildMongoObject","mongoObject","Date","unlink","deleteChunks","remove","_id","readlines","separator","args","Array","call","arguments","pop","shift","items","toString","split","splice","i","rewind","buffer","finalLength","finalBuffer","_index","readSlice","copy","tell","resolve","seek","seekLocation","seekLocationFinal","IO_SEEK_SET","finalPosition","targetPosition","IO_SEEK_CUR","IO_SEEK_END","newChunkNumber","Math","floor","seekChunk","Error","query","findOne","doc","error","contentType","aliases","metadata","md5","DEFAULT_CONTENT_TYPE","txtId","toHexString","lastChunkNumber","writeBuffer","finalClose","previousChunkNumber","leftOverDataSize","firstChunkData","leftOverData","chunksToWrite","newChunk","push","numberOfChunksToWrite","md5Command","filemd5","command","results","files_id","finalChunk","exist","fileIdObject","rootCollection","exists","PRIMARY","rootCollectionFinal","item","list","byId","find","cursor","each","name","readStatic","gridStore","readlinesStatic","finalSeperator","names","unlinkStatic","constructor","tc","isBuffer","from","_setWriteConcernHash","baseOptions","finalOptions","w","journal","j","fsync","wtimeout","safe","gs","endCalled","totalBytesToRead","seekPosition","_pipe","pipe","destination","apply","_read","pause","end","encoding","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * @fileOverview GridFS is a tool for MongoDB to store files to the database.\r\n * Because of the restrictions of the object size the database can hold, a\r\n * facility to split a file into several chunks is needed. The {@link GridStore}\r\n * class offers a simplified api to interact with files while managing the\r\n * chunks of split files behind the scenes. More information about GridFS can be\r\n * found <a href=\"http://www.mongodb.org/display/DOCS/GridFS\">here</a>.\r\n *\r\n * @example\r\n * const MongoClient = require('mongodb').MongoClient;\r\n * const GridStore = require('mongodb').GridStore;\r\n * const ObjectID = require('mongodb').ObjectID;\r\n * const test = require('assert');\r\n * // Connection url\r\n * const url = 'mongodb://localhost:27017';\r\n * // Database Name\r\n * const dbName = 'test';\r\n * // Connect using MongoClient\r\n * MongoClient.connect(url, function(err, client) {\r\n *   const db = client.db(dbName);\r\n *   const gridStore = new GridStore(db, null, \"w\");\r\n *   gridStore.open(function(err, gridStore) {\r\n *     gridStore.write(\"hello world!\", function(err, gridStore) {\r\n *       gridStore.close(function(err, result) {\r\n *         // Let's read the file using object Id\r\n *         GridStore.read(db, result._id, function(err, data) {\r\n *           test.equal('hello world!', data);\r\n *           client.close();\r\n *           test.done();\r\n *         });\r\n *       });\r\n *     });\r\n *   });\r\n * });\r\n */\r\nconst Chunk = require('./chunk');\r\nconst ObjectID = require('../core').BSON.ObjectID;\r\nconst ReadPreference = require('../core').ReadPreference;\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst fs = require('fs');\r\nconst f = require('util').format;\r\nconst util = require('util');\r\nconst MongoError = require('../core').MongoError;\r\nconst inherits = util.inherits;\r\nconst Duplex = require('stream').Duplex;\r\nconst shallowClone = require('../utils').shallowClone;\r\nconst executeLegacyOperation = require('../utils').executeLegacyOperation;\r\nconst deprecate = require('util').deprecate;\r\n\r\nvar REFERENCE_BY_FILENAME = 0,\r\n  REFERENCE_BY_ID = 1;\r\n\r\nconst deprecationFn = deprecate(() => {},\r\n'GridStore is deprecated, and will be removed in a future version. Please use GridFSBucket instead');\r\n\r\n/**\r\n * Namespace provided by the core module\r\n * @external Duplex\r\n */\r\n\r\n/**\r\n * Create a new GridStore instance\r\n *\r\n * Modes\r\n *  - **\"r\"** - read only. This is the default mode.\r\n *  - **\"w\"** - write in truncate mode. Existing data will be overwritten.\r\n *\r\n * @class\r\n * @param {Db} db A database instance to interact with.\r\n * @param {object} [id] optional unique id for this file\r\n * @param {string} [filename] optional filename for this file, no unique constrain on the field\r\n * @param {string} mode set the mode for this file.\r\n * @param {object} [options] Optional settings.\r\n * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\r\n * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\r\n * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\r\n * @param {boolean} [options.fsync=false] **Deprecated** Specify a file sync write concern. Use writeConcern instead.\r\n * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\r\n * @param {string} [options.root] Root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {string} [options.content_type] MIME type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.\r\n * @param {number} [options.chunk_size=261120] Size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.\r\n * @param {object} [options.metadata] Arbitrary data the user wants to store.\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @property {number} chunkSize Get the gridstore chunk size.\r\n * @property {number} md5 The md5 checksum for this file.\r\n * @property {number} chunkNumber The current chunk number the gridstore has materialized into memory\r\n * @return {GridStore} a GridStore instance.\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nvar GridStore = function GridStore(db, id, filename, mode, options) {\r\n  deprecationFn();\r\n  if (!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);\r\n  this.db = db;\r\n\r\n  // Handle options\r\n  if (typeof options === 'undefined') options = {};\r\n  // Handle mode\r\n  if (typeof mode === 'undefined') {\r\n    mode = filename;\r\n    filename = undefined;\r\n  } else if (typeof mode === 'object') {\r\n    options = mode;\r\n    mode = filename;\r\n    filename = undefined;\r\n  }\r\n\r\n  if (id && id._bsontype === 'ObjectID') {\r\n    this.referenceBy = REFERENCE_BY_ID;\r\n    this.fileId = id;\r\n    this.filename = filename;\r\n  } else if (typeof filename === 'undefined') {\r\n    this.referenceBy = REFERENCE_BY_FILENAME;\r\n    this.filename = id;\r\n    if (mode.indexOf('w') != null) {\r\n      this.fileId = new ObjectID();\r\n    }\r\n  } else {\r\n    this.referenceBy = REFERENCE_BY_ID;\r\n    this.fileId = id;\r\n    this.filename = filename;\r\n  }\r\n\r\n  // Set up the rest\r\n  this.mode = mode == null ? 'r' : mode;\r\n  this.options = options || {};\r\n\r\n  // Opened\r\n  this.isOpen = false;\r\n\r\n  // Set the root if overridden\r\n  this.root =\r\n    this.options['root'] == null ? GridStore.DEFAULT_ROOT_COLLECTION : this.options['root'];\r\n  this.position = 0;\r\n  this.readPreference =\r\n    this.options.readPreference || db.options.readPreference || ReadPreference.primary;\r\n  this.writeConcern = _getWriteConcern(db, this.options);\r\n  // Set default chunk size\r\n  this.internalChunkSize =\r\n    this.options['chunkSize'] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options['chunkSize'];\r\n\r\n  // Get the promiseLibrary\r\n  var promiseLibrary = this.options.promiseLibrary || Promise;\r\n\r\n  // Set the promiseLibrary\r\n  this.promiseLibrary = promiseLibrary;\r\n\r\n  Object.defineProperty(this, 'chunkSize', {\r\n    enumerable: true,\r\n    get: function() {\r\n      return this.internalChunkSize;\r\n    },\r\n    set: function(value) {\r\n      if (!(this.mode[0] === 'w' && this.position === 0 && this.uploadDate == null)) {\r\n        // eslint-disable-next-line no-self-assign\r\n        this.internalChunkSize = this.internalChunkSize;\r\n      } else {\r\n        this.internalChunkSize = value;\r\n      }\r\n    }\r\n  });\r\n\r\n  Object.defineProperty(this, 'md5', {\r\n    enumerable: true,\r\n    get: function() {\r\n      return this.internalMd5;\r\n    }\r\n  });\r\n\r\n  Object.defineProperty(this, 'chunkNumber', {\r\n    enumerable: true,\r\n    get: function() {\r\n      return this.currentChunk && this.currentChunk.chunkNumber\r\n        ? this.currentChunk.chunkNumber\r\n        : null;\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * The callback format for the Gridstore.open method\r\n * @callback GridStore~openCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {GridStore} gridStore The GridStore instance if the open method was successful.\r\n */\r\n\r\n/**\r\n * Opens the file from the database and initialize this object. Also creates a\r\n * new one if file does not exist.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~openCallback} [callback] this will be called after executing this method\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.open = function(options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  if (this.mode !== 'w' && this.mode !== 'w+' && this.mode !== 'r') {\r\n    throw MongoError.create({ message: 'Illegal mode ' + this.mode, driver: true });\r\n  }\r\n\r\n  return executeLegacyOperation(this.db.s.topology, open, [this, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar open = function(self, options, callback) {\r\n  // Get the write concern\r\n  var writeConcern = _getWriteConcern(self.db, self.options);\r\n\r\n  // If we are writing we need to ensure we have the right indexes for md5's\r\n  if (self.mode === 'w' || self.mode === 'w+') {\r\n    // Get files collection\r\n    var collection = self.collection();\r\n    // Put index on filename\r\n    collection.ensureIndex([['filename', 1]], writeConcern, function() {\r\n      // Get chunk collection\r\n      var chunkCollection = self.chunkCollection();\r\n      // Make an unique index for compatibility with mongo-cxx-driver:legacy\r\n      var chunkIndexOptions = shallowClone(writeConcern);\r\n      chunkIndexOptions.unique = true;\r\n      // Ensure index on chunk collection\r\n      chunkCollection.ensureIndex(\r\n        [\r\n          ['files_id', 1],\r\n          ['n', 1]\r\n        ],\r\n        chunkIndexOptions,\r\n        function() {\r\n          // Open the connection\r\n          _open(self, writeConcern, function(err, r) {\r\n            if (err) return callback(err);\r\n            self.isOpen = true;\r\n            callback(err, r);\r\n          });\r\n        }\r\n      );\r\n    });\r\n  } else {\r\n    // Open the gridstore\r\n    _open(self, writeConcern, function(err, r) {\r\n      if (err) return callback(err);\r\n      self.isOpen = true;\r\n      callback(err, r);\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Verify if the file is at EOF.\r\n *\r\n * @method\r\n * @return {boolean} true if the read/write head is at the end of this file.\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.eof = function() {\r\n  return this.position === this.length ? true : false;\r\n};\r\n\r\n/**\r\n * The callback result format.\r\n * @callback GridStore~resultCallback\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {object} result The result from the callback.\r\n */\r\n\r\n/**\r\n * Retrieves a single character from this file.\r\n *\r\n * @method\r\n * @param {GridStore~resultCallback} [callback] this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.getc = function(options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(this.db.s.topology, getc, [this, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar getc = function(self, options, callback) {\r\n  if (self.eof()) {\r\n    callback(null, null);\r\n  } else if (self.currentChunk.eof()) {\r\n    nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {\r\n      self.currentChunk = chunk;\r\n      self.position = self.position + 1;\r\n      callback(err, self.currentChunk.getc());\r\n    });\r\n  } else {\r\n    self.position = self.position + 1;\r\n    callback(null, self.currentChunk.getc());\r\n  }\r\n};\r\n\r\n/**\r\n * Writes a string to the file with a newline character appended at the end if\r\n * the given string does not have one.\r\n *\r\n * @method\r\n * @param {string} string the string to write.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.puts = function(string, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  var finalString = string.match(/\\n$/) == null ? string + '\\n' : string;\r\n  return executeLegacyOperation(\r\n    this.db.s.topology,\r\n    this.write.bind(this),\r\n    [finalString, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\n/**\r\n * Return a modified Readable stream including a possible transform method.\r\n *\r\n * @method\r\n * @return {GridStoreStream}\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.stream = function() {\r\n  return new GridStoreStream(this);\r\n};\r\n\r\n/**\r\n * Writes some data. This method will work properly only if initialized with mode \"w\" or \"w+\".\r\n *\r\n * @method\r\n * @param {(string|Buffer)} data the data to write.\r\n * @param {boolean} [close] closes this file after writing if set to true.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.write = function write(data, close, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(\r\n    this.db.s.topology,\r\n    _writeNormal,\r\n    [this, data, close, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\n/**\r\n * Handles the destroy part of a stream\r\n *\r\n * @method\r\n * @result {null}\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.destroy = function destroy() {\r\n  // close and do not emit any more events. queued data is not sent.\r\n  if (!this.writable) return;\r\n  this.readable = false;\r\n  if (this.writable) {\r\n    this.writable = false;\r\n    this._q.length = 0;\r\n    this.emit('close');\r\n  }\r\n};\r\n\r\n/**\r\n * Stores a file from the file system to the GridFS database.\r\n *\r\n * @method\r\n * @param {(string|Buffer|FileHandle)} file the file to store.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.writeFile = function(file, options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(this.db.s.topology, writeFile, [this, file, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar writeFile = function(self, file, options, callback) {\r\n  if (typeof file === 'string') {\r\n    fs.open(file, 'r', function(err, fd) {\r\n      if (err) return callback(err);\r\n      self.writeFile(fd, callback);\r\n    });\r\n    return;\r\n  }\r\n\r\n  self.open(function(err, self) {\r\n    if (err) return callback(err, self);\r\n\r\n    fs.fstat(file, function(err, stats) {\r\n      if (err) return callback(err, self);\r\n\r\n      var offset = 0;\r\n      var index = 0;\r\n\r\n      // Write a chunk\r\n      var writeChunk = function() {\r\n        // Allocate the buffer\r\n        var _buffer = Buffer.alloc(self.chunkSize);\r\n        // Read the file\r\n        fs.read(file, _buffer, 0, _buffer.length, offset, function(err, bytesRead, data) {\r\n          if (err) return callback(err, self);\r\n\r\n          offset = offset + bytesRead;\r\n\r\n          // Create a new chunk for the data\r\n          var chunk = new Chunk(self, { n: index++ }, self.writeConcern);\r\n          chunk.write(data.slice(0, bytesRead), function(err, chunk) {\r\n            if (err) return callback(err, self);\r\n\r\n            chunk.save({}, function(err) {\r\n              if (err) return callback(err, self);\r\n\r\n              self.position = self.position + bytesRead;\r\n\r\n              // Point to current chunk\r\n              self.currentChunk = chunk;\r\n\r\n              if (offset >= stats.size) {\r\n                fs.close(file, function(err) {\r\n                  if (err) return callback(err);\r\n\r\n                  self.close(function(err) {\r\n                    if (err) return callback(err, self);\r\n                    return callback(null, self);\r\n                  });\r\n                });\r\n              } else {\r\n                return process.nextTick(writeChunk);\r\n              }\r\n            });\r\n          });\r\n        });\r\n      };\r\n\r\n      // Process the first write\r\n      process.nextTick(writeChunk);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Saves this file to the database. This will overwrite the old entry if it\r\n * already exists. This will work properly only if mode was initialized to\r\n * \"w\" or \"w+\".\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.close = function(options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(this.db.s.topology, close, [this, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar close = function(self, options, callback) {\r\n  if (self.mode[0] === 'w') {\r\n    // Set up options\r\n    options = Object.assign({}, self.writeConcern, options);\r\n\r\n    if (self.currentChunk != null && self.currentChunk.position > 0) {\r\n      self.currentChunk.save({}, function(err) {\r\n        if (err && typeof callback === 'function') return callback(err);\r\n\r\n        self.collection(function(err, files) {\r\n          if (err && typeof callback === 'function') return callback(err);\r\n\r\n          // Build the mongo object\r\n          if (self.uploadDate != null) {\r\n            buildMongoObject(self, function(err, mongoObject) {\r\n              if (err) {\r\n                if (typeof callback === 'function') return callback(err);\r\n                else throw err;\r\n              }\r\n\r\n              files.save(mongoObject, options, function(err) {\r\n                if (typeof callback === 'function') callback(err, mongoObject);\r\n              });\r\n            });\r\n          } else {\r\n            self.uploadDate = new Date();\r\n            buildMongoObject(self, function(err, mongoObject) {\r\n              if (err) {\r\n                if (typeof callback === 'function') return callback(err);\r\n                else throw err;\r\n              }\r\n\r\n              files.save(mongoObject, options, function(err) {\r\n                if (typeof callback === 'function') callback(err, mongoObject);\r\n              });\r\n            });\r\n          }\r\n        });\r\n      });\r\n    } else {\r\n      self.collection(function(err, files) {\r\n        if (err && typeof callback === 'function') return callback(err);\r\n\r\n        self.uploadDate = new Date();\r\n        buildMongoObject(self, function(err, mongoObject) {\r\n          if (err) {\r\n            if (typeof callback === 'function') return callback(err);\r\n            else throw err;\r\n          }\r\n\r\n          files.save(mongoObject, options, function(err) {\r\n            if (typeof callback === 'function') callback(err, mongoObject);\r\n          });\r\n        });\r\n      });\r\n    }\r\n  } else if (self.mode[0] === 'r') {\r\n    if (typeof callback === 'function') callback(null, null);\r\n  } else {\r\n    if (typeof callback === 'function')\r\n      callback(MongoError.create({ message: f('Illegal mode %s', self.mode), driver: true }));\r\n  }\r\n};\r\n\r\n/**\r\n * The collection callback format.\r\n * @callback GridStore~collectionCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {Collection} collection The collection from the command execution.\r\n */\r\n\r\n/**\r\n * Retrieve this file's chunks collection.\r\n *\r\n * @method\r\n * @param {GridStore~collectionCallback} callback the command callback.\r\n * @return {Collection}\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.chunkCollection = function(callback) {\r\n  if (typeof callback === 'function') return this.db.collection(this.root + '.chunks', callback);\r\n  return this.db.collection(this.root + '.chunks');\r\n};\r\n\r\n/**\r\n * Deletes all the chunks of this file in the database.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.unlink = function(options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(this.db.s.topology, unlink, [this, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar unlink = function(self, options, callback) {\r\n  deleteChunks(self, function(err) {\r\n    if (err !== null) {\r\n      err.message = 'at deleteChunks: ' + err.message;\r\n      return callback(err);\r\n    }\r\n\r\n    self.collection(function(err, collection) {\r\n      if (err !== null) {\r\n        err.message = 'at collection: ' + err.message;\r\n        return callback(err);\r\n      }\r\n\r\n      collection.remove({ _id: self.fileId }, self.writeConcern, function(err) {\r\n        callback(err, self);\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Retrieves the file collection associated with this object.\r\n *\r\n * @method\r\n * @param {GridStore~collectionCallback} callback the command callback.\r\n * @return {Collection}\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.collection = function(callback) {\r\n  if (typeof callback === 'function') this.db.collection(this.root + '.files', callback);\r\n  return this.db.collection(this.root + '.files');\r\n};\r\n\r\n/**\r\n * The readlines callback format.\r\n * @callback GridStore~readlinesCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {string[]} strings The array of strings returned.\r\n */\r\n\r\n/**\r\n * Read the entire file as a list of strings splitting by the provided separator.\r\n *\r\n * @method\r\n * @param {string} [separator] The character to be recognized as the newline separator.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readlinesCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.readlines = function(separator, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 0);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  separator = args.length ? args.shift() : '\\n';\r\n  separator = separator || '\\n';\r\n  options = args.length ? args.shift() : {};\r\n\r\n  return executeLegacyOperation(\r\n    this.db.s.topology,\r\n    readlines,\r\n    [this, separator, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar readlines = function(self, separator, options, callback) {\r\n  self.read(function(err, data) {\r\n    if (err) return callback(err);\r\n\r\n    var items = data.toString().split(separator);\r\n    items = items.length > 0 ? items.splice(0, items.length - 1) : [];\r\n    for (var i = 0; i < items.length; i++) {\r\n      items[i] = items[i] + separator;\r\n    }\r\n\r\n    callback(null, items);\r\n  });\r\n};\r\n\r\n/**\r\n * Deletes all the chunks of this file in the database if mode was set to \"w\" or\r\n * \"w+\" and resets the read/write head to the initial position.\r\n *\r\n * @method\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.rewind = function(options, callback) {\r\n  if (typeof options === 'function') (callback = options), (options = {});\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(this.db.s.topology, rewind, [this, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar rewind = function(self, options, callback) {\r\n  if (self.currentChunk.chunkNumber !== 0) {\r\n    if (self.mode[0] === 'w') {\r\n      deleteChunks(self, function(err) {\r\n        if (err) return callback(err);\r\n        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);\r\n        self.position = 0;\r\n        callback(null, self);\r\n      });\r\n    } else {\r\n      self.currentChunk(0, function(err, chunk) {\r\n        if (err) return callback(err);\r\n        self.currentChunk = chunk;\r\n        self.currentChunk.rewind();\r\n        self.position = 0;\r\n        callback(null, self);\r\n      });\r\n    }\r\n  } else {\r\n    self.currentChunk.rewind();\r\n    self.position = 0;\r\n    callback(null, self);\r\n  }\r\n};\r\n\r\n/**\r\n * The read callback format.\r\n * @callback GridStore~readCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {Buffer} data The data read from the GridStore object\r\n */\r\n\r\n/**\r\n * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.\r\n *\r\n * There are 3 signatures for this method:\r\n *\r\n * (callback)\r\n * (length, callback)\r\n * (length, buffer, callback)\r\n *\r\n * @method\r\n * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.\r\n * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.read = function(length, buffer, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 0);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  length = args.length ? args.shift() : null;\r\n  buffer = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : {};\r\n\r\n  return executeLegacyOperation(\r\n    this.db.s.topology,\r\n    read,\r\n    [this, length, buffer, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar read = function(self, length, buffer, options, callback) {\r\n  // The data is a c-terminated string and thus the length - 1\r\n  var finalLength = length == null ? self.length - self.position : length;\r\n  var finalBuffer = buffer == null ? Buffer.alloc(finalLength) : buffer;\r\n  // Add a index to buffer to keep track of writing position or apply current index\r\n  finalBuffer._index = buffer != null && buffer._index != null ? buffer._index : 0;\r\n\r\n  if (self.currentChunk.length() - self.currentChunk.position + finalBuffer._index >= finalLength) {\r\n    var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);\r\n    // Copy content to final buffer\r\n    slice.copy(finalBuffer, finalBuffer._index);\r\n    // Update internal position\r\n    self.position = self.position + finalBuffer.length;\r\n    // Check if we don't have a file at all\r\n    if (finalLength === 0 && finalBuffer.length === 0)\r\n      return callback(MongoError.create({ message: 'File does not exist', driver: true }), null);\r\n    // Else return data\r\n    return callback(null, finalBuffer);\r\n  }\r\n\r\n  // Read the next chunk\r\n  slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);\r\n  // Copy content to final buffer\r\n  slice.copy(finalBuffer, finalBuffer._index);\r\n  // Update index position\r\n  finalBuffer._index += slice.length;\r\n\r\n  // Load next chunk and read more\r\n  nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {\r\n    if (err) return callback(err);\r\n\r\n    if (chunk.length() > 0) {\r\n      self.currentChunk = chunk;\r\n      self.read(length, finalBuffer, callback);\r\n    } else {\r\n      if (finalBuffer._index > 0) {\r\n        callback(null, finalBuffer);\r\n      } else {\r\n        callback(\r\n          MongoError.create({\r\n            message: 'no chunks found for file, possibly corrupt',\r\n            driver: true\r\n          }),\r\n          null\r\n        );\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * The tell callback format.\r\n * @callback GridStore~tellCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {number} position The current read position in the GridStore.\r\n */\r\n\r\n/**\r\n * Retrieves the position of the read/write head of this file.\r\n *\r\n * @method\r\n * @param {number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.\r\n * @param {(string|Buffer)} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~tellCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.tell = function(callback) {\r\n  var self = this;\r\n  // We provided a callback leg\r\n  if (typeof callback === 'function') return callback(null, this.position);\r\n  // Return promise\r\n  return new self.promiseLibrary(function(resolve) {\r\n    resolve(self.position);\r\n  });\r\n};\r\n\r\n/**\r\n * The tell callback format.\r\n * @callback GridStore~gridStoreCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {GridStore} gridStore The gridStore.\r\n */\r\n\r\n/**\r\n * Moves the read/write head to a new location.\r\n *\r\n * There are 3 signatures for this method\r\n *\r\n * Seek Location Modes\r\n *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.\r\n *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.\r\n *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.\r\n *\r\n * @method\r\n * @param {number} [position] the position to seek to\r\n * @param {number} [seekLocation] seek mode. Use one of the Seek Location modes.\r\n * @param {object} [options] Optional settings\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~gridStoreCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.prototype.seek = function(position, seekLocation, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  seekLocation = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : {};\r\n\r\n  return executeLegacyOperation(\r\n    this.db.s.topology,\r\n    seek,\r\n    [this, position, seekLocation, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar seek = function(self, position, seekLocation, options, callback) {\r\n  // Seek only supports read mode\r\n  if (self.mode !== 'r') {\r\n    return callback(\r\n      MongoError.create({ message: 'seek is only supported for mode r', driver: true })\r\n    );\r\n  }\r\n\r\n  var seekLocationFinal = seekLocation == null ? GridStore.IO_SEEK_SET : seekLocation;\r\n  var finalPosition = position;\r\n  var targetPosition = 0;\r\n\r\n  // Calculate the position\r\n  if (seekLocationFinal === GridStore.IO_SEEK_CUR) {\r\n    targetPosition = self.position + finalPosition;\r\n  } else if (seekLocationFinal === GridStore.IO_SEEK_END) {\r\n    targetPosition = self.length + finalPosition;\r\n  } else {\r\n    targetPosition = finalPosition;\r\n  }\r\n\r\n  // Get the chunk\r\n  var newChunkNumber = Math.floor(targetPosition / self.chunkSize);\r\n  var seekChunk = function() {\r\n    nthChunk(self, newChunkNumber, function(err, chunk) {\r\n      if (err) return callback(err, null);\r\n      if (chunk == null) return callback(new Error('no chunk found'));\r\n\r\n      // Set the current chunk\r\n      self.currentChunk = chunk;\r\n      self.position = targetPosition;\r\n      self.currentChunk.position = self.position % self.chunkSize;\r\n      callback(err, self);\r\n    });\r\n  };\r\n\r\n  seekChunk();\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar _open = function(self, options, callback) {\r\n  var collection = self.collection();\r\n  // Create the query\r\n  var query =\r\n    self.referenceBy === REFERENCE_BY_ID ? { _id: self.fileId } : { filename: self.filename };\r\n  query = null == self.fileId && self.filename == null ? null : query;\r\n  options.readPreference = self.readPreference;\r\n\r\n  // Fetch the chunks\r\n  if (query != null) {\r\n    collection.findOne(query, options, function(err, doc) {\r\n      if (err) {\r\n        return error(err);\r\n      }\r\n\r\n      // Check if the collection for the files exists otherwise prepare the new one\r\n      if (doc != null) {\r\n        self.fileId = doc._id;\r\n        // Prefer a new filename over the existing one if this is a write\r\n        self.filename =\r\n          self.mode === 'r' || self.filename === undefined ? doc.filename : self.filename;\r\n        self.contentType = doc.contentType;\r\n        self.internalChunkSize = doc.chunkSize;\r\n        self.uploadDate = doc.uploadDate;\r\n        self.aliases = doc.aliases;\r\n        self.length = doc.length;\r\n        self.metadata = doc.metadata;\r\n        self.internalMd5 = doc.md5;\r\n      } else if (self.mode !== 'r') {\r\n        self.fileId = self.fileId == null ? new ObjectID() : self.fileId;\r\n        self.contentType = GridStore.DEFAULT_CONTENT_TYPE;\r\n        self.internalChunkSize =\r\n          self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;\r\n        self.length = 0;\r\n      } else {\r\n        self.length = 0;\r\n        var txtId = self.fileId._bsontype === 'ObjectID' ? self.fileId.toHexString() : self.fileId;\r\n        return error(\r\n          MongoError.create({\r\n            message: f(\r\n              'file with id %s not opened for writing',\r\n              self.referenceBy === REFERENCE_BY_ID ? txtId : self.filename\r\n            ),\r\n            driver: true\r\n          }),\r\n          self\r\n        );\r\n      }\r\n\r\n      // Process the mode of the object\r\n      if (self.mode === 'r') {\r\n        nthChunk(self, 0, options, function(err, chunk) {\r\n          if (err) return error(err);\r\n          self.currentChunk = chunk;\r\n          self.position = 0;\r\n          callback(null, self);\r\n        });\r\n      } else if (self.mode === 'w' && doc) {\r\n        // Delete any existing chunks\r\n        deleteChunks(self, options, function(err) {\r\n          if (err) return error(err);\r\n          self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);\r\n          self.contentType =\r\n            self.options['content_type'] == null ? self.contentType : self.options['content_type'];\r\n          self.internalChunkSize =\r\n            self.options['chunk_size'] == null\r\n              ? self.internalChunkSize\r\n              : self.options['chunk_size'];\r\n          self.metadata =\r\n            self.options['metadata'] == null ? self.metadata : self.options['metadata'];\r\n          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\r\n          self.position = 0;\r\n          callback(null, self);\r\n        });\r\n      } else if (self.mode === 'w') {\r\n        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);\r\n        self.contentType =\r\n          self.options['content_type'] == null ? self.contentType : self.options['content_type'];\r\n        self.internalChunkSize =\r\n          self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];\r\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\r\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\r\n        self.position = 0;\r\n        callback(null, self);\r\n      } else if (self.mode === 'w+') {\r\n        nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {\r\n          if (err) return error(err);\r\n          // Set the current chunk\r\n          self.currentChunk = chunk == null ? new Chunk(self, { n: 0 }, self.writeConcern) : chunk;\r\n          self.currentChunk.position = self.currentChunk.data.length();\r\n          self.metadata =\r\n            self.options['metadata'] == null ? self.metadata : self.options['metadata'];\r\n          self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\r\n          self.position = self.length;\r\n          callback(null, self);\r\n        });\r\n      }\r\n    });\r\n  } else {\r\n    // Write only mode\r\n    self.fileId = null == self.fileId ? new ObjectID() : self.fileId;\r\n    self.contentType = GridStore.DEFAULT_CONTENT_TYPE;\r\n    self.internalChunkSize =\r\n      self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;\r\n    self.length = 0;\r\n\r\n    // No file exists set up write mode\r\n    if (self.mode === 'w') {\r\n      // Delete any existing chunks\r\n      deleteChunks(self, options, function(err) {\r\n        if (err) return error(err);\r\n        self.currentChunk = new Chunk(self, { n: 0 }, self.writeConcern);\r\n        self.contentType =\r\n          self.options['content_type'] == null ? self.contentType : self.options['content_type'];\r\n        self.internalChunkSize =\r\n          self.options['chunk_size'] == null ? self.internalChunkSize : self.options['chunk_size'];\r\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\r\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\r\n        self.position = 0;\r\n        callback(null, self);\r\n      });\r\n    } else if (self.mode === 'w+') {\r\n      nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {\r\n        if (err) return error(err);\r\n        // Set the current chunk\r\n        self.currentChunk = chunk == null ? new Chunk(self, { n: 0 }, self.writeConcern) : chunk;\r\n        self.currentChunk.position = self.currentChunk.data.length();\r\n        self.metadata = self.options['metadata'] == null ? self.metadata : self.options['metadata'];\r\n        self.aliases = self.options['aliases'] == null ? self.aliases : self.options['aliases'];\r\n        self.position = self.length;\r\n        callback(null, self);\r\n      });\r\n    }\r\n  }\r\n\r\n  // only pass error to callback once\r\n  function error(err) {\r\n    if (error.err) return;\r\n    callback((error.err = err));\r\n  }\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar writeBuffer = function(self, buffer, close, callback) {\r\n  if (typeof close === 'function') {\r\n    callback = close;\r\n    close = null;\r\n  }\r\n  var finalClose = typeof close === 'boolean' ? close : false;\r\n\r\n  if (self.mode !== 'w') {\r\n    callback(\r\n      MongoError.create({\r\n        message: f(\r\n          'file with id %s not opened for writing',\r\n          self.referenceBy === REFERENCE_BY_ID ? self.referenceBy : self.filename\r\n        ),\r\n        driver: true\r\n      }),\r\n      null\r\n    );\r\n  } else {\r\n    if (self.currentChunk.position + buffer.length >= self.chunkSize) {\r\n      // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left\r\n      // to a new chunk (recursively)\r\n      var previousChunkNumber = self.currentChunk.chunkNumber;\r\n      var leftOverDataSize = self.chunkSize - self.currentChunk.position;\r\n      var firstChunkData = buffer.slice(0, leftOverDataSize);\r\n      var leftOverData = buffer.slice(leftOverDataSize);\r\n      // A list of chunks to write out\r\n      var chunksToWrite = [self.currentChunk.write(firstChunkData)];\r\n      // If we have more data left than the chunk size let's keep writing new chunks\r\n      while (leftOverData.length >= self.chunkSize) {\r\n        // Create a new chunk and write to it\r\n        var newChunk = new Chunk(self, { n: previousChunkNumber + 1 }, self.writeConcern);\r\n        firstChunkData = leftOverData.slice(0, self.chunkSize);\r\n        leftOverData = leftOverData.slice(self.chunkSize);\r\n        // Update chunk number\r\n        previousChunkNumber = previousChunkNumber + 1;\r\n        // Write data\r\n        newChunk.write(firstChunkData);\r\n        // Push chunk to save list\r\n        chunksToWrite.push(newChunk);\r\n      }\r\n\r\n      // Set current chunk with remaining data\r\n      self.currentChunk = new Chunk(self, { n: previousChunkNumber + 1 }, self.writeConcern);\r\n      // If we have left over data write it\r\n      if (leftOverData.length > 0) self.currentChunk.write(leftOverData);\r\n\r\n      // Update the position for the gridstore\r\n      self.position = self.position + buffer.length;\r\n      // Total number of chunks to write\r\n      var numberOfChunksToWrite = chunksToWrite.length;\r\n\r\n      for (var i = 0; i < chunksToWrite.length; i++) {\r\n        chunksToWrite[i].save({}, function(err) {\r\n          if (err) return callback(err);\r\n\r\n          numberOfChunksToWrite = numberOfChunksToWrite - 1;\r\n\r\n          if (numberOfChunksToWrite <= 0) {\r\n            // We care closing the file before returning\r\n            if (finalClose) {\r\n              return self.close(function(err) {\r\n                callback(err, self);\r\n              });\r\n            }\r\n\r\n            // Return normally\r\n            return callback(null, self);\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      // Update the position for the gridstore\r\n      self.position = self.position + buffer.length;\r\n      // We have less data than the chunk size just write it and callback\r\n      self.currentChunk.write(buffer);\r\n      // We care closing the file before returning\r\n      if (finalClose) {\r\n        return self.close(function(err) {\r\n          callback(err, self);\r\n        });\r\n      }\r\n      // Return normally\r\n      return callback(null, self);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Creates a mongoDB object representation of this object.\r\n *\r\n *        <pre><code>\r\n *        {\r\n *          '_id' : , // {number} id for this file\r\n *          'filename' : , // {string} name for this file\r\n *          'contentType' : , // {string} mime type for this file\r\n *          'length' : , // {number} size of this file?\r\n *          'chunksize' : , // {number} chunk size used by this file\r\n *          'uploadDate' : , // {Date}\r\n *          'aliases' : , // {array of string}\r\n *          'metadata' : , // {string}\r\n *        }\r\n *        </code></pre>\r\n *\r\n * @ignore\r\n */\r\nvar buildMongoObject = function(self, callback) {\r\n  // Calcuate the length\r\n  var mongoObject = {\r\n    _id: self.fileId,\r\n    filename: self.filename,\r\n    contentType: self.contentType,\r\n    length: self.position ? self.position : 0,\r\n    chunkSize: self.chunkSize,\r\n    uploadDate: self.uploadDate,\r\n    aliases: self.aliases,\r\n    metadata: self.metadata\r\n  };\r\n\r\n  var md5Command = { filemd5: self.fileId, root: self.root };\r\n  self.db.command(md5Command, function(err, results) {\r\n    if (err) return callback(err);\r\n\r\n    mongoObject.md5 = results.md5;\r\n    callback(null, mongoObject);\r\n  });\r\n};\r\n\r\n/**\r\n * Gets the nth chunk of this file.\r\n * @ignore\r\n */\r\nvar nthChunk = function(self, chunkNumber, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  options = options || self.writeConcern;\r\n  options.readPreference = self.readPreference;\r\n  // Get the nth chunk\r\n  self\r\n    .chunkCollection()\r\n    .findOne({ files_id: self.fileId, n: chunkNumber }, options, function(err, chunk) {\r\n      if (err) return callback(err);\r\n\r\n      var finalChunk = chunk == null ? {} : chunk;\r\n      callback(null, new Chunk(self, finalChunk, self.writeConcern));\r\n    });\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar lastChunkNumber = function(self) {\r\n  return Math.floor((self.length ? self.length - 1 : 0) / self.chunkSize);\r\n};\r\n\r\n/**\r\n * Deletes all the chunks of this file in the database.\r\n *\r\n * @ignore\r\n */\r\nvar deleteChunks = function(self, options, callback) {\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  options = options || self.writeConcern;\r\n\r\n  if (self.fileId != null) {\r\n    self.chunkCollection().remove({ files_id: self.fileId }, options, function(err) {\r\n      if (err) return callback(err, false);\r\n      callback(null, true);\r\n    });\r\n  } else {\r\n    callback(null, true);\r\n  }\r\n};\r\n\r\n/**\r\n * The collection to be used for holding the files and chunks collection.\r\n *\r\n * @classconstant DEFAULT_ROOT_COLLECTION\r\n */\r\nGridStore.DEFAULT_ROOT_COLLECTION = 'fs';\r\n\r\n/**\r\n * Default file mime type\r\n *\r\n * @classconstant DEFAULT_CONTENT_TYPE\r\n */\r\nGridStore.DEFAULT_CONTENT_TYPE = 'binary/octet-stream';\r\n\r\n/**\r\n * Seek mode where the given length is absolute.\r\n *\r\n * @classconstant IO_SEEK_SET\r\n */\r\nGridStore.IO_SEEK_SET = 0;\r\n\r\n/**\r\n * Seek mode where the given length is an offset to the current read/write head.\r\n *\r\n * @classconstant IO_SEEK_CUR\r\n */\r\nGridStore.IO_SEEK_CUR = 1;\r\n\r\n/**\r\n * Seek mode where the given length is an offset to the end of the file.\r\n *\r\n * @classconstant IO_SEEK_END\r\n */\r\nGridStore.IO_SEEK_END = 2;\r\n\r\n/**\r\n * Checks if a file exists in the database.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} name The name of the file to look for.\r\n * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] result from exists.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  rootCollection = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : {};\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(\r\n    db.s.topology,\r\n    exists,\r\n    [db, fileIdObject, rootCollection, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar exists = function(db, fileIdObject, rootCollection, options, callback) {\r\n  // Establish read preference\r\n  var readPreference = options.readPreference || ReadPreference.PRIMARY;\r\n  // Fetch collection\r\n  var rootCollectionFinal =\r\n    rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;\r\n  db.collection(rootCollectionFinal + '.files', function(err, collection) {\r\n    if (err) return callback(err);\r\n\r\n    // Build query\r\n    var query =\r\n      typeof fileIdObject === 'string' ||\r\n      Object.prototype.toString.call(fileIdObject) === '[object RegExp]'\r\n        ? { filename: fileIdObject }\r\n        : { _id: fileIdObject }; // Attempt to locate file\r\n\r\n    // We have a specific query\r\n    if (\r\n      fileIdObject != null &&\r\n      typeof fileIdObject === 'object' &&\r\n      Object.prototype.toString.call(fileIdObject) !== '[object RegExp]'\r\n    ) {\r\n      query = fileIdObject;\r\n    }\r\n\r\n    // Check if the entry exists\r\n    collection.findOne(query, { readPreference: readPreference }, function(err, item) {\r\n      if (err) return callback(err);\r\n      callback(null, item == null ? false : true);\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Gets the list of files stored in the GridFS.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} [rootCollection] The root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] result from exists.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.list = function(db, rootCollection, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 1);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  rootCollection = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : {};\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(db.s.topology, list, [db, rootCollection, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar list = function(db, rootCollection, options, callback) {\r\n  // Ensure we have correct values\r\n  if (rootCollection != null && typeof rootCollection === 'object') {\r\n    options = rootCollection;\r\n    rootCollection = null;\r\n  }\r\n\r\n  // Establish read preference\r\n  var readPreference = options.readPreference || ReadPreference.primary;\r\n  // Check if we are returning by id not filename\r\n  var byId = options['id'] != null ? options['id'] : false;\r\n  // Fetch item\r\n  var rootCollectionFinal =\r\n    rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;\r\n  var items = [];\r\n  db.collection(rootCollectionFinal + '.files', function(err, collection) {\r\n    if (err) return callback(err);\r\n\r\n    collection.find({}, { readPreference: readPreference }, function(err, cursor) {\r\n      if (err) return callback(err);\r\n\r\n      cursor.each(function(err, item) {\r\n        if (item != null) {\r\n          items.push(byId ? item._id : item.filename);\r\n        } else {\r\n          callback(err, items);\r\n        }\r\n      });\r\n    });\r\n  });\r\n};\r\n\r\n/**\r\n * Reads the contents of a file.\r\n *\r\n * This method has the following signatures\r\n *\r\n * (db, name, callback)\r\n * (db, name, length, callback)\r\n * (db, name, length, offset, callback)\r\n * (db, name, length, offset, options, callback)\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {string} name The name of the file.\r\n * @param {number} [length] The size of data to read.\r\n * @param {number} [offset] The offset from the head of the file of which to start reading from.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.read = function(db, name, length, offset, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  length = args.length ? args.shift() : null;\r\n  offset = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : null;\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(\r\n    db.s.topology,\r\n    readStatic,\r\n    [db, name, length, offset, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar readStatic = function(db, name, length, offset, options, callback) {\r\n  new GridStore(db, name, 'r', options).open(function(err, gridStore) {\r\n    if (err) return callback(err);\r\n    // Make sure we are not reading out of bounds\r\n    if (offset && offset >= gridStore.length)\r\n      return callback('offset larger than size of file', null);\r\n    if (length && length > gridStore.length)\r\n      return callback('length is larger than the size of the file', null);\r\n    if (offset && length && offset + length > gridStore.length)\r\n      return callback('offset and length is larger than the size of the file', null);\r\n\r\n    if (offset != null) {\r\n      gridStore.seek(offset, function(err, gridStore) {\r\n        if (err) return callback(err);\r\n        gridStore.read(length, callback);\r\n      });\r\n    } else {\r\n      gridStore.read(length, callback);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Read the entire file as a list of strings splitting by the provided separator.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db the database to query.\r\n * @param {(String|object)} name the name of the file.\r\n * @param {string} [separator] The character to be recognized as the newline separator.\r\n * @param {object} [options] Optional settings.\r\n * @param {(ReadPreference|string)} [options.readPreference] The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~readlinesCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.readlines = function(db, name, separator, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  separator = args.length ? args.shift() : null;\r\n  options = args.length ? args.shift() : null;\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(\r\n    db.s.topology,\r\n    readlinesStatic,\r\n    [db, name, separator, options, callback],\r\n    { skipSessions: true }\r\n  );\r\n};\r\n\r\nvar readlinesStatic = function(db, name, separator, options, callback) {\r\n  var finalSeperator = separator == null ? '\\n' : separator;\r\n  new GridStore(db, name, 'r', options).open(function(err, gridStore) {\r\n    if (err) return callback(err);\r\n    gridStore.readlines(finalSeperator, callback);\r\n  });\r\n};\r\n\r\n/**\r\n * Deletes the chunks and metadata information of a file from GridFS.\r\n *\r\n * @method\r\n * @static\r\n * @param {Db} db The database to query.\r\n * @param {(string|array)} names The name/names of the files to delete.\r\n * @param {object} [options] Optional settings.\r\n * @param {object} [options.promiseLibrary] A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible\r\n * @param {ClientSession} [options.session] optional session to use for this operation\r\n * @param {GridStore~resultCallback} [callback] the command callback.\r\n * @return {Promise} returns Promise if no callback passed\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nGridStore.unlink = function(db, names, options, callback) {\r\n  var args = Array.prototype.slice.call(arguments, 2);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  options = args.length ? args.shift() : {};\r\n  options = options || {};\r\n\r\n  return executeLegacyOperation(db.s.topology, unlinkStatic, [this, db, names, options, callback], {\r\n    skipSessions: true\r\n  });\r\n};\r\n\r\nvar unlinkStatic = function(self, db, names, options, callback) {\r\n  // Get the write concern\r\n  var writeConcern = _getWriteConcern(db, options);\r\n\r\n  // List of names\r\n  if (names.constructor === Array) {\r\n    var tc = 0;\r\n    for (var i = 0; i < names.length; i++) {\r\n      ++tc;\r\n      GridStore.unlink(db, names[i], options, function() {\r\n        if (--tc === 0) {\r\n          callback(null, self);\r\n        }\r\n      });\r\n    }\r\n  } else {\r\n    new GridStore(db, names, 'w', options).open(function(err, gridStore) {\r\n      if (err) return callback(err);\r\n      deleteChunks(gridStore, function(err) {\r\n        if (err) return callback(err);\r\n        gridStore.collection(function(err, collection) {\r\n          if (err) return callback(err);\r\n          collection.remove({ _id: gridStore.fileId }, writeConcern, function(err) {\r\n            callback(err, self);\r\n          });\r\n        });\r\n      });\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n *  @ignore\r\n */\r\nvar _writeNormal = function(self, data, close, options, callback) {\r\n  // If we have a buffer write it using the writeBuffer method\r\n  if (Buffer.isBuffer(data)) {\r\n    return writeBuffer(self, data, close, callback);\r\n  } else {\r\n    return writeBuffer(self, Buffer.from(data, 'binary'), close, callback);\r\n  }\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar _setWriteConcernHash = function(options) {\r\n  const baseOptions = Object.assign(options, options.writeConcern);\r\n  var finalOptions = {};\r\n  if (baseOptions.w != null) finalOptions.w = baseOptions.w;\r\n  if (baseOptions.journal === true) finalOptions.j = baseOptions.journal;\r\n  if (baseOptions.j === true) finalOptions.j = baseOptions.j;\r\n  if (baseOptions.fsync === true) finalOptions.fsync = baseOptions.fsync;\r\n  if (baseOptions.wtimeout != null) finalOptions.wtimeout = baseOptions.wtimeout;\r\n  return finalOptions;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar _getWriteConcern = function(self, options) {\r\n  // Final options\r\n  var finalOptions = { w: 1 };\r\n  options = options || {};\r\n\r\n  // Local options verification\r\n  if (\r\n    options.writeConcern != null ||\r\n    options.w != null ||\r\n    typeof options.j === 'boolean' ||\r\n    typeof options.journal === 'boolean' ||\r\n    typeof options.fsync === 'boolean'\r\n  ) {\r\n    finalOptions = _setWriteConcernHash(options);\r\n  } else if (options.safe != null && typeof options.safe === 'object') {\r\n    finalOptions = _setWriteConcernHash(options.safe);\r\n  } else if (typeof options.safe === 'boolean') {\r\n    finalOptions = { w: options.safe ? 1 : 0 };\r\n  } else if (\r\n    self.options.writeConcern != null ||\r\n    self.options.w != null ||\r\n    typeof self.options.j === 'boolean' ||\r\n    typeof self.options.journal === 'boolean' ||\r\n    typeof self.options.fsync === 'boolean'\r\n  ) {\r\n    finalOptions = _setWriteConcernHash(self.options);\r\n  } else if (\r\n    self.safe &&\r\n    (self.safe.w != null ||\r\n      typeof self.safe.j === 'boolean' ||\r\n      typeof self.safe.journal === 'boolean' ||\r\n      typeof self.safe.fsync === 'boolean')\r\n  ) {\r\n    finalOptions = _setWriteConcernHash(self.safe);\r\n  } else if (typeof self.safe === 'boolean') {\r\n    finalOptions = { w: self.safe ? 1 : 0 };\r\n  }\r\n\r\n  // Ensure we don't have an invalid combination of write concerns\r\n  if (\r\n    finalOptions.w < 1 &&\r\n    (finalOptions.journal === true || finalOptions.j === true || finalOptions.fsync === true)\r\n  )\r\n    throw MongoError.create({\r\n      message: 'No acknowledgement using w < 1 cannot be combined with journal:true or fsync:true',\r\n      driver: true\r\n    });\r\n\r\n  // Return the options\r\n  return finalOptions;\r\n};\r\n\r\n/**\r\n * Create a new GridStoreStream instance (INTERNAL TYPE, do not instantiate directly)\r\n *\r\n * @class\r\n * @extends external:Duplex\r\n * @return {GridStoreStream} a GridStoreStream instance.\r\n * @deprecated Use GridFSBucket API instead\r\n */\r\nvar GridStoreStream = function(gs) {\r\n  // Initialize the duplex stream\r\n  Duplex.call(this);\r\n\r\n  // Get the gridstore\r\n  this.gs = gs;\r\n\r\n  // End called\r\n  this.endCalled = false;\r\n\r\n  // If we have a seek\r\n  this.totalBytesToRead = this.gs.length - this.gs.position;\r\n  this.seekPosition = this.gs.position;\r\n};\r\n\r\n//\r\n// Inherit duplex\r\ninherits(GridStoreStream, Duplex);\r\n\r\nGridStoreStream.prototype._pipe = GridStoreStream.prototype.pipe;\r\n\r\n// Set up override\r\nGridStoreStream.prototype.pipe = function(destination) {\r\n  var self = this;\r\n\r\n  // Only open gridstore if not already open\r\n  if (!self.gs.isOpen) {\r\n    self.gs.open(function(err) {\r\n      if (err) return self.emit('error', err);\r\n      self.totalBytesToRead = self.gs.length - self.gs.position;\r\n      self._pipe.apply(self, [destination]);\r\n    });\r\n  } else {\r\n    self.totalBytesToRead = self.gs.length - self.gs.position;\r\n    self._pipe.apply(self, [destination]);\r\n  }\r\n\r\n  return destination;\r\n};\r\n\r\n// Called by stream\r\nGridStoreStream.prototype._read = function() {\r\n  var self = this;\r\n\r\n  var read = function() {\r\n    // Read data\r\n    self.gs.read(length, function(err, buffer) {\r\n      if (err && !self.endCalled) return self.emit('error', err);\r\n\r\n      // Stream is closed\r\n      if (self.endCalled || buffer == null) return self.push(null);\r\n      // Remove bytes read\r\n      if (buffer.length <= self.totalBytesToRead) {\r\n        self.totalBytesToRead = self.totalBytesToRead - buffer.length;\r\n        self.push(buffer);\r\n      } else if (buffer.length > self.totalBytesToRead) {\r\n        self.totalBytesToRead = self.totalBytesToRead - buffer._index;\r\n        self.push(buffer.slice(0, buffer._index));\r\n      }\r\n\r\n      // Finished reading\r\n      if (self.totalBytesToRead <= 0) {\r\n        self.endCalled = true;\r\n      }\r\n    });\r\n  };\r\n\r\n  // Set read length\r\n  var length =\r\n    self.gs.length < self.gs.chunkSize ? self.gs.length - self.seekPosition : self.gs.chunkSize;\r\n  if (!self.gs.isOpen) {\r\n    self.gs.open(function(err) {\r\n      self.totalBytesToRead = self.gs.length - self.gs.position;\r\n      if (err) return self.emit('error', err);\r\n      read();\r\n    });\r\n  } else {\r\n    read();\r\n  }\r\n};\r\n\r\nGridStoreStream.prototype.destroy = function() {\r\n  this.pause();\r\n  this.endCalled = true;\r\n  this.gs.close();\r\n  this.emit('end');\r\n};\r\n\r\nGridStoreStream.prototype.write = function(chunk) {\r\n  var self = this;\r\n  if (self.endCalled)\r\n    return self.emit(\r\n      'error',\r\n      MongoError.create({ message: 'attempting to write to stream after end called', driver: true })\r\n    );\r\n  // Do we have to open the gridstore\r\n  if (!self.gs.isOpen) {\r\n    self.gs.open(function() {\r\n      self.gs.isOpen = true;\r\n      self.gs.write(chunk, function() {\r\n        process.nextTick(function() {\r\n          self.emit('drain');\r\n        });\r\n      });\r\n    });\r\n    return false;\r\n  } else {\r\n    self.gs.write(chunk, function() {\r\n      self.emit('drain');\r\n    });\r\n    return true;\r\n  }\r\n};\r\n\r\nGridStoreStream.prototype.end = function(chunk, encoding, callback) {\r\n  var self = this;\r\n  var args = Array.prototype.slice.call(arguments, 0);\r\n  callback = typeof args[args.length - 1] === 'function' ? args.pop() : undefined;\r\n  chunk = args.length ? args.shift() : null;\r\n  encoding = args.length ? args.shift() : null;\r\n  self.endCalled = true;\r\n\r\n  if (chunk) {\r\n    self.gs.write(chunk, function() {\r\n      self.gs.close(function() {\r\n        if (typeof callback === 'function') callback();\r\n        self.emit('end');\r\n      });\r\n    });\r\n  }\r\n\r\n  self.gs.close(function() {\r\n    if (typeof callback === 'function') callback();\r\n    self.emit('end');\r\n  });\r\n};\r\n\r\n/**\r\n * The read() method pulls some data out of the internal buffer and returns it. If there is no data available, then it will return null.\r\n * @function external:Duplex#read\r\n * @param {number} size Optional argument to specify how much data to read.\r\n * @return {(String | Buffer | null)}\r\n */\r\n\r\n/**\r\n * Call this function to cause the stream to return strings of the specified encoding instead of Buffer objects.\r\n * @function external:Duplex#setEncoding\r\n * @param {string} encoding The encoding to use.\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This method will cause the readable stream to resume emitting data events.\r\n * @function external:Duplex#resume\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This method will cause a stream in flowing-mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\r\n * @function external:Duplex#pause\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\r\n * @function external:Duplex#pipe\r\n * @param {Writable} destination The destination for writing data\r\n * @param {object} [options] Pipe options\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This method will remove the hooks set up for a previous pipe() call.\r\n * @function external:Duplex#unpipe\r\n * @param {Writable} [destination] The destination for writing data\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This is useful in certain cases where a stream is being consumed by a parser, which needs to \"un-consume\" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.\r\n * @function external:Duplex#unshift\r\n * @param {(Buffer|string)} chunk Chunk of data to unshift onto the read queue.\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * Versions of Node prior to v0.10 had streams that did not implement the entire Streams API as it is today. (See \"Compatibility\" below for more information.)\r\n * @function external:Duplex#wrap\r\n * @param {Stream} stream An \"old style\" readable stream.\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * This method writes some data to the underlying system, and calls the supplied callback once the data has been fully handled.\r\n * @function external:Duplex#write\r\n * @param {(string|Buffer)} chunk The data to write\r\n * @param {string} encoding The encoding, if chunk is a String\r\n * @param {function} callback Callback for when this chunk of data is flushed\r\n * @return {boolean}\r\n */\r\n\r\n/**\r\n * Call this method when no more data will be written to the stream. If supplied, the callback is attached as a listener on the finish event.\r\n * @function external:Duplex#end\r\n * @param {(string|Buffer)} chunk The data to write\r\n * @param {string} encoding The encoding, if chunk is a String\r\n * @param {function} callback Callback for when this chunk of data is flushed\r\n * @return {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream data event, fired for each document in the cursor.\r\n *\r\n * @event GridStoreStream#data\r\n * @type {object}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream end event\r\n *\r\n * @event GridStoreStream#end\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream close event\r\n *\r\n * @event GridStoreStream#close\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream readable event\r\n *\r\n * @event GridStoreStream#readable\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream drain event\r\n *\r\n * @event GridStoreStream#drain\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream finish event\r\n *\r\n * @event GridStoreStream#finish\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream pipe event\r\n *\r\n * @event GridStoreStream#pipe\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream unpipe event\r\n *\r\n * @event GridStoreStream#unpipe\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * GridStoreStream stream error event\r\n *\r\n * @event GridStoreStream#error\r\n * @type {null}\r\n */\r\n\r\n/**\r\n * @ignore\r\n */\r\nmodule.exports = GridStore;\r\n"]},"metadata":{},"sourceType":"script"}