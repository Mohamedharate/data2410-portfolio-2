{"ast":null,"code":"'use strict';\n\nconst Logger = require('./connection/logger');\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\n\nconst MongoError = require('./error').MongoError;\n\nconst MongoNetworkError = require('./error').MongoNetworkError;\n\nconst collationNotSupported = require('./utils').collationNotSupported;\n\nconst ReadPreference = require('./topologies/read_preference');\n\nconst isUnifiedTopology = require('./utils').isUnifiedTopology;\n\nconst executeOperation = require('../operations/execute_operation');\n\nconst Readable = require('stream').Readable;\n\nconst SUPPORTS = require('../utils').SUPPORTS;\n\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\n\nconst mergeOptions = require('../utils').mergeOptions;\n\nconst OperationBase = require('../operations/operation').OperationBase;\n\nconst BSON = retrieveBSON();\nconst Long = BSON.Long; // Possible states for a cursor\n\nconst CursorState = {\n  INIT: 0,\n  OPEN: 1,\n  CLOSED: 2,\n  GET_MORE: 3\n}; //\n// Handle callback (including any exceptions thrown)\n\nfunction handleCallback(callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n  }\n}\n/**\r\n * This is a cursor results callback\r\n *\r\n * @callback resultCallback\r\n * @param {error} error An error object. Set to null if no error present\r\n * @param {object} document\r\n */\n\n/**\r\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\r\n * allowing for iteration over the results returned from the underlying query.\r\n *\r\n * **CURSORS Cannot directly be instantiated**\r\n */\n\n/**\r\n * The core cursor class. All cursors in the driver build off of this one.\r\n *\r\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\r\n * @property {number} cursorLimit The current cursorLimit for the cursor\r\n * @property {number} cursorSkip The current cursorSkip for the cursor\r\n */\n\n\nclass CoreCursor extends Readable {\n  /**\r\n   * Create a new core `Cursor` instance.\r\n   * **NOTE** Not to be instantiated directly\r\n   *\r\n   * @param {object} topology The server topology instance.\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\r\n   * @param {object} [options=null] Optional settings.\r\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n   * @param {array} [options.documents=[]] Initial documents list for cursor\r\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\r\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\r\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\r\n   */\n  constructor(topology, ns, cmd, options) {\n    super({\n      objectMode: true\n    });\n    options = options || {};\n\n    if (ns instanceof OperationBase) {\n      this.operation = ns;\n      ns = this.operation.ns.toString();\n      options = this.operation.options;\n      cmd = this.operation.cmd ? this.operation.cmd : {};\n    } // Cursor pool\n\n\n    this.pool = null; // Cursor server\n\n    this.server = null; // Do we have a not connected handler\n\n    this.disconnectHandler = options.disconnectHandler; // Set local values\n\n    this.bson = topology.s.bson;\n    this.ns = ns;\n    this.namespace = MongoDBNamespace.fromString(ns);\n    this.cmd = cmd;\n    this.options = options;\n    this.topology = topology; // All internal state\n\n    this.cursorState = {\n      cursorId: null,\n      cmd,\n      documents: options.documents || [],\n      cursorIndex: 0,\n      dead: false,\n      killed: false,\n      init: false,\n      notified: false,\n      limit: options.limit || cmd.limit || 0,\n      skip: options.skip || cmd.skip || 0,\n      batchSize: options.batchSize || cmd.batchSize || 1000,\n      currentLimit: 0,\n      // Result field name if not a cursor (contains the array of results)\n      transforms: options.transforms,\n      raw: options.raw || cmd && cmd.raw\n    };\n\n    if (typeof options.session === 'object') {\n      this.cursorState.session = options.session;\n    } // Add promoteLong to cursor state\n\n\n    const topologyOptions = topology.s.options;\n\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n    } else if (typeof options.promoteLongs === 'boolean') {\n      this.cursorState.promoteLongs = options.promoteLongs;\n    } // Add promoteValues to cursor state\n\n\n    if (typeof topologyOptions.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = topologyOptions.promoteValues;\n    } else if (typeof options.promoteValues === 'boolean') {\n      this.cursorState.promoteValues = options.promoteValues;\n    } // Add promoteBuffers to cursor state\n\n\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\n    } else if (typeof options.promoteBuffers === 'boolean') {\n      this.cursorState.promoteBuffers = options.promoteBuffers;\n    }\n\n    if (topologyOptions.reconnect) {\n      this.cursorState.reconnect = topologyOptions.reconnect;\n    } // Logger\n\n\n    this.logger = Logger('Cursor', topologyOptions); //\n    // Did we pass in a cursor id\n\n    if (typeof cmd === 'number') {\n      this.cursorState.cursorId = Long.fromNumber(cmd);\n      this.cursorState.lastCursorId = this.cursorState.cursorId;\n    } else if (cmd instanceof Long) {\n      this.cursorState.cursorId = cmd;\n      this.cursorState.lastCursorId = cmd;\n    } // TODO: remove as part of NODE-2104\n\n\n    if (this.operation) {\n      this.operation.cursorState = this.cursorState;\n    }\n  }\n\n  setCursorBatchSize(value) {\n    this.cursorState.batchSize = value;\n  }\n\n  cursorBatchSize() {\n    return this.cursorState.batchSize;\n  }\n\n  setCursorLimit(value) {\n    this.cursorState.limit = value;\n  }\n\n  cursorLimit() {\n    return this.cursorState.limit;\n  }\n\n  setCursorSkip(value) {\n    this.cursorState.skip = value;\n  }\n\n  cursorSkip() {\n    return this.cursorState.skip;\n  }\n  /**\r\n   * Retrieve the next document from the cursor\r\n   * @method\r\n   * @param {resultCallback} callback A callback function\r\n   */\n\n\n  _next(callback) {\n    nextFunction(this, callback);\n  }\n  /**\r\n   * Clone the cursor\r\n   * @method\r\n   * @return {Cursor}\r\n   */\n\n\n  clone() {\n    const clonedOptions = mergeOptions({}, this.options);\n    delete clonedOptions.session;\n    return this.topology.cursor(this.ns, this.cmd, clonedOptions);\n  }\n  /**\r\n   * Checks if the cursor is dead\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor is dead or not\r\n   */\n\n\n  isDead() {\n    return this.cursorState.dead === true;\n  }\n  /**\r\n   * Checks if the cursor was killed by the application\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor was killed by the application\r\n   */\n\n\n  isKilled() {\n    return this.cursorState.killed === true;\n  }\n  /**\r\n   * Checks if the cursor notified it's caller about it's death\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor notified the callback\r\n   */\n\n\n  isNotified() {\n    return this.cursorState.notified === true;\n  }\n  /**\r\n   * Returns current buffered documents length\r\n   * @method\r\n   * @return {number} The number of items in the buffered documents\r\n   */\n\n\n  bufferedCount() {\n    return this.cursorState.documents.length - this.cursorState.cursorIndex;\n  }\n  /**\r\n   * Returns current buffered documents\r\n   * @method\r\n   * @return {Array} An array of buffered documents\r\n   */\n\n\n  readBufferedDocuments(number) {\n    const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n    const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n    let elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length); // Transform the doc with passed in transformation method if provided\n\n    if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\n      // Transform all the elements\n      for (let i = 0; i < elements.length; i++) {\n        elements[i] = this.cursorState.transforms.doc(elements[i]);\n      }\n    } // Ensure we do not return any more documents than the limit imposed\n    // Just return the number of elements up to the limit\n\n\n    if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {\n      elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n      this.kill();\n    } // Adjust current limit\n\n\n    this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n    this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length; // Return elements\n\n    return elements;\n  }\n  /**\r\n   * Resets local state for this cursor instance, and issues a `killCursors` command to the server\r\n   *\r\n   * @param {resultCallback} callback A callback function\r\n   */\n\n\n  kill(callback) {\n    // Set cursor to dead\n    this.cursorState.dead = true;\n    this.cursorState.killed = true; // Remove documents\n\n    this.cursorState.documents = []; // If no cursor id just return\n\n    if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init === false) {\n      if (callback) callback(null, null);\n      return;\n    }\n\n    this.server.killCursors(this.ns, this.cursorState, callback);\n  }\n  /**\r\n   * Resets the cursor\r\n   */\n\n\n  rewind() {\n    if (this.cursorState.init) {\n      if (!this.cursorState.dead) {\n        this.kill();\n      }\n\n      this.cursorState.currentLimit = 0;\n      this.cursorState.init = false;\n      this.cursorState.dead = false;\n      this.cursorState.killed = false;\n      this.cursorState.notified = false;\n      this.cursorState.documents = [];\n      this.cursorState.cursorId = null;\n      this.cursorState.cursorIndex = 0;\n    }\n  } // Internal methods\n\n\n  _read() {\n    if (this.s && this.s.state === CursorState.CLOSED || this.isDead()) {\n      return this.push(null);\n    } // Get the next item\n\n\n    this._next((err, result) => {\n      if (err) {\n        if (this.listeners('error') && this.listeners('error').length > 0) {\n          this.emit('error', err);\n        }\n\n        if (!this.isDead()) this.close(); // Emit end event\n\n        this.emit('end');\n        return this.emit('finish');\n      } // If we provided a transformation method\n\n\n      if (this.cursorState.streamOptions && typeof this.cursorState.streamOptions.transform === 'function' && result != null) {\n        return this.push(this.cursorState.streamOptions.transform(result));\n      } // Return the result\n\n\n      this.push(result);\n\n      if (result === null && this.isDead()) {\n        this.once('end', () => {\n          this.close();\n          this.emit('finish');\n        });\n      }\n    });\n  }\n\n  _endSession(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    const session = this.cursorState.session;\n\n    if (session && (options.force || session.owner === this)) {\n      this.cursorState.session = undefined;\n\n      if (this.operation) {\n        this.operation.clearSession();\n      }\n\n      session.endSession(callback);\n      return true;\n    }\n\n    if (callback) {\n      callback();\n    }\n\n    return false;\n  }\n\n  _getMore(callback) {\n    if (this.logger.isDebug()) {\n      this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);\n    } // Set the current batchSize\n\n\n    let batchSize = this.cursorState.batchSize;\n\n    if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {\n      batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n    }\n\n    const cursorState = this.cursorState;\n    this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {\n      // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\n      if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n        this._endSession();\n      }\n\n      callback(err, result, conn);\n    });\n  }\n\n  _initializeCursor(callback) {\n    const cursor = this; // NOTE: this goes away once cursors use `executeOperation`\n\n    if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\n      cursor.topology.selectServer(ReadPreference.primaryPreferred, err => {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        this._initializeCursor(callback);\n      });\n      return;\n    }\n\n    function done(err, result) {\n      const cursorState = cursor.cursorState;\n\n      if (err || cursorState.cursorId && cursorState.cursorId.isZero()) {\n        cursor._endSession();\n      }\n\n      if (cursorState.documents.length === 0 && cursorState.cursorId && cursorState.cursorId.isZero() && !cursor.cmd.tailable && !cursor.cmd.awaitData) {\n        return setCursorNotified(cursor, callback);\n      }\n\n      callback(err, result);\n    }\n\n    const queryCallback = (err, r) => {\n      if (err) {\n        return done(err);\n      }\n\n      const result = r.message;\n\n      if (Array.isArray(result.documents) && result.documents.length === 1) {\n        const document = result.documents[0];\n\n        if (result.queryFailure) {\n          return done(new MongoError(document), null);\n        } // Check if we have a command cursor\n\n\n        if (!cursor.cmd.find || cursor.cmd.find && cursor.cmd.virtual === false) {\n          // We have an error document, return the error\n          if (document.$err || document.errmsg) {\n            return done(new MongoError(document), null);\n          } // We have a cursor document\n\n\n          if (document.cursor != null && typeof document.cursor !== 'string') {\n            const id = document.cursor.id; // If we have a namespace change set the new namespace for getmores\n\n            if (document.cursor.ns) {\n              cursor.ns = document.cursor.ns;\n            } // Promote id to long if needed\n\n\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\n            cursor.cursorState.operationTime = document.operationTime; // If we have a firstBatch set it\n\n            if (Array.isArray(document.cursor.firstBatch)) {\n              cursor.cursorState.documents = document.cursor.firstBatch; //.reverse();\n            } // Return after processing command cursor\n\n\n            return done(null, result);\n          }\n        }\n      } // Otherwise fall back to regular find path\n\n\n      const cursorId = result.cursorId || 0;\n      cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\n      cursor.cursorState.documents = result.documents;\n      cursor.cursorState.lastCursorId = result.cursorId; // Transform the results with passed in transformation method if provided\n\n      if (cursor.cursorState.transforms && typeof cursor.cursorState.transforms.query === 'function') {\n        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\n      }\n\n      done(null, result);\n    };\n\n    if (cursor.operation) {\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);\n      }\n\n      executeOperation(cursor.topology, cursor.operation, (err, result) => {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        cursor.server = cursor.operation.server;\n        cursor.cursorState.init = true; // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n        if (cursor.cursorState.cursorId != null) {\n          return done();\n        }\n\n        queryCallback(err, result);\n      });\n      return;\n    } // Very explicitly choose what is passed to selectServer\n\n\n    const serverSelectOptions = {};\n\n    if (cursor.cursorState.session) {\n      serverSelectOptions.session = cursor.cursorState.session;\n    }\n\n    if (cursor.operation) {\n      serverSelectOptions.readPreference = cursor.operation.readPreference;\n    } else if (cursor.options.readPreference) {\n      serverSelectOptions.readPreference = cursor.options.readPreference;\n    }\n\n    return cursor.topology.selectServer(serverSelectOptions, (err, server) => {\n      if (err) {\n        const disconnectHandler = cursor.disconnectHandler;\n\n        if (disconnectHandler != null) {\n          return disconnectHandler.addObjectAndMethod('cursor', cursor, 'next', [callback], callback);\n        }\n\n        return callback(err);\n      }\n\n      cursor.server = server;\n      cursor.cursorState.init = true;\n\n      if (collationNotSupported(cursor.server, cursor.cmd)) {\n        return callback(new MongoError(`server ${cursor.server.name} does not support collation`));\n      } // NOTE: this is a special internal method for cloning a cursor, consider removing\n\n\n      if (cursor.cursorState.cursorId != null) {\n        return done();\n      }\n\n      if (cursor.logger.isDebug()) {\n        cursor.logger.debug(`issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(cursor.query)}]`);\n      }\n\n      if (cursor.cmd.find != null) {\n        server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\n        return;\n      }\n\n      const commandOptions = Object.assign({\n        session: cursor.cursorState.session\n      }, cursor.options);\n      server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\n    });\n  }\n\n}\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\n}\n/**\r\n * Validate if the pool is dead and return error\r\n */\n\n\nfunction isConnectionDead(self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.killed = true;\n    const err = new MongoNetworkError(`connection to host ${self.pool.host}:${self.pool.port} was destroyed`);\n\n    _setCursorNotifiedImpl(self, () => callback(err));\n\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Validate if the cursor is dead but was not explicitly killed by user\r\n */\n\n\nfunction isCursorDeadButNotkilled(self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.killed = true;\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Validate if the cursor is dead and was killed by user\r\n */\n\n\nfunction isCursorDeadAndKilled(self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, new MongoError('cursor is dead'));\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Validate if the cursor was killed by the user\r\n */\n\n\nfunction isCursorKilled(self, callback) {\n  if (self.cursorState.killed) {\n    setCursorNotified(self, callback);\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Mark cursor as being dead and notified\r\n */\n\n\nfunction setCursorDeadAndNotified(self, callback) {\n  self.cursorState.dead = true;\n  setCursorNotified(self, callback);\n}\n/**\r\n * Mark cursor as being notified\r\n */\n\n\nfunction setCursorNotified(self, callback) {\n  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\n}\n\nfunction _setCursorNotifiedImpl(self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n\n  if (self.cursorState.session) {\n    self._endSession(callback);\n\n    return;\n  }\n\n  return callback();\n}\n\nfunction nextFunction(self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  } // Cursor is killed return null\n\n\n  if (isCursorKilled(self, callback)) return; // Cursor is dead but not marked killed, return null\n\n  if (isCursorDeadButNotkilled(self, callback)) return; // We have a dead and killed cursor, attempting to call next should error\n\n  if (isCursorDeadAndKilled(self, callback)) return; // We have just started the cursor\n\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options)) {\n      // Only need this for single server, because repl sets and mongos\n      // will always continue trying to reconnect\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\n        // Reconnect is disabled, so we'll never reconnect\n        return callback(new MongoError('no connection available'));\n      }\n\n      if (self.disconnectHandler != null) {\n        if (self.topology.isDestroyed()) {\n          // Topology was destroyed, so don't try to wait for it to reconnect\n          return callback(new MongoError('Topology was destroyed'));\n        }\n\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n        return;\n      }\n    }\n\n    self._initializeCursor((err, result) => {\n      if (err || result === null) {\n        callback(err, result);\n        return;\n      }\n\n      nextFunction(self, callback);\n    });\n\n    return;\n  }\n\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(() => // Set cursor in dead and notified state\n    setCursorDeadAndNotified(self, callback));\n  } else if (self.cursorState.cursorIndex === self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0; // Check if topology is destroyed\n\n    if (self.topology.isDestroyed()) return callback(new MongoNetworkError('connection destroyed, not possible to instantiate cursor')); // Check if connection is dead and return if not possible to\n    // execute a getMore on this connection\n\n    if (isConnectionDead(self, callback)) return; // Execute the next get more\n\n    self._getMore(function (err, doc, connection) {\n      if (err) {\n        return handleCallback(callback, err);\n      } // Save the returned connection to ensure all getMore's fire over the same connection\n\n\n      self.connection = connection; // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n\n      if (self.cursorState.documents.length === 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n        // No more documents in the tailed cursor\n        return handleCallback(callback, new MongoError({\n          message: 'No more documents in tailed cursor',\n          tailable: self.cmd.tailable,\n          awaitData: self.cmd.awaitData\n        }));\n      } else if (self.cursorState.documents.length === 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n    return handleCallback(callback, new MongoError({\n      message: 'No more documents in tailed cursor',\n      tailable: self.cmd.tailable,\n      awaitData: self.cmd.awaitData\n    }));\n  } else if (self.cursorState.documents.length === self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(() => // Set cursor in dead and notified state\n      setCursorDeadAndNotified(self, callback));\n      return;\n    } // Increment the current cursor limit\n\n\n    self.cursorState.currentLimit += 1; // Get the document\n\n    let doc = self.cursorState.documents[self.cursorState.cursorIndex++]; // Doc overflow\n\n    if (!doc || doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(() => // Set cursor in dead and notified state\n      setCursorDeadAndNotified(self, function () {\n        handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\n      }));\n      return;\n    } // Transform the doc with passed in transformation method if provided\n\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    } // Return the document\n\n\n    handleCallback(callback, null, doc);\n  }\n}\n\nmodule.exports = {\n  CursorState,\n  CoreCursor\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/core/cursor.js"],"names":["Logger","require","retrieveBSON","MongoError","MongoNetworkError","collationNotSupported","ReadPreference","isUnifiedTopology","executeOperation","Readable","SUPPORTS","MongoDBNamespace","mergeOptions","OperationBase","BSON","Long","CursorState","INIT","OPEN","CLOSED","GET_MORE","handleCallback","callback","err","result","process","nextTick","CoreCursor","constructor","topology","ns","cmd","options","objectMode","operation","toString","pool","server","disconnectHandler","bson","s","namespace","fromString","cursorState","cursorId","documents","cursorIndex","dead","killed","init","notified","limit","skip","batchSize","currentLimit","transforms","raw","session","topologyOptions","promoteLongs","promoteValues","promoteBuffers","reconnect","logger","fromNumber","lastCursorId","setCursorBatchSize","value","cursorBatchSize","setCursorLimit","cursorLimit","setCursorSkip","cursorSkip","_next","nextFunction","clone","clonedOptions","cursor","isDead","isKilled","isNotified","bufferedCount","length","readBufferedDocuments","number","unreadDocumentsLength","elements","slice","doc","i","kill","isZero","killCursors","rewind","_read","state","push","listeners","emit","close","streamOptions","transform","once","_endSession","force","owner","undefined","clearSession","endSession","_getMore","isDebug","debug","JSON","stringify","query","getMore","conn","_initializeCursor","shouldCheckForSessionSupport","selectServer","primaryPreferred","done","tailable","awaitData","setCursorNotified","queryCallback","r","message","Array","isArray","document","queryFailure","find","virtual","$err","errmsg","id","operationTime","firstBatch","serverSelectOptions","readPreference","addObjectAndMethod","name","commandOptions","Object","assign","command","ASYNC_ITERATOR","prototype","Symbol","asyncIterator","isConnectionDead","self","isDestroyed","host","port","_setCursorNotifiedImpl","isCursorDeadButNotkilled","isCursorDeadAndKilled","isCursorKilled","setCursorDeadAndNotified","Error","isConnected","_type","ZERO","equals","connection","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Logger = require('./connection/logger');\r\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\r\nconst MongoError = require('./error').MongoError;\r\nconst MongoNetworkError = require('./error').MongoNetworkError;\r\nconst collationNotSupported = require('./utils').collationNotSupported;\r\nconst ReadPreference = require('./topologies/read_preference');\r\nconst isUnifiedTopology = require('./utils').isUnifiedTopology;\r\nconst executeOperation = require('../operations/execute_operation');\r\nconst Readable = require('stream').Readable;\r\nconst SUPPORTS = require('../utils').SUPPORTS;\r\nconst MongoDBNamespace = require('../utils').MongoDBNamespace;\r\nconst mergeOptions = require('../utils').mergeOptions;\r\nconst OperationBase = require('../operations/operation').OperationBase;\r\n\r\nconst BSON = retrieveBSON();\r\nconst Long = BSON.Long;\r\n\r\n// Possible states for a cursor\r\nconst CursorState = {\r\n  INIT: 0,\r\n  OPEN: 1,\r\n  CLOSED: 2,\r\n  GET_MORE: 3\r\n};\r\n\r\n//\r\n// Handle callback (including any exceptions thrown)\r\nfunction handleCallback(callback, err, result) {\r\n  try {\r\n    callback(err, result);\r\n  } catch (err) {\r\n    process.nextTick(function() {\r\n      throw err;\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * This is a cursor results callback\r\n *\r\n * @callback resultCallback\r\n * @param {error} error An error object. Set to null if no error present\r\n * @param {object} document\r\n */\r\n\r\n/**\r\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\r\n * allowing for iteration over the results returned from the underlying query.\r\n *\r\n * **CURSORS Cannot directly be instantiated**\r\n */\r\n\r\n/**\r\n * The core cursor class. All cursors in the driver build off of this one.\r\n *\r\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\r\n * @property {number} cursorLimit The current cursorLimit for the cursor\r\n * @property {number} cursorSkip The current cursorSkip for the cursor\r\n */\r\nclass CoreCursor extends Readable {\r\n  /**\r\n   * Create a new core `Cursor` instance.\r\n   * **NOTE** Not to be instantiated directly\r\n   *\r\n   * @param {object} topology The server topology instance.\r\n   * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\r\n   * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\r\n   * @param {object} [options=null] Optional settings.\r\n   * @param {object} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/| find command documentation} and {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n   * @param {array} [options.documents=[]] Initial documents list for cursor\r\n   * @param {object} [options.transforms=null] Transform methods for the cursor results\r\n   * @param {function} [options.transforms.query] Transform the value returned from the initial query\r\n   * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype._next\r\n   */\r\n  constructor(topology, ns, cmd, options) {\r\n    super({ objectMode: true });\r\n    options = options || {};\r\n\r\n    if (ns instanceof OperationBase) {\r\n      this.operation = ns;\r\n      ns = this.operation.ns.toString();\r\n      options = this.operation.options;\r\n      cmd = this.operation.cmd ? this.operation.cmd : {};\r\n    }\r\n\r\n    // Cursor pool\r\n    this.pool = null;\r\n    // Cursor server\r\n    this.server = null;\r\n\r\n    // Do we have a not connected handler\r\n    this.disconnectHandler = options.disconnectHandler;\r\n\r\n    // Set local values\r\n    this.bson = topology.s.bson;\r\n    this.ns = ns;\r\n    this.namespace = MongoDBNamespace.fromString(ns);\r\n    this.cmd = cmd;\r\n    this.options = options;\r\n    this.topology = topology;\r\n\r\n    // All internal state\r\n    this.cursorState = {\r\n      cursorId: null,\r\n      cmd,\r\n      documents: options.documents || [],\r\n      cursorIndex: 0,\r\n      dead: false,\r\n      killed: false,\r\n      init: false,\r\n      notified: false,\r\n      limit: options.limit || cmd.limit || 0,\r\n      skip: options.skip || cmd.skip || 0,\r\n      batchSize: options.batchSize || cmd.batchSize || 1000,\r\n      currentLimit: 0,\r\n      // Result field name if not a cursor (contains the array of results)\r\n      transforms: options.transforms,\r\n      raw: options.raw || (cmd && cmd.raw)\r\n    };\r\n\r\n    if (typeof options.session === 'object') {\r\n      this.cursorState.session = options.session;\r\n    }\r\n\r\n    // Add promoteLong to cursor state\r\n    const topologyOptions = topology.s.options;\r\n    if (typeof topologyOptions.promoteLongs === 'boolean') {\r\n      this.cursorState.promoteLongs = topologyOptions.promoteLongs;\r\n    } else if (typeof options.promoteLongs === 'boolean') {\r\n      this.cursorState.promoteLongs = options.promoteLongs;\r\n    }\r\n\r\n    // Add promoteValues to cursor state\r\n    if (typeof topologyOptions.promoteValues === 'boolean') {\r\n      this.cursorState.promoteValues = topologyOptions.promoteValues;\r\n    } else if (typeof options.promoteValues === 'boolean') {\r\n      this.cursorState.promoteValues = options.promoteValues;\r\n    }\r\n\r\n    // Add promoteBuffers to cursor state\r\n    if (typeof topologyOptions.promoteBuffers === 'boolean') {\r\n      this.cursorState.promoteBuffers = topologyOptions.promoteBuffers;\r\n    } else if (typeof options.promoteBuffers === 'boolean') {\r\n      this.cursorState.promoteBuffers = options.promoteBuffers;\r\n    }\r\n\r\n    if (topologyOptions.reconnect) {\r\n      this.cursorState.reconnect = topologyOptions.reconnect;\r\n    }\r\n\r\n    // Logger\r\n    this.logger = Logger('Cursor', topologyOptions);\r\n\r\n    //\r\n    // Did we pass in a cursor id\r\n    if (typeof cmd === 'number') {\r\n      this.cursorState.cursorId = Long.fromNumber(cmd);\r\n      this.cursorState.lastCursorId = this.cursorState.cursorId;\r\n    } else if (cmd instanceof Long) {\r\n      this.cursorState.cursorId = cmd;\r\n      this.cursorState.lastCursorId = cmd;\r\n    }\r\n\r\n    // TODO: remove as part of NODE-2104\r\n    if (this.operation) {\r\n      this.operation.cursorState = this.cursorState;\r\n    }\r\n  }\r\n\r\n  setCursorBatchSize(value) {\r\n    this.cursorState.batchSize = value;\r\n  }\r\n\r\n  cursorBatchSize() {\r\n    return this.cursorState.batchSize;\r\n  }\r\n\r\n  setCursorLimit(value) {\r\n    this.cursorState.limit = value;\r\n  }\r\n\r\n  cursorLimit() {\r\n    return this.cursorState.limit;\r\n  }\r\n\r\n  setCursorSkip(value) {\r\n    this.cursorState.skip = value;\r\n  }\r\n\r\n  cursorSkip() {\r\n    return this.cursorState.skip;\r\n  }\r\n\r\n  /**\r\n   * Retrieve the next document from the cursor\r\n   * @method\r\n   * @param {resultCallback} callback A callback function\r\n   */\r\n  _next(callback) {\r\n    nextFunction(this, callback);\r\n  }\r\n\r\n  /**\r\n   * Clone the cursor\r\n   * @method\r\n   * @return {Cursor}\r\n   */\r\n  clone() {\r\n    const clonedOptions = mergeOptions({}, this.options);\r\n    delete clonedOptions.session;\r\n    return this.topology.cursor(this.ns, this.cmd, clonedOptions);\r\n  }\r\n\r\n  /**\r\n   * Checks if the cursor is dead\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor is dead or not\r\n   */\r\n  isDead() {\r\n    return this.cursorState.dead === true;\r\n  }\r\n\r\n  /**\r\n   * Checks if the cursor was killed by the application\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor was killed by the application\r\n   */\r\n  isKilled() {\r\n    return this.cursorState.killed === true;\r\n  }\r\n\r\n  /**\r\n   * Checks if the cursor notified it's caller about it's death\r\n   * @method\r\n   * @return {boolean} A boolean signifying if the cursor notified the callback\r\n   */\r\n  isNotified() {\r\n    return this.cursorState.notified === true;\r\n  }\r\n\r\n  /**\r\n   * Returns current buffered documents length\r\n   * @method\r\n   * @return {number} The number of items in the buffered documents\r\n   */\r\n  bufferedCount() {\r\n    return this.cursorState.documents.length - this.cursorState.cursorIndex;\r\n  }\r\n\r\n  /**\r\n   * Returns current buffered documents\r\n   * @method\r\n   * @return {Array} An array of buffered documents\r\n   */\r\n  readBufferedDocuments(number) {\r\n    const unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\r\n    const length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\r\n    let elements = this.cursorState.documents.slice(\r\n      this.cursorState.cursorIndex,\r\n      this.cursorState.cursorIndex + length\r\n    );\r\n\r\n    // Transform the doc with passed in transformation method if provided\r\n    if (this.cursorState.transforms && typeof this.cursorState.transforms.doc === 'function') {\r\n      // Transform all the elements\r\n      for (let i = 0; i < elements.length; i++) {\r\n        elements[i] = this.cursorState.transforms.doc(elements[i]);\r\n      }\r\n    }\r\n\r\n    // Ensure we do not return any more documents than the limit imposed\r\n    // Just return the number of elements up to the limit\r\n    if (\r\n      this.cursorState.limit > 0 &&\r\n      this.cursorState.currentLimit + elements.length > this.cursorState.limit\r\n    ) {\r\n      elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\r\n      this.kill();\r\n    }\r\n\r\n    // Adjust current limit\r\n    this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\r\n    this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length;\r\n\r\n    // Return elements\r\n    return elements;\r\n  }\r\n\r\n  /**\r\n   * Resets local state for this cursor instance, and issues a `killCursors` command to the server\r\n   *\r\n   * @param {resultCallback} callback A callback function\r\n   */\r\n  kill(callback) {\r\n    // Set cursor to dead\r\n    this.cursorState.dead = true;\r\n    this.cursorState.killed = true;\r\n    // Remove documents\r\n    this.cursorState.documents = [];\r\n\r\n    // If no cursor id just return\r\n    if (\r\n      this.cursorState.cursorId == null ||\r\n      this.cursorState.cursorId.isZero() ||\r\n      this.cursorState.init === false\r\n    ) {\r\n      if (callback) callback(null, null);\r\n      return;\r\n    }\r\n\r\n    this.server.killCursors(this.ns, this.cursorState, callback);\r\n  }\r\n\r\n  /**\r\n   * Resets the cursor\r\n   */\r\n  rewind() {\r\n    if (this.cursorState.init) {\r\n      if (!this.cursorState.dead) {\r\n        this.kill();\r\n      }\r\n\r\n      this.cursorState.currentLimit = 0;\r\n      this.cursorState.init = false;\r\n      this.cursorState.dead = false;\r\n      this.cursorState.killed = false;\r\n      this.cursorState.notified = false;\r\n      this.cursorState.documents = [];\r\n      this.cursorState.cursorId = null;\r\n      this.cursorState.cursorIndex = 0;\r\n    }\r\n  }\r\n\r\n  // Internal methods\r\n  _read() {\r\n    if ((this.s && this.s.state === CursorState.CLOSED) || this.isDead()) {\r\n      return this.push(null);\r\n    }\r\n\r\n    // Get the next item\r\n    this._next((err, result) => {\r\n      if (err) {\r\n        if (this.listeners('error') && this.listeners('error').length > 0) {\r\n          this.emit('error', err);\r\n        }\r\n        if (!this.isDead()) this.close();\r\n\r\n        // Emit end event\r\n        this.emit('end');\r\n        return this.emit('finish');\r\n      }\r\n\r\n      // If we provided a transformation method\r\n      if (\r\n        this.cursorState.streamOptions &&\r\n        typeof this.cursorState.streamOptions.transform === 'function' &&\r\n        result != null\r\n      ) {\r\n        return this.push(this.cursorState.streamOptions.transform(result));\r\n      }\r\n\r\n      // Return the result\r\n      this.push(result);\r\n\r\n      if (result === null && this.isDead()) {\r\n        this.once('end', () => {\r\n          this.close();\r\n          this.emit('finish');\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  _endSession(options, callback) {\r\n    if (typeof options === 'function') {\r\n      callback = options;\r\n      options = {};\r\n    }\r\n    options = options || {};\r\n\r\n    const session = this.cursorState.session;\r\n\r\n    if (session && (options.force || session.owner === this)) {\r\n      this.cursorState.session = undefined;\r\n\r\n      if (this.operation) {\r\n        this.operation.clearSession();\r\n      }\r\n\r\n      session.endSession(callback);\r\n      return true;\r\n    }\r\n\r\n    if (callback) {\r\n      callback();\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  _getMore(callback) {\r\n    if (this.logger.isDebug()) {\r\n      this.logger.debug(`schedule getMore call for query [${JSON.stringify(this.query)}]`);\r\n    }\r\n\r\n    // Set the current batchSize\r\n    let batchSize = this.cursorState.batchSize;\r\n    if (\r\n      this.cursorState.limit > 0 &&\r\n      this.cursorState.currentLimit + batchSize > this.cursorState.limit\r\n    ) {\r\n      batchSize = this.cursorState.limit - this.cursorState.currentLimit;\r\n    }\r\n\r\n    const cursorState = this.cursorState;\r\n    this.server.getMore(this.ns, cursorState, batchSize, this.options, (err, result, conn) => {\r\n      // NOTE: `getMore` modifies `cursorState`, would be very ideal not to do so in the future\r\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\r\n        this._endSession();\r\n      }\r\n\r\n      callback(err, result, conn);\r\n    });\r\n  }\r\n\r\n  _initializeCursor(callback) {\r\n    const cursor = this;\r\n\r\n    // NOTE: this goes away once cursors use `executeOperation`\r\n    if (isUnifiedTopology(cursor.topology) && cursor.topology.shouldCheckForSessionSupport()) {\r\n      cursor.topology.selectServer(ReadPreference.primaryPreferred, err => {\r\n        if (err) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        this._initializeCursor(callback);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    function done(err, result) {\r\n      const cursorState = cursor.cursorState;\r\n      if (err || (cursorState.cursorId && cursorState.cursorId.isZero())) {\r\n        cursor._endSession();\r\n      }\r\n\r\n      if (\r\n        cursorState.documents.length === 0 &&\r\n        cursorState.cursorId &&\r\n        cursorState.cursorId.isZero() &&\r\n        !cursor.cmd.tailable &&\r\n        !cursor.cmd.awaitData\r\n      ) {\r\n        return setCursorNotified(cursor, callback);\r\n      }\r\n\r\n      callback(err, result);\r\n    }\r\n\r\n    const queryCallback = (err, r) => {\r\n      if (err) {\r\n        return done(err);\r\n      }\r\n\r\n      const result = r.message;\r\n\r\n      if (Array.isArray(result.documents) && result.documents.length === 1) {\r\n        const document = result.documents[0];\r\n\r\n        if (result.queryFailure) {\r\n          return done(new MongoError(document), null);\r\n        }\r\n\r\n        // Check if we have a command cursor\r\n        if (!cursor.cmd.find || (cursor.cmd.find && cursor.cmd.virtual === false)) {\r\n          // We have an error document, return the error\r\n          if (document.$err || document.errmsg) {\r\n            return done(new MongoError(document), null);\r\n          }\r\n\r\n          // We have a cursor document\r\n          if (document.cursor != null && typeof document.cursor !== 'string') {\r\n            const id = document.cursor.id;\r\n            // If we have a namespace change set the new namespace for getmores\r\n            if (document.cursor.ns) {\r\n              cursor.ns = document.cursor.ns;\r\n            }\r\n            // Promote id to long if needed\r\n            cursor.cursorState.cursorId = typeof id === 'number' ? Long.fromNumber(id) : id;\r\n            cursor.cursorState.lastCursorId = cursor.cursorState.cursorId;\r\n            cursor.cursorState.operationTime = document.operationTime;\r\n\r\n            // If we have a firstBatch set it\r\n            if (Array.isArray(document.cursor.firstBatch)) {\r\n              cursor.cursorState.documents = document.cursor.firstBatch; //.reverse();\r\n            }\r\n\r\n            // Return after processing command cursor\r\n            return done(null, result);\r\n          }\r\n        }\r\n      }\r\n\r\n      // Otherwise fall back to regular find path\r\n      const cursorId = result.cursorId || 0;\r\n      cursor.cursorState.cursorId = cursorId instanceof Long ? cursorId : Long.fromNumber(cursorId);\r\n      cursor.cursorState.documents = result.documents;\r\n      cursor.cursorState.lastCursorId = result.cursorId;\r\n\r\n      // Transform the results with passed in transformation method if provided\r\n      if (\r\n        cursor.cursorState.transforms &&\r\n        typeof cursor.cursorState.transforms.query === 'function'\r\n      ) {\r\n        cursor.cursorState.documents = cursor.cursorState.transforms.query(result);\r\n      }\r\n\r\n      done(null, result);\r\n    };\r\n\r\n    if (cursor.operation) {\r\n      if (cursor.logger.isDebug()) {\r\n        cursor.logger.debug(\r\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\r\n            cursor.query\r\n          )}]`\r\n        );\r\n      }\r\n\r\n      executeOperation(cursor.topology, cursor.operation, (err, result) => {\r\n        if (err) {\r\n          done(err);\r\n          return;\r\n        }\r\n\r\n        cursor.server = cursor.operation.server;\r\n        cursor.cursorState.init = true;\r\n\r\n        // NOTE: this is a special internal method for cloning a cursor, consider removing\r\n        if (cursor.cursorState.cursorId != null) {\r\n          return done();\r\n        }\r\n\r\n        queryCallback(err, result);\r\n      });\r\n\r\n      return;\r\n    }\r\n\r\n    // Very explicitly choose what is passed to selectServer\r\n    const serverSelectOptions = {};\r\n    if (cursor.cursorState.session) {\r\n      serverSelectOptions.session = cursor.cursorState.session;\r\n    }\r\n\r\n    if (cursor.operation) {\r\n      serverSelectOptions.readPreference = cursor.operation.readPreference;\r\n    } else if (cursor.options.readPreference) {\r\n      serverSelectOptions.readPreference = cursor.options.readPreference;\r\n    }\r\n\r\n    return cursor.topology.selectServer(serverSelectOptions, (err, server) => {\r\n      if (err) {\r\n        const disconnectHandler = cursor.disconnectHandler;\r\n        if (disconnectHandler != null) {\r\n          return disconnectHandler.addObjectAndMethod(\r\n            'cursor',\r\n            cursor,\r\n            'next',\r\n            [callback],\r\n            callback\r\n          );\r\n        }\r\n\r\n        return callback(err);\r\n      }\r\n\r\n      cursor.server = server;\r\n      cursor.cursorState.init = true;\r\n      if (collationNotSupported(cursor.server, cursor.cmd)) {\r\n        return callback(new MongoError(`server ${cursor.server.name} does not support collation`));\r\n      }\r\n\r\n      // NOTE: this is a special internal method for cloning a cursor, consider removing\r\n      if (cursor.cursorState.cursorId != null) {\r\n        return done();\r\n      }\r\n\r\n      if (cursor.logger.isDebug()) {\r\n        cursor.logger.debug(\r\n          `issue initial query [${JSON.stringify(cursor.cmd)}] with flags [${JSON.stringify(\r\n            cursor.query\r\n          )}]`\r\n        );\r\n      }\r\n\r\n      if (cursor.cmd.find != null) {\r\n        server.query(cursor.ns, cursor.cmd, cursor.cursorState, cursor.options, queryCallback);\r\n        return;\r\n      }\r\n\r\n      const commandOptions = Object.assign({ session: cursor.cursorState.session }, cursor.options);\r\n      server.command(cursor.ns, cursor.cmd, commandOptions, queryCallback);\r\n    });\r\n  }\r\n}\r\n\r\nif (SUPPORTS.ASYNC_ITERATOR) {\r\n  CoreCursor.prototype[Symbol.asyncIterator] = require('../async/async_iterator').asyncIterator;\r\n}\r\n\r\n/**\r\n * Validate if the pool is dead and return error\r\n */\r\nfunction isConnectionDead(self, callback) {\r\n  if (self.pool && self.pool.isDestroyed()) {\r\n    self.cursorState.killed = true;\r\n    const err = new MongoNetworkError(\r\n      `connection to host ${self.pool.host}:${self.pool.port} was destroyed`\r\n    );\r\n\r\n    _setCursorNotifiedImpl(self, () => callback(err));\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Validate if the cursor is dead but was not explicitly killed by user\r\n */\r\nfunction isCursorDeadButNotkilled(self, callback) {\r\n  // Cursor is dead but not marked killed, return null\r\n  if (self.cursorState.dead && !self.cursorState.killed) {\r\n    self.cursorState.killed = true;\r\n    setCursorNotified(self, callback);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Validate if the cursor is dead and was killed by user\r\n */\r\nfunction isCursorDeadAndKilled(self, callback) {\r\n  if (self.cursorState.dead && self.cursorState.killed) {\r\n    handleCallback(callback, new MongoError('cursor is dead'));\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Validate if the cursor was killed by the user\r\n */\r\nfunction isCursorKilled(self, callback) {\r\n  if (self.cursorState.killed) {\r\n    setCursorNotified(self, callback);\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Mark cursor as being dead and notified\r\n */\r\nfunction setCursorDeadAndNotified(self, callback) {\r\n  self.cursorState.dead = true;\r\n  setCursorNotified(self, callback);\r\n}\r\n\r\n/**\r\n * Mark cursor as being notified\r\n */\r\nfunction setCursorNotified(self, callback) {\r\n  _setCursorNotifiedImpl(self, () => handleCallback(callback, null, null));\r\n}\r\n\r\nfunction _setCursorNotifiedImpl(self, callback) {\r\n  self.cursorState.notified = true;\r\n  self.cursorState.documents = [];\r\n  self.cursorState.cursorIndex = 0;\r\n\r\n  if (self.cursorState.session) {\r\n    self._endSession(callback);\r\n    return;\r\n  }\r\n\r\n  return callback();\r\n}\r\n\r\nfunction nextFunction(self, callback) {\r\n  // We have notified about it\r\n  if (self.cursorState.notified) {\r\n    return callback(new Error('cursor is exhausted'));\r\n  }\r\n\r\n  // Cursor is killed return null\r\n  if (isCursorKilled(self, callback)) return;\r\n\r\n  // Cursor is dead but not marked killed, return null\r\n  if (isCursorDeadButNotkilled(self, callback)) return;\r\n\r\n  // We have a dead and killed cursor, attempting to call next should error\r\n  if (isCursorDeadAndKilled(self, callback)) return;\r\n\r\n  // We have just started the cursor\r\n  if (!self.cursorState.init) {\r\n    // Topology is not connected, save the call in the provided store to be\r\n    // Executed at some point when the handler deems it's reconnected\r\n    if (!self.topology.isConnected(self.options)) {\r\n      // Only need this for single server, because repl sets and mongos\r\n      // will always continue trying to reconnect\r\n      if (self.topology._type === 'server' && !self.topology.s.options.reconnect) {\r\n        // Reconnect is disabled, so we'll never reconnect\r\n        return callback(new MongoError('no connection available'));\r\n      }\r\n\r\n      if (self.disconnectHandler != null) {\r\n        if (self.topology.isDestroyed()) {\r\n          // Topology was destroyed, so don't try to wait for it to reconnect\r\n          return callback(new MongoError('Topology was destroyed'));\r\n        }\r\n\r\n        self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\r\n        return;\r\n      }\r\n    }\r\n\r\n    self._initializeCursor((err, result) => {\r\n      if (err || result === null) {\r\n        callback(err, result);\r\n        return;\r\n      }\r\n\r\n      nextFunction(self, callback);\r\n    });\r\n\r\n    return;\r\n  }\r\n\r\n  if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\r\n    // Ensure we kill the cursor on the server\r\n    self.kill(() =>\r\n      // Set cursor in dead and notified state\r\n      setCursorDeadAndNotified(self, callback)\r\n    );\r\n  } else if (\r\n    self.cursorState.cursorIndex === self.cursorState.documents.length &&\r\n    !Long.ZERO.equals(self.cursorState.cursorId)\r\n  ) {\r\n    // Ensure an empty cursor state\r\n    self.cursorState.documents = [];\r\n    self.cursorState.cursorIndex = 0;\r\n\r\n    // Check if topology is destroyed\r\n    if (self.topology.isDestroyed())\r\n      return callback(\r\n        new MongoNetworkError('connection destroyed, not possible to instantiate cursor')\r\n      );\r\n\r\n    // Check if connection is dead and return if not possible to\r\n    // execute a getMore on this connection\r\n    if (isConnectionDead(self, callback)) return;\r\n\r\n    // Execute the next get more\r\n    self._getMore(function(err, doc, connection) {\r\n      if (err) {\r\n        return handleCallback(callback, err);\r\n      }\r\n\r\n      // Save the returned connection to ensure all getMore's fire over the same connection\r\n      self.connection = connection;\r\n\r\n      // Tailable cursor getMore result, notify owner about it\r\n      // No attempt is made here to retry, this is left to the user of the\r\n      // core module to handle to keep core simple\r\n      if (\r\n        self.cursorState.documents.length === 0 &&\r\n        self.cmd.tailable &&\r\n        Long.ZERO.equals(self.cursorState.cursorId)\r\n      ) {\r\n        // No more documents in the tailed cursor\r\n        return handleCallback(\r\n          callback,\r\n          new MongoError({\r\n            message: 'No more documents in tailed cursor',\r\n            tailable: self.cmd.tailable,\r\n            awaitData: self.cmd.awaitData\r\n          })\r\n        );\r\n      } else if (\r\n        self.cursorState.documents.length === 0 &&\r\n        self.cmd.tailable &&\r\n        !Long.ZERO.equals(self.cursorState.cursorId)\r\n      ) {\r\n        return nextFunction(self, callback);\r\n      }\r\n\r\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\r\n        return setCursorDeadAndNotified(self, callback);\r\n      }\r\n\r\n      nextFunction(self, callback);\r\n    });\r\n  } else if (\r\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\r\n    self.cmd.tailable &&\r\n    Long.ZERO.equals(self.cursorState.cursorId)\r\n  ) {\r\n    return handleCallback(\r\n      callback,\r\n      new MongoError({\r\n        message: 'No more documents in tailed cursor',\r\n        tailable: self.cmd.tailable,\r\n        awaitData: self.cmd.awaitData\r\n      })\r\n    );\r\n  } else if (\r\n    self.cursorState.documents.length === self.cursorState.cursorIndex &&\r\n    Long.ZERO.equals(self.cursorState.cursorId)\r\n  ) {\r\n    setCursorDeadAndNotified(self, callback);\r\n  } else {\r\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\r\n      // Ensure we kill the cursor on the server\r\n      self.kill(() =>\r\n        // Set cursor in dead and notified state\r\n        setCursorDeadAndNotified(self, callback)\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    // Increment the current cursor limit\r\n    self.cursorState.currentLimit += 1;\r\n\r\n    // Get the document\r\n    let doc = self.cursorState.documents[self.cursorState.cursorIndex++];\r\n\r\n    // Doc overflow\r\n    if (!doc || doc.$err) {\r\n      // Ensure we kill the cursor on the server\r\n      self.kill(() =>\r\n        // Set cursor in dead and notified state\r\n        setCursorDeadAndNotified(self, function() {\r\n          handleCallback(callback, new MongoError(doc ? doc.$err : undefined));\r\n        })\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    // Transform the doc with passed in transformation method if provided\r\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc === 'function') {\r\n      doc = self.cursorState.transforms.doc(doc);\r\n    }\r\n\r\n    // Return the document\r\n    handleCallback(callback, null, doc);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  CursorState,\r\n  CoreCursor\r\n};\r\n"]},"metadata":{},"sourceType":"script"}