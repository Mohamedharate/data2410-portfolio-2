{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Wrap a Mongo error document in an Error instance\r\n * @ignore\r\n * @api private\r\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\r\n * @ignore\r\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\r\n * Create index name based on field spec\r\n *\r\n * @ignore\r\n * @api private\r\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\n/**\r\n * If there is no WriteConcern related options defined on target then inherit from source.\r\n * Otherwise, do not inherit **any** options from source.\r\n * @internal\r\n * @param {object} target - options object conditionally receiving the writeConcern options\r\n * @param {object} source - options object containing the potentially inherited writeConcern options\r\n */\n\nfunction conditionallyMergeWriteConcern(target, source) {\n  let found = false;\n\n  for (const wcKey of WRITE_CONCERN_KEYS) {\n    if (wcKey in target) {\n      // Found a writeConcern option\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (const wcKey of WRITE_CONCERN_KEYS) {\n      if (source[wcKey]) {\n        if (!('writeConcern' in target)) {\n          target.writeConcern = {};\n        }\n\n        target.writeConcern[wcKey] = source[wcKey];\n      }\n    }\n  }\n\n  return target;\n}\n/**\r\n * Executes the given operation with provided arguments.\r\n *\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param {object} topology The topology to execute this operation on\r\n * @param {function} operation The operation to execute\r\n * @param {array} args Arguments to apply the provided operation\r\n * @param {object} [options] Options that modify the behavior of the method\r\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\r\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\r\n *\r\n * @param {object} target The target command to which we will apply retryWrites.\r\n * @param {object} db The database from which we can inherit a retryWrites value.\r\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\r\n * Applies a write concern to a command based on well defined inheritance rules, optionally\r\n * detecting support for the write concern in the first place.\r\n *\r\n * @param {Object} target the target command we will be applying the write concern to\r\n * @param {Object} sources sources where we can inherit default write concerns from\r\n * @param {Object} [options] optional settings passed into a command for write concern overrides\r\n * @returns {Object} the (now) decorated target\r\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\r\n * Applies collation to a given command.\r\n *\r\n * @param {object} [command] the command on which to apply collation\r\n * @param {(Cursor|Collection)} [target] target of command\r\n * @param {object} [options] options containing collation settings\r\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n/**\r\n * Applies a read concern to a given command.\r\n *\r\n * @param {object} command the command on which to apply the read concern\r\n * @param {Collection} coll the parent collection of the operation calling this method\r\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n/**\r\n * Applies an explain to a given command.\r\n * @internal\r\n *\r\n * @param {object} command - the command on which to apply the explain\r\n * @param {Explain} explain - the options containing the explain verbosity\r\n * @return the new command\r\n */\n\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\n\nconst emitProcessWarning = msg => nodejsMajorVersion <= 6 ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE) : process.emitWarning(msg, {\n  type: 'DeprecationWarning',\n  code: MONGODB_WARNING_CODE\n}); // eslint-disable-next-line no-console\n\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\r\n * Default message handler for generating deprecation warnings.\r\n *\r\n * @param {string} name function name\r\n * @param {string} option option name\r\n * @return {string} warning message\r\n * @ignore\r\n * @api private\r\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n/**\r\n * Deprecates a given function's options.\r\n *\r\n * @param {object} config configuration for deprecation\r\n * @param {string} config.name function name\r\n * @param {Array} config.deprecatedOptions options to deprecate\r\n * @param {number} config.optionsIndex index of options object in function arguments array\r\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\r\n * @param {function} fn the target function of deprecation\r\n * @return {function} modified function that warns once per deprecated option, and executes original function\r\n * @ignore\r\n * @api private\r\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n/**\r\n * Helper function for either accepting a callback, or returning a promise\r\n *\r\n * @param {Object} parent an instance of parent with promiseLibrary.\r\n * @param {object} parent.s an object containing promiseLibrary.\r\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\r\n * @param {[Function]} callback an optional callback.\r\n * @param {Function} fn A function that takes a callback\r\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\r\n */\n\n\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    callback(err, res);\n  });\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n/**\r\n * Creates an interval timer which is able to be woken up sooner than\r\n * the interval. The timer will also debounce multiple calls to wake\r\n * ensuring that the function is only ever called once within a minimum\r\n * interval window.\r\n *\r\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\r\n * @param {object} [options] Optional settings\r\n * @param {number} [options.interval] The interval at which to run the provided function\r\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\r\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\r\n */\n\n\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  return Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON()).map(k => k[0]).indexOf('$') >= 0;\n}\n/**\r\n * When the driver used emitWarning the code will be equal to this.\r\n * @public\r\n *\r\n * @example\r\n * ```js\r\n * process.on('warning', (warning) => {\r\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\r\n * })\r\n * ```\r\n */\n\n\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/**\r\n * @internal\r\n * @param {string} message - message to warn about\r\n */\n\nfunction emitWarning(message) {\n  if (process.emitWarning) {\n    return nodejsMajorVersion <= 6 ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE) : process.emitWarning(message, {\n      code: MONGODB_WARNING_CODE\n    });\n  } else {\n    // Approximate the style of print out on node versions pre 8.x\n    // eslint-disable-next-line no-console\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\n  }\n}\n\nconst emittedWarnings = new Set();\n/**\r\n * Will emit a warning once for the duration of the application.\r\n * Uses the message to identify if it has already been emitted\r\n * so using string interpolation can cause multiple emits\r\n * @internal\r\n * @param {string} message - message to warn about\r\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  conditionallyMergeWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  decorateWithExplain,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators,\n  MONGODB_WARNING_CODE,\n  emitWarning,\n  emitWarningOnce\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/utils.js"],"names":["MongoError","require","WriteConcern","shallowClone","obj","copy","name","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Array","isArray","length","i","constructor","String","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","keys","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","k","key","join","arg","prototype","toString","call","debugOptions","debugFields","options","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","WRITE_CONCERN_KEYS","conditionallyMergeWriteConcern","found","wcKey","writeConcern","executeLegacyOperation","topology","operation","args","TypeError","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","decorateWithExplain","explain","verbosity","nodejsMajorVersion","version","split","substring","emitProcessWarning","emitWarning","MONGODB_WARNING_CODE","type","code","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","makeCounter","seed","count","newCount","parent","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","reduce","u","toBSON","map","undefined","emittedWarnings","emitWarningOnce","module","MAX_JS_INT","Number","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["'use strict';\r\nconst MongoError = require('./core/error').MongoError;\r\nconst WriteConcern = require('./write_concern');\r\n\r\nvar shallowClone = function(obj) {\r\n  var copy = {};\r\n  for (var name in obj) copy[name] = obj[name];\r\n  return copy;\r\n};\r\n\r\n// Set simple property\r\nvar getSingleProperty = function(obj, name, value) {\r\n  Object.defineProperty(obj, name, {\r\n    enumerable: true,\r\n    get: function() {\r\n      return value;\r\n    }\r\n  });\r\n};\r\n\r\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\r\n  var value = ('' + sortDirection).toLowerCase();\r\n\r\n  switch (value) {\r\n    case 'ascending':\r\n    case 'asc':\r\n    case '1':\r\n      return 1;\r\n    case 'descending':\r\n    case 'desc':\r\n    case '-1':\r\n      return -1;\r\n    default:\r\n      throw new Error(\r\n        'Illegal sort clause, must be of the form ' +\r\n          \"[['field1', '(ascending|descending)'], \" +\r\n          \"['field2', '(ascending|descending)']]\"\r\n      );\r\n  }\r\n});\r\n\r\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\r\n  var orderBy = {};\r\n  if (sortValue == null) return null;\r\n  if (Array.isArray(sortValue)) {\r\n    if (sortValue.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    for (var i = 0; i < sortValue.length; i++) {\r\n      if (sortValue[i].constructor === String) {\r\n        orderBy[sortValue[i]] = 1;\r\n      } else {\r\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\r\n      }\r\n    }\r\n  } else if (sortValue != null && typeof sortValue === 'object') {\r\n    orderBy = sortValue;\r\n  } else if (typeof sortValue === 'string') {\r\n    orderBy[sortValue] = 1;\r\n  } else {\r\n    throw new Error(\r\n      'Illegal sort clause, must be of the form ' +\r\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\r\n    );\r\n  }\r\n\r\n  return orderBy;\r\n});\r\n\r\nvar checkCollectionName = function checkCollectionName(collectionName) {\r\n  if ('string' !== typeof collectionName) {\r\n    throw new MongoError('collection name must be a String');\r\n  }\r\n\r\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\r\n    throw new MongoError('collection names cannot be empty');\r\n  }\r\n\r\n  if (\r\n    collectionName.indexOf('$') !== -1 &&\r\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\r\n  ) {\r\n    throw new MongoError(\"collection names must not contain '$'\");\r\n  }\r\n\r\n  if (collectionName.match(/^\\.|\\.$/) != null) {\r\n    throw new MongoError(\"collection names must not start or end with '.'\");\r\n  }\r\n\r\n  // Validate that we are not passing 0x00 in the collection name\r\n  if (collectionName.indexOf('\\x00') !== -1) {\r\n    throw new MongoError('collection names cannot contain a null character');\r\n  }\r\n};\r\n\r\nvar handleCallback = function(callback, err, value1, value2) {\r\n  try {\r\n    if (callback == null) return;\r\n\r\n    if (callback) {\r\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\r\n    }\r\n  } catch (err) {\r\n    process.nextTick(function() {\r\n      throw err;\r\n    });\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Wrap a Mongo error document in an Error instance\r\n * @ignore\r\n * @api private\r\n */\r\nvar toError = function(error) {\r\n  if (error instanceof Error) return error;\r\n\r\n  var msg = error.err || error.errmsg || error.errMessage || error;\r\n  var e = MongoError.create({ message: msg, driver: true });\r\n\r\n  // Get all object keys\r\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\r\n\r\n  for (var i = 0; i < keys.length; i++) {\r\n    try {\r\n      e[keys[i]] = error[keys[i]];\r\n    } catch (err) {\r\n      // continue\r\n    }\r\n  }\r\n\r\n  return e;\r\n};\r\n\r\n/**\r\n * @ignore\r\n */\r\nvar normalizeHintField = function normalizeHintField(hint) {\r\n  var finalHint = null;\r\n\r\n  if (typeof hint === 'string') {\r\n    finalHint = hint;\r\n  } else if (Array.isArray(hint)) {\r\n    finalHint = {};\r\n\r\n    hint.forEach(function(param) {\r\n      finalHint[param] = 1;\r\n    });\r\n  } else if (hint != null && typeof hint === 'object') {\r\n    finalHint = {};\r\n    for (var name in hint) {\r\n      finalHint[name] = hint[name];\r\n    }\r\n  }\r\n\r\n  return finalHint;\r\n};\r\n\r\n/**\r\n * Create index name based on field spec\r\n *\r\n * @ignore\r\n * @api private\r\n */\r\nvar parseIndexOptions = function(fieldOrSpec) {\r\n  var fieldHash = {};\r\n  var indexes = [];\r\n  var keys;\r\n\r\n  // Get all the fields accordingly\r\n  if ('string' === typeof fieldOrSpec) {\r\n    // 'type'\r\n    indexes.push(fieldOrSpec + '_' + 1);\r\n    fieldHash[fieldOrSpec] = 1;\r\n  } else if (Array.isArray(fieldOrSpec)) {\r\n    fieldOrSpec.forEach(function(f) {\r\n      if ('string' === typeof f) {\r\n        // [{location:'2d'}, 'type']\r\n        indexes.push(f + '_' + 1);\r\n        fieldHash[f] = 1;\r\n      } else if (Array.isArray(f)) {\r\n        // [['location', '2d'],['type', 1]]\r\n        indexes.push(f[0] + '_' + (f[1] || 1));\r\n        fieldHash[f[0]] = f[1] || 1;\r\n      } else if (isObject(f)) {\r\n        // [{location:'2d'}, {type:1}]\r\n        keys = Object.keys(f);\r\n        keys.forEach(function(k) {\r\n          indexes.push(k + '_' + f[k]);\r\n          fieldHash[k] = f[k];\r\n        });\r\n      } else {\r\n        // undefined (ignore)\r\n      }\r\n    });\r\n  } else if (isObject(fieldOrSpec)) {\r\n    // {location:'2d', type:1}\r\n    keys = Object.keys(fieldOrSpec);\r\n    keys.forEach(function(key) {\r\n      indexes.push(key + '_' + fieldOrSpec[key]);\r\n      fieldHash[key] = fieldOrSpec[key];\r\n    });\r\n  }\r\n\r\n  return {\r\n    name: indexes.join('_'),\r\n    keys: keys,\r\n    fieldHash: fieldHash\r\n  };\r\n};\r\n\r\nvar isObject = (exports.isObject = function(arg) {\r\n  return '[object Object]' === Object.prototype.toString.call(arg);\r\n});\r\n\r\nvar debugOptions = function(debugFields, options) {\r\n  var finaloptions = {};\r\n  debugFields.forEach(function(n) {\r\n    finaloptions[n] = options[n];\r\n  });\r\n\r\n  return finaloptions;\r\n};\r\n\r\nvar decorateCommand = function(command, options, exclude) {\r\n  for (var name in options) {\r\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\r\n  }\r\n\r\n  return command;\r\n};\r\n\r\nvar mergeOptions = function(target, source) {\r\n  for (var name in source) {\r\n    target[name] = source[name];\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\n// Merge options with translation\r\nvar translateOptions = function(target, source) {\r\n  var translations = {\r\n    // SSL translation options\r\n    sslCA: 'ca',\r\n    sslCRL: 'crl',\r\n    sslValidate: 'rejectUnauthorized',\r\n    sslKey: 'key',\r\n    sslCert: 'cert',\r\n    sslPass: 'passphrase',\r\n    // SocketTimeout translation options\r\n    socketTimeoutMS: 'socketTimeout',\r\n    connectTimeoutMS: 'connectionTimeout',\r\n    // Replicaset options\r\n    replicaSet: 'setName',\r\n    rs_name: 'setName',\r\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\r\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\r\n    // Mongos options\r\n    acceptableLatencyMS: 'localThresholdMS'\r\n  };\r\n\r\n  for (var name in source) {\r\n    if (translations[name]) {\r\n      target[translations[name]] = source[name];\r\n    } else {\r\n      target[name] = source[name];\r\n    }\r\n  }\r\n\r\n  return target;\r\n};\r\n\r\nvar filterOptions = function(options, names) {\r\n  var filterOptions = {};\r\n\r\n  for (var name in options) {\r\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\r\n  }\r\n\r\n  // Filtered options\r\n  return filterOptions;\r\n};\r\n\r\n// Write concern keys\r\nconst WRITE_CONCERN_KEYS = ['w', 'j', 'wtimeout', 'fsync', 'writeConcern'];\r\n\r\n/**\r\n * If there is no WriteConcern related options defined on target then inherit from source.\r\n * Otherwise, do not inherit **any** options from source.\r\n * @internal\r\n * @param {object} target - options object conditionally receiving the writeConcern options\r\n * @param {object} source - options object containing the potentially inherited writeConcern options\r\n */\r\nfunction conditionallyMergeWriteConcern(target, source) {\r\n  let found = false;\r\n  for (const wcKey of WRITE_CONCERN_KEYS) {\r\n    if (wcKey in target) {\r\n      // Found a writeConcern option\r\n      found = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (!found) {\r\n    for (const wcKey of WRITE_CONCERN_KEYS) {\r\n      if (source[wcKey]) {\r\n        if (!('writeConcern' in target)) {\r\n          target.writeConcern = {};\r\n        }\r\n        target.writeConcern[wcKey] = source[wcKey];\r\n      }\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Executes the given operation with provided arguments.\r\n *\r\n * This method reduces large amounts of duplication in the entire codebase by providing\r\n * a single point for determining whether callbacks or promises should be used. Additionally\r\n * it allows for a single point of entry to provide features such as implicit sessions, which\r\n * are required by the Driver Sessions specification in the event that a ClientSession is\r\n * not provided\r\n *\r\n * @param {object} topology The topology to execute this operation on\r\n * @param {function} operation The operation to execute\r\n * @param {array} args Arguments to apply the provided operation\r\n * @param {object} [options] Options that modify the behavior of the method\r\n */\r\nconst executeLegacyOperation = (topology, operation, args, options) => {\r\n  if (topology == null) {\r\n    throw new TypeError('This method requires a valid topology instance');\r\n  }\r\n\r\n  if (!Array.isArray(args)) {\r\n    throw new TypeError('This method requires an array of arguments to apply');\r\n  }\r\n\r\n  options = options || {};\r\n  const Promise = topology.s.promiseLibrary;\r\n  let callback = args[args.length - 1];\r\n\r\n  // The driver sessions spec mandates that we implicitly create sessions for operations\r\n  // that are not explicitly provided with a session.\r\n  let session, opOptions, owner;\r\n  if (!options.skipSessions && topology.hasSessionSupport()) {\r\n    opOptions = args[args.length - 2];\r\n    if (opOptions == null || opOptions.session == null) {\r\n      owner = Symbol();\r\n      session = topology.startSession({ owner });\r\n      const optionsIndex = args.length - 2;\r\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\r\n    } else if (opOptions.session && opOptions.session.hasEnded) {\r\n      throw new MongoError('Use of expired sessions is not permitted');\r\n    }\r\n  }\r\n\r\n  const makeExecuteCallback = (resolve, reject) =>\r\n    function executeCallback(err, result) {\r\n      if (session && session.owner === owner && !options.returnsCursor) {\r\n        session.endSession(() => {\r\n          delete opOptions.session;\r\n          if (err) return reject(err);\r\n          resolve(result);\r\n        });\r\n      } else {\r\n        if (err) return reject(err);\r\n        resolve(result);\r\n      }\r\n    };\r\n\r\n  // Execute using callback\r\n  if (typeof callback === 'function') {\r\n    callback = args.pop();\r\n    const handler = makeExecuteCallback(\r\n      result => callback(null, result),\r\n      err => callback(err, null)\r\n    );\r\n    args.push(handler);\r\n\r\n    try {\r\n      return operation.apply(null, args);\r\n    } catch (e) {\r\n      handler(e);\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  // Return a Promise\r\n  if (args[args.length - 1] != null) {\r\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\r\n  }\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    const handler = makeExecuteCallback(resolve, reject);\r\n    args[args.length - 1] = handler;\r\n\r\n    try {\r\n      return operation.apply(null, args);\r\n    } catch (e) {\r\n      handler(e);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\r\n *\r\n * @param {object} target The target command to which we will apply retryWrites.\r\n * @param {object} db The database from which we can inherit a retryWrites value.\r\n */\r\nfunction applyRetryableWrites(target, db) {\r\n  if (db && db.s.options.retryWrites) {\r\n    target.retryWrites = true;\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Applies a write concern to a command based on well defined inheritance rules, optionally\r\n * detecting support for the write concern in the first place.\r\n *\r\n * @param {Object} target the target command we will be applying the write concern to\r\n * @param {Object} sources sources where we can inherit default write concerns from\r\n * @param {Object} [options] optional settings passed into a command for write concern overrides\r\n * @returns {Object} the (now) decorated target\r\n */\r\nfunction applyWriteConcern(target, sources, options) {\r\n  options = options || {};\r\n  const db = sources.db;\r\n  const coll = sources.collection;\r\n\r\n  if (options.session && options.session.inTransaction()) {\r\n    // writeConcern is not allowed within a multi-statement transaction\r\n    if (target.writeConcern) {\r\n      delete target.writeConcern;\r\n    }\r\n\r\n    return target;\r\n  }\r\n\r\n  const writeConcern = WriteConcern.fromOptions(options);\r\n  if (writeConcern) {\r\n    return Object.assign(target, { writeConcern });\r\n  }\r\n\r\n  if (coll && coll.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\r\n  }\r\n\r\n  if (db && db.writeConcern) {\r\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\r\nfunction isPromiseLike(maybePromise) {\r\n  return maybePromise && typeof maybePromise.then === 'function';\r\n}\r\n\r\n/**\r\n * Applies collation to a given command.\r\n *\r\n * @param {object} [command] the command on which to apply collation\r\n * @param {(Cursor|Collection)} [target] target of command\r\n * @param {object} [options] options containing collation settings\r\n */\r\nfunction decorateWithCollation(command, target, options) {\r\n  const topology = (target.s && target.s.topology) || target.topology;\r\n\r\n  if (!topology) {\r\n    throw new TypeError('parameter \"target\" is missing a topology');\r\n  }\r\n\r\n  const capabilities = topology.capabilities();\r\n  if (options.collation && typeof options.collation === 'object') {\r\n    if (capabilities && capabilities.commandsTakeCollation) {\r\n      command.collation = options.collation;\r\n    } else {\r\n      throw new MongoError(`Current topology does not support collation`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Applies a read concern to a given command.\r\n *\r\n * @param {object} command the command on which to apply the read concern\r\n * @param {Collection} coll the parent collection of the operation calling this method\r\n */\r\nfunction decorateWithReadConcern(command, coll, options) {\r\n  if (options && options.session && options.session.inTransaction()) {\r\n    return;\r\n  }\r\n  let readConcern = Object.assign({}, command.readConcern || {});\r\n  if (coll.s.readConcern) {\r\n    Object.assign(readConcern, coll.s.readConcern);\r\n  }\r\n\r\n  if (Object.keys(readConcern).length > 0) {\r\n    Object.assign(command, { readConcern: readConcern });\r\n  }\r\n}\r\n\r\n/**\r\n * Applies an explain to a given command.\r\n * @internal\r\n *\r\n * @param {object} command - the command on which to apply the explain\r\n * @param {Explain} explain - the options containing the explain verbosity\r\n * @return the new command\r\n */\r\nfunction decorateWithExplain(command, explain) {\r\n  if (command.explain) {\r\n    return command;\r\n  }\r\n\r\n  return { explain: command, verbosity: explain.verbosity };\r\n}\r\n\r\nconst nodejsMajorVersion = +process.version.split('.')[0].substring(1);\r\nconst emitProcessWarning = msg =>\r\n  nodejsMajorVersion <= 6\r\n    ? process.emitWarning(msg, 'DeprecationWarning', MONGODB_WARNING_CODE)\r\n    : process.emitWarning(msg, { type: 'DeprecationWarning', code: MONGODB_WARNING_CODE });\r\n// eslint-disable-next-line no-console\r\nconst emitConsoleWarning = msg => console.error(msg);\r\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\r\n\r\n/**\r\n * Default message handler for generating deprecation warnings.\r\n *\r\n * @param {string} name function name\r\n * @param {string} option option name\r\n * @return {string} warning message\r\n * @ignore\r\n * @api private\r\n */\r\nfunction defaultMsgHandler(name, option) {\r\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\r\n}\r\n\r\n/**\r\n * Deprecates a given function's options.\r\n *\r\n * @param {object} config configuration for deprecation\r\n * @param {string} config.name function name\r\n * @param {Array} config.deprecatedOptions options to deprecate\r\n * @param {number} config.optionsIndex index of options object in function arguments array\r\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\r\n * @param {function} fn the target function of deprecation\r\n * @return {function} modified function that warns once per deprecated option, and executes original function\r\n * @ignore\r\n * @api private\r\n */\r\nfunction deprecateOptions(config, fn) {\r\n  if (process.noDeprecation === true) {\r\n    return fn;\r\n  }\r\n\r\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\r\n\r\n  const optionsWarned = new Set();\r\n  function deprecated() {\r\n    const options = arguments[config.optionsIndex];\r\n\r\n    // ensure options is a valid, non-empty object, otherwise short-circuit\r\n    if (!isObject(options) || Object.keys(options).length === 0) {\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    config.deprecatedOptions.forEach(deprecatedOption => {\r\n      if (\r\n        Object.prototype.hasOwnProperty.call(options, deprecatedOption) &&\r\n        !optionsWarned.has(deprecatedOption)\r\n      ) {\r\n        optionsWarned.add(deprecatedOption);\r\n        const msg = msgHandler(config.name, deprecatedOption);\r\n        emitDeprecationWarning(msg);\r\n        if (this && this.getLogger) {\r\n          const logger = this.getLogger();\r\n          if (logger) {\r\n            logger.warn(msg);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return fn.apply(this, arguments);\r\n  }\r\n\r\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\r\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\r\n  Object.setPrototypeOf(deprecated, fn);\r\n  if (fn.prototype) {\r\n    // Setting this (rather than using Object.setPrototype, as above) ensures\r\n    // that calling the unwrapped constructor gives an instanceof the wrapped\r\n    // constructor.\r\n    deprecated.prototype = fn.prototype;\r\n  }\r\n\r\n  return deprecated;\r\n}\r\n\r\nconst SUPPORTS = {};\r\n// Test asyncIterator support\r\ntry {\r\n  require('./async/async_iterator');\r\n  SUPPORTS.ASYNC_ITERATOR = true;\r\n} catch (e) {\r\n  SUPPORTS.ASYNC_ITERATOR = false;\r\n}\r\n\r\nclass MongoDBNamespace {\r\n  constructor(db, collection) {\r\n    this.db = db;\r\n    this.collection = collection;\r\n  }\r\n\r\n  toString() {\r\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\r\n  }\r\n\r\n  withCollection(collection) {\r\n    return new MongoDBNamespace(this.db, collection);\r\n  }\r\n\r\n  static fromString(namespace) {\r\n    if (!namespace) {\r\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\r\n    }\r\n\r\n    const index = namespace.indexOf('.');\r\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\r\n  }\r\n}\r\n\r\nfunction* makeCounter(seed) {\r\n  let count = seed || 0;\r\n  while (true) {\r\n    const newCount = count;\r\n    count += 1;\r\n    yield newCount;\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function for either accepting a callback, or returning a promise\r\n *\r\n * @param {Object} parent an instance of parent with promiseLibrary.\r\n * @param {object} parent.s an object containing promiseLibrary.\r\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\r\n * @param {[Function]} callback an optional callback.\r\n * @param {Function} fn A function that takes a callback\r\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\r\n */\r\nfunction maybePromise(parent, callback, fn) {\r\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\r\n\r\n  let result;\r\n  if (typeof callback !== 'function') {\r\n    result = new PromiseLibrary((resolve, reject) => {\r\n      callback = (err, res) => {\r\n        if (err) return reject(err);\r\n        resolve(res);\r\n      };\r\n    });\r\n  }\r\n\r\n  fn(function(err, res) {\r\n    if (err != null) {\r\n      try {\r\n        callback(err);\r\n      } catch (error) {\r\n        return process.nextTick(() => {\r\n          throw error;\r\n        });\r\n      }\r\n      return;\r\n    }\r\n\r\n    callback(err, res);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction now() {\r\n  const hrtime = process.hrtime();\r\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\r\n}\r\n\r\nfunction calculateDurationInMs(started) {\r\n  if (typeof started !== 'number') {\r\n    throw TypeError('numeric value required to calculate duration');\r\n  }\r\n\r\n  const elapsed = now() - started;\r\n  return elapsed < 0 ? 0 : elapsed;\r\n}\r\n\r\n/**\r\n * Creates an interval timer which is able to be woken up sooner than\r\n * the interval. The timer will also debounce multiple calls to wake\r\n * ensuring that the function is only ever called once within a minimum\r\n * interval window.\r\n *\r\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\r\n * @param {object} [options] Optional settings\r\n * @param {number} [options.interval] The interval at which to run the provided function\r\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\r\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\r\n */\r\nfunction makeInterruptableAsyncInterval(fn, options) {\r\n  let timerId;\r\n  let lastCallTime;\r\n  let lastWakeTime;\r\n  let stopped = false;\r\n\r\n  options = options || {};\r\n  const interval = options.interval || 1000;\r\n  const minInterval = options.minInterval || 500;\r\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\r\n  const clock = typeof options.clock === 'function' ? options.clock : now;\r\n\r\n  function wake() {\r\n    const currentTime = clock();\r\n    const timeSinceLastWake = currentTime - lastWakeTime;\r\n    const timeSinceLastCall = currentTime - lastCallTime;\r\n    const timeUntilNextCall = interval - timeSinceLastCall;\r\n    lastWakeTime = currentTime;\r\n\r\n    // For the streaming protocol: there is nothing obviously stopping this\r\n    // interval from being woken up again while we are waiting \"infinitely\"\r\n    // for `fn` to be called again`. Since the function effectively\r\n    // never completes, the `timeUntilNextCall` will continue to grow\r\n    // negatively unbounded, so it will never trigger a reschedule here.\r\n\r\n    // debounce multiple calls to wake within the `minInterval`\r\n    if (timeSinceLastWake < minInterval) {\r\n      return;\r\n    }\r\n\r\n    // reschedule a call as soon as possible, ensuring the call never happens\r\n    // faster than the `minInterval`\r\n    if (timeUntilNextCall > minInterval) {\r\n      reschedule(minInterval);\r\n    }\r\n\r\n    // This is possible in virtualized environments like AWS Lambda where our\r\n    // clock is unreliable. In these cases the timer is \"running\" but never\r\n    // actually completes, so we want to execute immediately and then attempt\r\n    // to reschedule.\r\n    if (timeUntilNextCall < 0) {\r\n      executeAndReschedule();\r\n    }\r\n  }\r\n\r\n  function stop() {\r\n    stopped = true;\r\n    if (timerId) {\r\n      clearTimeout(timerId);\r\n      timerId = null;\r\n    }\r\n\r\n    lastCallTime = 0;\r\n    lastWakeTime = 0;\r\n  }\r\n\r\n  function reschedule(ms) {\r\n    if (stopped) return;\r\n    clearTimeout(timerId);\r\n    timerId = setTimeout(executeAndReschedule, ms || interval);\r\n  }\r\n\r\n  function executeAndReschedule() {\r\n    lastWakeTime = 0;\r\n    lastCallTime = clock();\r\n\r\n    fn(err => {\r\n      if (err) throw err;\r\n      reschedule(interval);\r\n    });\r\n  }\r\n\r\n  if (immediate) {\r\n    executeAndReschedule();\r\n  } else {\r\n    lastCallTime = clock();\r\n    reschedule();\r\n  }\r\n\r\n  return { wake, stop };\r\n}\r\n\r\nfunction hasAtomicOperators(doc) {\r\n  if (Array.isArray(doc)) {\r\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\r\n  }\r\n\r\n  return (\r\n    Object.keys(typeof doc.toBSON !== 'function' ? doc : doc.toBSON())\r\n      .map(k => k[0])\r\n      .indexOf('$') >= 0\r\n  );\r\n}\r\n\r\n/**\r\n * When the driver used emitWarning the code will be equal to this.\r\n * @public\r\n *\r\n * @example\r\n * ```js\r\n * process.on('warning', (warning) => {\r\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\r\n * })\r\n * ```\r\n */\r\nconst MONGODB_WARNING_CODE = 'MONGODB DRIVER';\r\n\r\n/**\r\n * @internal\r\n * @param {string} message - message to warn about\r\n */\r\nfunction emitWarning(message) {\r\n  if (process.emitWarning) {\r\n    return nodejsMajorVersion <= 6\r\n      ? process.emitWarning(message, undefined, MONGODB_WARNING_CODE)\r\n      : process.emitWarning(message, { code: MONGODB_WARNING_CODE });\r\n  } else {\r\n    // Approximate the style of print out on node versions pre 8.x\r\n    // eslint-disable-next-line no-console\r\n    return console.error(`[${MONGODB_WARNING_CODE}] Warning:`, message);\r\n  }\r\n}\r\n\r\nconst emittedWarnings = new Set();\r\n/**\r\n * Will emit a warning once for the duration of the application.\r\n * Uses the message to identify if it has already been emitted\r\n * so using string interpolation can cause multiple emits\r\n * @internal\r\n * @param {string} message - message to warn about\r\n */\r\nfunction emitWarningOnce(message) {\r\n  if (!emittedWarnings.has(message)) {\r\n    emittedWarnings.add(message);\r\n    return emitWarning(message);\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  filterOptions,\r\n  mergeOptions,\r\n  translateOptions,\r\n  shallowClone,\r\n  getSingleProperty,\r\n  checkCollectionName,\r\n  toError,\r\n  formattedOrderClause,\r\n  parseIndexOptions,\r\n  normalizeHintField,\r\n  handleCallback,\r\n  decorateCommand,\r\n  isObject,\r\n  debugOptions,\r\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\r\n  conditionallyMergeWriteConcern,\r\n  executeLegacyOperation,\r\n  applyRetryableWrites,\r\n  applyWriteConcern,\r\n  isPromiseLike,\r\n  decorateWithCollation,\r\n  decorateWithReadConcern,\r\n  decorateWithExplain,\r\n  deprecateOptions,\r\n  SUPPORTS,\r\n  MongoDBNamespace,\r\n  emitDeprecationWarning,\r\n  makeCounter,\r\n  maybePromise,\r\n  now,\r\n  calculateDurationInMs,\r\n  makeInterruptableAsyncInterval,\r\n  hasAtomicOperators,\r\n  MONGODB_WARNING_CODE,\r\n  emitWarning,\r\n  emitWarningOnce\r\n};\r\n"]},"metadata":{},"sourceType":"script"}