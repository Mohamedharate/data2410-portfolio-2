{"ast":null,"code":"'use strict';\n\nconst os = require('os');\n\nconst crypto = require('crypto');\n\nconst requireOptional = require('optional-require')(require);\n/**\r\n * Generate a UUIDv4\r\n */\n\n\nconst uuidV4 = () => {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n};\n/**\r\n * Relays events for a given listener and emitter\r\n *\r\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\r\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\r\n */\n\n\nfunction relayEvents(listener, emitter, events) {\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\n}\n\nfunction retrieveKerberos() {\n  let kerberos;\n\n  try {\n    kerberos = requireOptional('kerberos');\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\n    }\n\n    throw err;\n  }\n\n  return kerberos;\n} // Throw an error if an attempt to use EJSON is made when it is not installed\n\n\nconst noEJSONError = function () {\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\n}; // Facilitate loading EJSON optionally\n\n\nfunction retrieveEJSON() {\n  let EJSON = requireOptional('mongodb-extjson');\n\n  if (!EJSON) {\n    EJSON = {\n      parse: noEJSONError,\n      deserialize: noEJSONError,\n      serialize: noEJSONError,\n      stringify: noEJSONError,\n      setBSONModule: noEJSONError,\n      BSON: noEJSONError\n    };\n  }\n\n  return EJSON;\n}\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology\r\n * instances\r\n *\r\n * @private\r\n * @param {(Topology|Server)} topologyOrServer\r\n */\n\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n/*\r\n * Checks that collation is supported by server.\r\n *\r\n * @param {Server} [server] to check against\r\n * @param {object} [cmd] object where collation may be specified\r\n * @param {function} [callback] callback function\r\n * @return true if server does not support collation\r\n */\n\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n *\r\n * @param {array} arr an array of items to asynchronusly iterate over\r\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param {function} callback The callback called after every item has been iterated\r\n */\n\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nfunction isUnifiedTopology(topology) {\n  return topology.description != null;\n}\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nfunction tagsStrictEqual(tags, tags2) {\n  const tagsKeys = Object.keys(tags);\n  const tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\n}\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new TypeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nfunction makeClientMetadata(options) {\n  options = options || {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: require('../../package.json').version\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `'Node.js ${process.version}, ${os.endianness} (${options.useUnifiedTopology ? 'unified' : 'legacy'})`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appname) {\n    // MongoDB requires the appname not exceed a byte length of 128\n    const buffer = Buffer.from(options.appname);\n    metadata.application = {\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\n    };\n  }\n\n  return metadata;\n}\n\nconst noop = () => {};\n\nmodule.exports = {\n  uuidV4,\n  relayEvents,\n  collationNotSupported,\n  retrieveEJSON,\n  retrieveKerberos,\n  maxWireVersion,\n  isPromiseLike,\n  eachAsync,\n  eachAsyncSeries,\n  isUnifiedTopology,\n  arrayStrictEqual,\n  tagsStrictEqual,\n  errorStrictEqual,\n  makeStateMachine,\n  makeClientMetadata,\n  noop\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/core/utils.js"],"names":["os","require","crypto","requireOptional","uuidV4","result","randomBytes","relayEvents","listener","emitter","events","forEach","eventName","on","event","emit","retrieveKerberos","kerberos","err","code","Error","noEJSONError","retrieveEJSON","EJSON","parse","deserialize","serialize","stringify","setBSONModule","BSON","maxWireVersion","topologyOrServer","ismaster","lastIsMaster","description","collationNotSupported","server","cmd","collation","isPromiseLike","maybePromise","then","eachAsync","arr","eachFn","callback","idx","awaiting","length","eachCallback","eachAsyncSeries","isUnifiedTopology","topology","arrayStrictEqual","arr2","Array","isArray","every","elt","tagsStrictEqual","tags","tags2","tagsKeys","Object","keys","tags2Keys","key","errorStrictEqual","lhs","rhs","constructor","name","message","makeStateMachine","stateTable","stateTransition","target","newState","legalStates","s","state","indexOf","TypeError","makeClientMetadata","options","metadata","driver","version","type","process","platform","architecture","arch","release","endianness","useUnifiedTopology","driverInfo","appname","buffer","Buffer","from","application","slice","toString","noop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst os = require('os');\r\nconst crypto = require('crypto');\r\nconst requireOptional = require('optional-require')(require);\r\n\r\n/**\r\n * Generate a UUIDv4\r\n */\r\nconst uuidV4 = () => {\r\n  const result = crypto.randomBytes(16);\r\n  result[6] = (result[6] & 0x0f) | 0x40;\r\n  result[8] = (result[8] & 0x3f) | 0x80;\r\n  return result;\r\n};\r\n\r\n/**\r\n * Relays events for a given listener and emitter\r\n *\r\n * @param {EventEmitter} listener the EventEmitter to listen to the events from\r\n * @param {EventEmitter} emitter the EventEmitter to relay the events to\r\n */\r\nfunction relayEvents(listener, emitter, events) {\r\n  events.forEach(eventName => listener.on(eventName, event => emitter.emit(eventName, event)));\r\n}\r\n\r\nfunction retrieveKerberos() {\r\n  let kerberos;\r\n\r\n  try {\r\n    kerberos = requireOptional('kerberos');\r\n  } catch (err) {\r\n    if (err.code === 'MODULE_NOT_FOUND') {\r\n      throw new Error('The `kerberos` module was not found. Please install it and try again.');\r\n    }\r\n\r\n    throw err;\r\n  }\r\n\r\n  return kerberos;\r\n}\r\n\r\n// Throw an error if an attempt to use EJSON is made when it is not installed\r\nconst noEJSONError = function() {\r\n  throw new Error('The `mongodb-extjson` module was not found. Please install it and try again.');\r\n};\r\n\r\n// Facilitate loading EJSON optionally\r\nfunction retrieveEJSON() {\r\n  let EJSON = requireOptional('mongodb-extjson');\r\n  if (!EJSON) {\r\n    EJSON = {\r\n      parse: noEJSONError,\r\n      deserialize: noEJSONError,\r\n      serialize: noEJSONError,\r\n      stringify: noEJSONError,\r\n      setBSONModule: noEJSONError,\r\n      BSON: noEJSONError\r\n    };\r\n  }\r\n\r\n  return EJSON;\r\n}\r\n\r\n/**\r\n * A helper function for determining `maxWireVersion` between legacy and new topology\r\n * instances\r\n *\r\n * @private\r\n * @param {(Topology|Server)} topologyOrServer\r\n */\r\nfunction maxWireVersion(topologyOrServer) {\r\n  if (topologyOrServer) {\r\n    if (topologyOrServer.ismaster) {\r\n      return topologyOrServer.ismaster.maxWireVersion;\r\n    }\r\n\r\n    if (typeof topologyOrServer.lastIsMaster === 'function') {\r\n      const lastIsMaster = topologyOrServer.lastIsMaster();\r\n      if (lastIsMaster) {\r\n        return lastIsMaster.maxWireVersion;\r\n      }\r\n    }\r\n\r\n    if (topologyOrServer.description) {\r\n      return topologyOrServer.description.maxWireVersion;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\n/*\r\n * Checks that collation is supported by server.\r\n *\r\n * @param {Server} [server] to check against\r\n * @param {object} [cmd] object where collation may be specified\r\n * @param {function} [callback] callback function\r\n * @return true if server does not support collation\r\n */\r\nfunction collationNotSupported(server, cmd) {\r\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\r\n}\r\n\r\n/**\r\n * Checks if a given value is a Promise\r\n *\r\n * @param {*} maybePromise\r\n * @return true if the provided value is a Promise\r\n */\r\nfunction isPromiseLike(maybePromise) {\r\n  return maybePromise && typeof maybePromise.then === 'function';\r\n}\r\n\r\n/**\r\n * Applies the function `eachFn` to each item in `arr`, in parallel.\r\n *\r\n * @param {array} arr an array of items to asynchronusly iterate over\r\n * @param {function} eachFn A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\r\n * @param {function} callback The callback called after every item has been iterated\r\n */\r\nfunction eachAsync(arr, eachFn, callback) {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = 0;\r\n  for (idx = 0; idx < arr.length; ++idx) {\r\n    awaiting++;\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err) {\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n    }\r\n  }\r\n}\r\n\r\nfunction eachAsyncSeries(arr, eachFn, callback) {\r\n  arr = arr || [];\r\n\r\n  let idx = 0;\r\n  let awaiting = arr.length;\r\n  if (awaiting === 0) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  function eachCallback(err) {\r\n    idx++;\r\n    awaiting--;\r\n    if (err) {\r\n      callback(err);\r\n      return;\r\n    }\r\n\r\n    if (idx === arr.length && awaiting <= 0) {\r\n      callback();\r\n      return;\r\n    }\r\n\r\n    eachFn(arr[idx], eachCallback);\r\n  }\r\n\r\n  eachFn(arr[idx], eachCallback);\r\n}\r\n\r\nfunction isUnifiedTopology(topology) {\r\n  return topology.description != null;\r\n}\r\n\r\nfunction arrayStrictEqual(arr, arr2) {\r\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\r\n    return false;\r\n  }\r\n\r\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\r\n}\r\n\r\nfunction tagsStrictEqual(tags, tags2) {\r\n  const tagsKeys = Object.keys(tags);\r\n  const tags2Keys = Object.keys(tags2);\r\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(key => tags2[key] === tags[key]);\r\n}\r\n\r\nfunction errorStrictEqual(lhs, rhs) {\r\n  if (lhs === rhs) {\r\n    return true;\r\n  }\r\n\r\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.constructor.name !== rhs.constructor.name) {\r\n    return false;\r\n  }\r\n\r\n  if (lhs.message !== rhs.message) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction makeStateMachine(stateTable) {\r\n  return function stateTransition(target, newState) {\r\n    const legalStates = stateTable[target.s.state];\r\n    if (legalStates && legalStates.indexOf(newState) < 0) {\r\n      throw new TypeError(\r\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\r\n      );\r\n    }\r\n\r\n    target.emit('stateChanged', target.s.state, newState);\r\n    target.s.state = newState;\r\n  };\r\n}\r\n\r\nfunction makeClientMetadata(options) {\r\n  options = options || {};\r\n\r\n  const metadata = {\r\n    driver: {\r\n      name: 'nodejs',\r\n      version: require('../../package.json').version\r\n    },\r\n    os: {\r\n      type: os.type(),\r\n      name: process.platform,\r\n      architecture: process.arch,\r\n      version: os.release()\r\n    },\r\n    platform: `'Node.js ${process.version}, ${os.endianness} (${\r\n      options.useUnifiedTopology ? 'unified' : 'legacy'\r\n    })`\r\n  };\r\n\r\n  // support optionally provided wrapping driver info\r\n  if (options.driverInfo) {\r\n    if (options.driverInfo.name) {\r\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\r\n    }\r\n\r\n    if (options.driverInfo.version) {\r\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\r\n    }\r\n\r\n    if (options.driverInfo.platform) {\r\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\r\n    }\r\n  }\r\n\r\n  if (options.appname) {\r\n    // MongoDB requires the appname not exceed a byte length of 128\r\n    const buffer = Buffer.from(options.appname);\r\n    metadata.application = {\r\n      name: buffer.length > 128 ? buffer.slice(0, 128).toString('utf8') : options.appname\r\n    };\r\n  }\r\n\r\n  return metadata;\r\n}\r\n\r\nconst noop = () => {};\r\n\r\nmodule.exports = {\r\n  uuidV4,\r\n  relayEvents,\r\n  collationNotSupported,\r\n  retrieveEJSON,\r\n  retrieveKerberos,\r\n  maxWireVersion,\r\n  isPromiseLike,\r\n  eachAsync,\r\n  eachAsyncSeries,\r\n  isUnifiedTopology,\r\n  arrayStrictEqual,\r\n  tagsStrictEqual,\r\n  errorStrictEqual,\r\n  makeStateMachine,\r\n  makeClientMetadata,\r\n  noop\r\n};\r\n"]},"metadata":{},"sourceType":"script"}