{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst emitWarningOnce = require('../../utils').emitWarning;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      emitWarningOnce('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256'; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n\n}\n\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/core/auth/scram.js"],"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","emitWarningOnce","emitWarning","BSON","Binary","saslprep","e","ScramSHA","constructor","bson","cryptoMethod","prepare","handshakeDoc","authContext","callback","randomBytes","err","nonce","Object","assign","credentials","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","concat","from","toString","mechanism","saslStart","payload","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","_err","result","resolveError","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","ScramSHA1","ScramSHA256","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\nconst crypto = require('crypto');\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\r\nconst MongoError = require('../error').MongoError;\r\nconst AuthProvider = require('./auth_provider').AuthProvider;\r\nconst emitWarningOnce = require('../../utils').emitWarning;\r\n\r\nconst BSON = retrieveBSON();\r\nconst Binary = BSON.Binary;\r\n\r\nlet saslprep;\r\ntry {\r\n  saslprep = require('saslprep');\r\n} catch (e) {\r\n  // don't do anything;\r\n}\r\n\r\nclass ScramSHA extends AuthProvider {\r\n  constructor(bson, cryptoMethod) {\r\n    super(bson);\r\n    this.cryptoMethod = cryptoMethod || 'sha1';\r\n  }\r\n\r\n  prepare(handshakeDoc, authContext, callback) {\r\n    const cryptoMethod = this.cryptoMethod;\r\n    if (cryptoMethod === 'sha256' && saslprep == null) {\r\n      emitWarningOnce('Warning: no saslprep library specified. Passwords will not be sanitized');\r\n    }\r\n\r\n    crypto.randomBytes(24, (err, nonce) => {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n\r\n      // store the nonce for later use\r\n      Object.assign(authContext, { nonce });\r\n\r\n      const credentials = authContext.credentials;\r\n      const request = Object.assign({}, handshakeDoc, {\r\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\r\n          db: credentials.source\r\n        })\r\n      });\r\n\r\n      callback(undefined, request);\r\n    });\r\n  }\r\n\r\n  auth(authContext, callback) {\r\n    const response = authContext.response;\r\n    if (response && response.speculativeAuthenticate) {\r\n      continueScramConversation(\r\n        this.cryptoMethod,\r\n        response.speculativeAuthenticate,\r\n        authContext,\r\n        callback\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    executeScram(this.cryptoMethod, authContext, callback);\r\n  }\r\n}\r\n\r\nfunction cleanUsername(username) {\r\n  return username.replace('=', '=3D').replace(',', '=2C');\r\n}\r\n\r\nfunction clientFirstMessageBare(username, nonce) {\r\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\r\n  // Since the username is not sasl-prep-d, we need to do this here.\r\n  return Buffer.concat([\r\n    Buffer.from('n=', 'utf8'),\r\n    Buffer.from(username, 'utf8'),\r\n    Buffer.from(',r=', 'utf8'),\r\n    Buffer.from(nonce.toString('base64'), 'utf8')\r\n  ]);\r\n}\r\n\r\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\r\n  const username = cleanUsername(credentials.username);\r\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256';\r\n\r\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\r\n  // Since the username is not sasl-prep-d, we need to do this here.\r\n  return {\r\n    saslStart: 1,\r\n    mechanism,\r\n    payload: new Binary(\r\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\r\n    ),\r\n    autoAuthorize: 1,\r\n    options: { skipEmptyExchange: true }\r\n  };\r\n}\r\n\r\nfunction executeScram(cryptoMethod, authContext, callback) {\r\n  const connection = authContext.connection;\r\n  const credentials = authContext.credentials;\r\n  const nonce = authContext.nonce;\r\n  const db = credentials.source;\r\n\r\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\r\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\r\n    const err = resolveError(_err, result);\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\r\n  });\r\n}\r\n\r\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\r\n  const connection = authContext.connection;\r\n  const credentials = authContext.credentials;\r\n  const nonce = authContext.nonce;\r\n\r\n  const db = credentials.source;\r\n  const username = cleanUsername(credentials.username);\r\n  const password = credentials.password;\r\n\r\n  let processedPassword;\r\n  if (cryptoMethod === 'sha256') {\r\n    processedPassword = saslprep ? saslprep(password) : password;\r\n  } else {\r\n    try {\r\n      processedPassword = passwordDigest(username, password);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n  }\r\n\r\n  const payload = Buffer.isBuffer(response.payload)\r\n    ? new Binary(response.payload)\r\n    : response.payload;\r\n  const dict = parsePayload(payload.value());\r\n\r\n  const iterations = parseInt(dict.i, 10);\r\n  if (iterations && iterations < 4096) {\r\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\r\n    return;\r\n  }\r\n\r\n  const salt = dict.s;\r\n  const rnonce = dict.r;\r\n  if (rnonce.startsWith('nonce')) {\r\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\r\n    return;\r\n  }\r\n\r\n  // Set up start of proof\r\n  const withoutProof = `c=biws,r=${rnonce}`;\r\n  const saltedPassword = HI(\r\n    processedPassword,\r\n    Buffer.from(salt, 'base64'),\r\n    iterations,\r\n    cryptoMethod\r\n  );\r\n\r\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\r\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\r\n  const storedKey = H(cryptoMethod, clientKey);\r\n  const authMessage = [\r\n    clientFirstMessageBare(username, nonce),\r\n    payload.value().toString('base64'),\r\n    withoutProof\r\n  ].join(',');\r\n\r\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\r\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\r\n  const clientFinal = [withoutProof, clientProof].join(',');\r\n\r\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\r\n  const saslContinueCmd = {\r\n    saslContinue: 1,\r\n    conversationId: response.conversationId,\r\n    payload: new Binary(Buffer.from(clientFinal))\r\n  };\r\n\r\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\r\n    const err = resolveError(_err, result);\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    const r = result.result;\r\n    const parsedResponse = parsePayload(r.payload.value());\r\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\r\n      callback(new MongoError('Server returned an invalid signature'));\r\n      return;\r\n    }\r\n\r\n    if (!r || r.done !== false) {\r\n      return callback(err, r);\r\n    }\r\n\r\n    const retrySaslContinueCmd = {\r\n      saslContinue: 1,\r\n      conversationId: r.conversationId,\r\n      payload: Buffer.alloc(0)\r\n    };\r\n\r\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\r\n  });\r\n}\r\n\r\nfunction parsePayload(payload) {\r\n  const dict = {};\r\n  const parts = payload.split(',');\r\n  for (let i = 0; i < parts.length; i++) {\r\n    const valueParts = parts[i].split('=');\r\n    dict[valueParts[0]] = valueParts[1];\r\n  }\r\n\r\n  return dict;\r\n}\r\n\r\nfunction passwordDigest(username, password) {\r\n  if (typeof username !== 'string') {\r\n    throw new MongoError('username must be a string');\r\n  }\r\n\r\n  if (typeof password !== 'string') {\r\n    throw new MongoError('password must be a string');\r\n  }\r\n\r\n  if (password.length === 0) {\r\n    throw new MongoError('password cannot be empty');\r\n  }\r\n\r\n  const md5 = crypto.createHash('md5');\r\n  md5.update(`${username}:mongo:${password}`, 'utf8');\r\n  return md5.digest('hex');\r\n}\r\n\r\n// XOR two buffers\r\nfunction xor(a, b) {\r\n  if (!Buffer.isBuffer(a)) {\r\n    a = Buffer.from(a);\r\n  }\r\n\r\n  if (!Buffer.isBuffer(b)) {\r\n    b = Buffer.from(b);\r\n  }\r\n\r\n  const length = Math.max(a.length, b.length);\r\n  const res = [];\r\n\r\n  for (let i = 0; i < length; i += 1) {\r\n    res.push(a[i] ^ b[i]);\r\n  }\r\n\r\n  return Buffer.from(res).toString('base64');\r\n}\r\n\r\nfunction H(method, text) {\r\n  return crypto\r\n    .createHash(method)\r\n    .update(text)\r\n    .digest();\r\n}\r\n\r\nfunction HMAC(method, key, text) {\r\n  return crypto\r\n    .createHmac(method, key)\r\n    .update(text)\r\n    .digest();\r\n}\r\n\r\nlet _hiCache = {};\r\nlet _hiCacheCount = 0;\r\nfunction _hiCachePurge() {\r\n  _hiCache = {};\r\n  _hiCacheCount = 0;\r\n}\r\n\r\nconst hiLengthMap = {\r\n  sha256: 32,\r\n  sha1: 20\r\n};\r\n\r\nfunction HI(data, salt, iterations, cryptoMethod) {\r\n  // omit the work if already generated\r\n  const key = [data, salt.toString('base64'), iterations].join('_');\r\n  if (_hiCache[key] !== undefined) {\r\n    return _hiCache[key];\r\n  }\r\n\r\n  // generate the salt\r\n  const saltedData = crypto.pbkdf2Sync(\r\n    data,\r\n    salt,\r\n    iterations,\r\n    hiLengthMap[cryptoMethod],\r\n    cryptoMethod\r\n  );\r\n\r\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\r\n  if (_hiCacheCount >= 200) {\r\n    _hiCachePurge();\r\n  }\r\n\r\n  _hiCache[key] = saltedData;\r\n  _hiCacheCount += 1;\r\n  return saltedData;\r\n}\r\n\r\nfunction compareDigest(lhs, rhs) {\r\n  if (lhs.length !== rhs.length) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof crypto.timingSafeEqual === 'function') {\r\n    return crypto.timingSafeEqual(lhs, rhs);\r\n  }\r\n\r\n  let result = 0;\r\n  for (let i = 0; i < lhs.length; i++) {\r\n    result |= lhs[i] ^ rhs[i];\r\n  }\r\n\r\n  return result === 0;\r\n}\r\n\r\nfunction resolveError(err, result) {\r\n  if (err) return err;\r\n\r\n  const r = result.result;\r\n  if (r.$err || r.errmsg) return new MongoError(r);\r\n}\r\n\r\nclass ScramSHA1 extends ScramSHA {\r\n  constructor(bson) {\r\n    super(bson, 'sha1');\r\n  }\r\n}\r\n\r\nclass ScramSHA256 extends ScramSHA {\r\n  constructor(bson) {\r\n    super(bson, 'sha256');\r\n  }\r\n}\r\n\r\nmodule.exports = { ScramSHA1, ScramSHA256 };\r\n"]},"metadata":{},"sourceType":"script"}