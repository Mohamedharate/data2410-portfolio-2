{"ast":null,"code":"'use strict';\n\nvar Binary = require('../core').BSON.Binary,\n    ObjectID = require('../core').BSON.ObjectID;\n\nvar Buffer = require('safe-buffer').Buffer;\n/**\r\n * Class for representing a single chunk in GridFS.\r\n *\r\n * @class\r\n *\r\n * @param file {GridStore} The {@link GridStore} object holding this chunk.\r\n * @param mongoObject {object} The mongo object representation of this chunk.\r\n *\r\n * @throws Error when the type of data field for {@link mongoObject} is not\r\n *     supported. Currently supported types for data field are instances of\r\n *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}\r\n *     from the bson module\r\n *\r\n * @see Chunk#buildMongoObject\r\n */\n\n\nvar Chunk = function (file, mongoObject, writeConcern) {\n  if (!(this instanceof Chunk)) return new Chunk(file, mongoObject);\n  this.file = file;\n  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;\n  this.writeConcern = writeConcern || {\n    w: 1\n  };\n  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;\n  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;\n  this.data = new Binary();\n\n  if (typeof mongoObjectFinal.data === 'string') {\n    var buffer = Buffer.alloc(mongoObjectFinal.data.length);\n    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');\n    this.data = new Binary(buffer);\n  } else if (Array.isArray(mongoObjectFinal.data)) {\n    buffer = Buffer.alloc(mongoObjectFinal.data.length);\n    var data = mongoObjectFinal.data.join('');\n    buffer.write(data, 0, data.length, 'binary');\n    this.data = new Binary(buffer);\n  } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {\n    this.data = mongoObjectFinal.data;\n  } else if (!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {\n    throw Error('Illegal chunk format');\n  } // Update position\n\n\n  this.internalPosition = 0;\n};\n/**\r\n * Writes a data to this object and advance the read/write head.\r\n *\r\n * @param data {string} the data to write\r\n * @param callback {function(*, GridStore)} This will be called after executing\r\n *     this method. The first parameter will contain null and the second one\r\n *     will contain a reference to this object.\r\n */\n\n\nChunk.prototype.write = function (data, callback) {\n  this.data.write(data, this.internalPosition, data.length, 'binary');\n  this.internalPosition = this.data.length();\n  if (callback != null) return callback(null, this);\n  return this;\n};\n/**\r\n * Reads data and advances the read/write head.\r\n *\r\n * @param length {number} The length of data to read.\r\n *\r\n * @return {string} The data read if the given length will not exceed the end of\r\n *     the chunk. Returns an empty String otherwise.\r\n */\n\n\nChunk.prototype.read = function (length) {\n  // Default to full read if no index defined\n  length = length == null || length === 0 ? this.length() : length;\n\n  if (this.length() - this.internalPosition + 1 >= length) {\n    var data = this.data.read(this.internalPosition, length);\n    this.internalPosition = this.internalPosition + length;\n    return data;\n  } else {\n    return '';\n  }\n};\n\nChunk.prototype.readSlice = function (length) {\n  if (this.length() - this.internalPosition >= length) {\n    var data = null;\n\n    if (this.data.buffer != null) {\n      //Pure BSON\n      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);\n    } else {\n      //Native BSON\n      data = Buffer.alloc(length);\n      length = this.data.readInto(data, this.internalPosition);\n    }\n\n    this.internalPosition = this.internalPosition + length;\n    return data;\n  } else {\n    return null;\n  }\n};\n/**\r\n * Checks if the read/write head is at the end.\r\n *\r\n * @return {boolean} Whether the read/write head has reached the end of this\r\n *     chunk.\r\n */\n\n\nChunk.prototype.eof = function () {\n  return this.internalPosition === this.length() ? true : false;\n};\n/**\r\n * Reads one character from the data of this chunk and advances the read/write\r\n * head.\r\n *\r\n * @return {string} a single character data read if the the read/write head is\r\n *     not at the end of the chunk. Returns an empty String otherwise.\r\n */\n\n\nChunk.prototype.getc = function () {\n  return this.read(1);\n};\n/**\r\n * Clears the contents of the data in this chunk and resets the read/write head\r\n * to the initial position.\r\n */\n\n\nChunk.prototype.rewind = function () {\n  this.internalPosition = 0;\n  this.data = new Binary();\n};\n/**\r\n * Saves this chunk to the database. Also overwrites existing entries having the\r\n * same id as this chunk.\r\n *\r\n * @param callback {function(*, GridStore)} This will be called after executing\r\n *     this method. The first parameter will contain null and the second one\r\n *     will contain a reference to this object.\r\n */\n\n\nChunk.prototype.save = function (options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  self.file.chunkCollection(function (err, collection) {\n    if (err) return callback(err); // Merge the options\n\n    var writeOptions = {\n      upsert: true\n    };\n\n    for (var name in options) writeOptions[name] = options[name];\n\n    for (name in self.writeConcern) writeOptions[name] = self.writeConcern[name];\n\n    if (self.data.length() > 0) {\n      self.buildMongoObject(function (mongoObject) {\n        var options = {\n          forceServerObjectId: true\n        };\n\n        for (var name in self.writeConcern) {\n          options[name] = self.writeConcern[name];\n        }\n\n        collection.replaceOne({\n          _id: self.objectId\n        }, mongoObject, writeOptions, function (err) {\n          callback(err, self);\n        });\n      });\n    } else {\n      callback(null, self);\n    } // });\n\n  });\n};\n/**\r\n * Creates a mongoDB object representation of this chunk.\r\n *\r\n * @param callback {function(Object)} This will be called after executing this\r\n *     method. The object will be passed to the first parameter and will have\r\n *     the structure:\r\n *\r\n *        <pre><code>\r\n *        {\r\n *          '_id' : , // {number} id for this chunk\r\n *          'files_id' : , // {number} foreign key to the file collection\r\n *          'n' : , // {number} chunk number\r\n *          'data' : , // {bson#Binary} the chunk data itself\r\n *        }\r\n *        </code></pre>\r\n *\r\n * @see <a href=\"http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}\">MongoDB GridFS Chunk Object Structure</a>\r\n */\n\n\nChunk.prototype.buildMongoObject = function (callback) {\n  var mongoObject = {\n    files_id: this.file.fileId,\n    n: this.chunkNumber,\n    data: this.data\n  }; // If we are saving using a specific ObjectId\n\n  if (this.objectId != null) mongoObject._id = this.objectId;\n  callback(mongoObject);\n};\n/**\r\n * @return {number} the length of the data\r\n */\n\n\nChunk.prototype.length = function () {\n  return this.data.length();\n};\n/**\r\n * The position of the read/write head\r\n * @name position\r\n * @lends Chunk#\r\n * @field\r\n */\n\n\nObject.defineProperty(Chunk.prototype, 'position', {\n  enumerable: true,\n  get: function () {\n    return this.internalPosition;\n  },\n  set: function (value) {\n    this.internalPosition = value;\n  }\n});\n/**\r\n * The default chunk size\r\n * @constant\r\n */\n\nChunk.DEFAULT_CHUNK_SIZE = 1024 * 255;\nmodule.exports = Chunk;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/gridfs/chunk.js"],"names":["Binary","require","BSON","ObjectID","Buffer","Chunk","file","mongoObject","writeConcern","mongoObjectFinal","w","objectId","_id","chunkNumber","n","data","buffer","alloc","length","write","Array","isArray","join","_bsontype","isBuffer","Error","internalPosition","prototype","callback","read","readSlice","slice","readInto","eof","getc","rewind","save","options","self","chunkCollection","err","collection","writeOptions","upsert","name","buildMongoObject","forceServerObjectId","replaceOne","files_id","fileId","Object","defineProperty","enumerable","get","set","value","DEFAULT_CHUNK_SIZE","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Binary = require('../core').BSON.Binary,\r\n  ObjectID = require('../core').BSON.ObjectID;\r\n\r\nvar Buffer = require('safe-buffer').Buffer;\r\n\r\n/**\r\n * Class for representing a single chunk in GridFS.\r\n *\r\n * @class\r\n *\r\n * @param file {GridStore} The {@link GridStore} object holding this chunk.\r\n * @param mongoObject {object} The mongo object representation of this chunk.\r\n *\r\n * @throws Error when the type of data field for {@link mongoObject} is not\r\n *     supported. Currently supported types for data field are instances of\r\n *     {@link String}, {@link Array}, {@link Binary} and {@link Binary}\r\n *     from the bson module\r\n *\r\n * @see Chunk#buildMongoObject\r\n */\r\nvar Chunk = function(file, mongoObject, writeConcern) {\r\n  if (!(this instanceof Chunk)) return new Chunk(file, mongoObject);\r\n\r\n  this.file = file;\r\n  var mongoObjectFinal = mongoObject == null ? {} : mongoObject;\r\n  this.writeConcern = writeConcern || { w: 1 };\r\n  this.objectId = mongoObjectFinal._id == null ? new ObjectID() : mongoObjectFinal._id;\r\n  this.chunkNumber = mongoObjectFinal.n == null ? 0 : mongoObjectFinal.n;\r\n  this.data = new Binary();\r\n\r\n  if (typeof mongoObjectFinal.data === 'string') {\r\n    var buffer = Buffer.alloc(mongoObjectFinal.data.length);\r\n    buffer.write(mongoObjectFinal.data, 0, mongoObjectFinal.data.length, 'binary');\r\n    this.data = new Binary(buffer);\r\n  } else if (Array.isArray(mongoObjectFinal.data)) {\r\n    buffer = Buffer.alloc(mongoObjectFinal.data.length);\r\n    var data = mongoObjectFinal.data.join('');\r\n    buffer.write(data, 0, data.length, 'binary');\r\n    this.data = new Binary(buffer);\r\n  } else if (mongoObjectFinal.data && mongoObjectFinal.data._bsontype === 'Binary') {\r\n    this.data = mongoObjectFinal.data;\r\n  } else if (!Buffer.isBuffer(mongoObjectFinal.data) && !(mongoObjectFinal.data == null)) {\r\n    throw Error('Illegal chunk format');\r\n  }\r\n\r\n  // Update position\r\n  this.internalPosition = 0;\r\n};\r\n\r\n/**\r\n * Writes a data to this object and advance the read/write head.\r\n *\r\n * @param data {string} the data to write\r\n * @param callback {function(*, GridStore)} This will be called after executing\r\n *     this method. The first parameter will contain null and the second one\r\n *     will contain a reference to this object.\r\n */\r\nChunk.prototype.write = function(data, callback) {\r\n  this.data.write(data, this.internalPosition, data.length, 'binary');\r\n  this.internalPosition = this.data.length();\r\n  if (callback != null) return callback(null, this);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Reads data and advances the read/write head.\r\n *\r\n * @param length {number} The length of data to read.\r\n *\r\n * @return {string} The data read if the given length will not exceed the end of\r\n *     the chunk. Returns an empty String otherwise.\r\n */\r\nChunk.prototype.read = function(length) {\r\n  // Default to full read if no index defined\r\n  length = length == null || length === 0 ? this.length() : length;\r\n\r\n  if (this.length() - this.internalPosition + 1 >= length) {\r\n    var data = this.data.read(this.internalPosition, length);\r\n    this.internalPosition = this.internalPosition + length;\r\n    return data;\r\n  } else {\r\n    return '';\r\n  }\r\n};\r\n\r\nChunk.prototype.readSlice = function(length) {\r\n  if (this.length() - this.internalPosition >= length) {\r\n    var data = null;\r\n    if (this.data.buffer != null) {\r\n      //Pure BSON\r\n      data = this.data.buffer.slice(this.internalPosition, this.internalPosition + length);\r\n    } else {\r\n      //Native BSON\r\n      data = Buffer.alloc(length);\r\n      length = this.data.readInto(data, this.internalPosition);\r\n    }\r\n    this.internalPosition = this.internalPosition + length;\r\n    return data;\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Checks if the read/write head is at the end.\r\n *\r\n * @return {boolean} Whether the read/write head has reached the end of this\r\n *     chunk.\r\n */\r\nChunk.prototype.eof = function() {\r\n  return this.internalPosition === this.length() ? true : false;\r\n};\r\n\r\n/**\r\n * Reads one character from the data of this chunk and advances the read/write\r\n * head.\r\n *\r\n * @return {string} a single character data read if the the read/write head is\r\n *     not at the end of the chunk. Returns an empty String otherwise.\r\n */\r\nChunk.prototype.getc = function() {\r\n  return this.read(1);\r\n};\r\n\r\n/**\r\n * Clears the contents of the data in this chunk and resets the read/write head\r\n * to the initial position.\r\n */\r\nChunk.prototype.rewind = function() {\r\n  this.internalPosition = 0;\r\n  this.data = new Binary();\r\n};\r\n\r\n/**\r\n * Saves this chunk to the database. Also overwrites existing entries having the\r\n * same id as this chunk.\r\n *\r\n * @param callback {function(*, GridStore)} This will be called after executing\r\n *     this method. The first parameter will contain null and the second one\r\n *     will contain a reference to this object.\r\n */\r\nChunk.prototype.save = function(options, callback) {\r\n  var self = this;\r\n  if (typeof options === 'function') {\r\n    callback = options;\r\n    options = {};\r\n  }\r\n\r\n  self.file.chunkCollection(function(err, collection) {\r\n    if (err) return callback(err);\r\n\r\n    // Merge the options\r\n    var writeOptions = { upsert: true };\r\n    for (var name in options) writeOptions[name] = options[name];\r\n    for (name in self.writeConcern) writeOptions[name] = self.writeConcern[name];\r\n\r\n    if (self.data.length() > 0) {\r\n      self.buildMongoObject(function(mongoObject) {\r\n        var options = { forceServerObjectId: true };\r\n        for (var name in self.writeConcern) {\r\n          options[name] = self.writeConcern[name];\r\n        }\r\n\r\n        collection.replaceOne({ _id: self.objectId }, mongoObject, writeOptions, function(err) {\r\n          callback(err, self);\r\n        });\r\n      });\r\n    } else {\r\n      callback(null, self);\r\n    }\r\n    // });\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a mongoDB object representation of this chunk.\r\n *\r\n * @param callback {function(Object)} This will be called after executing this\r\n *     method. The object will be passed to the first parameter and will have\r\n *     the structure:\r\n *\r\n *        <pre><code>\r\n *        {\r\n *          '_id' : , // {number} id for this chunk\r\n *          'files_id' : , // {number} foreign key to the file collection\r\n *          'n' : , // {number} chunk number\r\n *          'data' : , // {bson#Binary} the chunk data itself\r\n *        }\r\n *        </code></pre>\r\n *\r\n * @see <a href=\"http://www.mongodb.org/display/DOCS/GridFS+Specification#GridFSSpecification-{{chunks}}\">MongoDB GridFS Chunk Object Structure</a>\r\n */\r\nChunk.prototype.buildMongoObject = function(callback) {\r\n  var mongoObject = {\r\n    files_id: this.file.fileId,\r\n    n: this.chunkNumber,\r\n    data: this.data\r\n  };\r\n  // If we are saving using a specific ObjectId\r\n  if (this.objectId != null) mongoObject._id = this.objectId;\r\n\r\n  callback(mongoObject);\r\n};\r\n\r\n/**\r\n * @return {number} the length of the data\r\n */\r\nChunk.prototype.length = function() {\r\n  return this.data.length();\r\n};\r\n\r\n/**\r\n * The position of the read/write head\r\n * @name position\r\n * @lends Chunk#\r\n * @field\r\n */\r\nObject.defineProperty(Chunk.prototype, 'position', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.internalPosition;\r\n  },\r\n  set: function(value) {\r\n    this.internalPosition = value;\r\n  }\r\n});\r\n\r\n/**\r\n * The default chunk size\r\n * @constant\r\n */\r\nChunk.DEFAULT_CHUNK_SIZE = 1024 * 255;\r\n\r\nmodule.exports = Chunk;\r\n"]},"metadata":{},"sourceType":"script"}