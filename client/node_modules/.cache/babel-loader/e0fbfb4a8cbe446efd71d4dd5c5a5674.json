{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\n\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\n\nconst Logger = require('./logger');\n\nconst f = require('util').format;\n\nconst Msg = require('./msg').Msg;\n\nconst CommandResult = require('./command_result');\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../wireprotocol/shared').opcodes;\n\nconst compress = require('../wireprotocol/compression').compress;\n\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\n\nconst apm = require('./apm');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst connect = require('./connect');\n\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\n\nconst eachAsync = require('../utils').eachAsync;\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst now = require('../../utils').now;\n\nconst DISCONNECTED = 'disconnected';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst DRAINING = 'draining';\nconst DESTROYING = 'destroying';\nconst DESTROYED = 'destroyed';\nconst stateTransition = makeStateMachine({\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\n  [DESTROYING]: [DESTROYING, DESTROYED],\n  [DESTROYED]: [DESTROYED]\n});\nconst CONNECTION_EVENTS = new Set(['error', 'close', 'timeout', 'parseError', 'connect', 'message']);\nvar _id = 0;\n/**\r\n * Creates a new Pool instance\r\n * @class\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Max server connection pool size\r\n * @param {number} [options.minSize=0] Minimum server connection pool size\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\r\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @fires Pool#connect\r\n * @fires Pool#close\r\n * @fires Pool#error\r\n * @fires Pool#timeout\r\n * @fires Pool#parseError\r\n * @return {Pool} A cursor instance\r\n */\n\nvar Pool = function (topology, options) {\n  // Add event listener\n  EventEmitter.call(this); // Store topology for later use\n\n  this.topology = topology;\n  this.s = {\n    state: DISCONNECTED,\n    cancellationToken: new EventEmitter()\n  }; // we don't care how many connections are listening for cancellation\n\n  this.s.cancellationToken.setMaxListeners(Infinity); // Add the options\n\n  this.options = Object.assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // Pool default min size\n    minSize: 0,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 0,\n    keepAlive: true,\n    keepAliveInitialDelay: 120000,\n    noDelay: true,\n    // SSL Settings\n    ssl: false,\n    checkServerIdentity: true,\n    ca: null,\n    crl: null,\n    cert: null,\n    key: null,\n    passphrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false,\n    // feature flag for determining if we are running with the unified topology or not\n    legacyCompatMode: true\n  }, options); // Identification information\n\n  this.id = _id++; // Current reconnect retries\n\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  this.reconnectError = null; // No bson parser passed in\n\n  if (!options.bson || options.bson && (typeof options.bson.serialize !== 'function' || typeof options.bson.deserialize !== 'function')) {\n    throw new Error('must pass in valid bson parser');\n  } // Logger instance\n\n\n  this.logger = Logger('Pool', options); // Connections\n\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0; // Currently executing\n\n  this.executing = false; // Operation work queue\n\n  this.queue = []; // Number of consecutive timeouts caught\n\n  this.numberOfConsecutiveTimeouts = 0; // Current pool Index\n\n  this.connectionIndex = 0; // event handlers\n\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n\n  this._connectionCloseHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n\n  this._connectionErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n\n  this._connectionTimeoutHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n\n  this._connectionParseErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\n\ninherits(Pool, EventEmitter);\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function () {\n    return this.options.size;\n  }\n});\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function () {\n    return this.options.minSize;\n  }\n});\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.connectionTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.socketTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'state', {\n  enumerable: true,\n  get: function () {\n    return this.s.state;\n  }\n}); // clears all pool state\n\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\n\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) {\n      return;\n    }\n\n    conn._connectionFailHandled = true;\n    conn.destroy(); // Remove the connection\n\n    removeConnection(pool, conn); // flush remaining work items\n\n    conn.flush(err);\n  } // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n\n\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1; // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0; // Destroy all connections and pool\n\n      pool.destroy(true); // Emit close event\n\n      return pool.emit('close', pool);\n    }\n  } // No more socket available propegate the event\n\n\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\n      if (pool.options.reconnect) {\n        stateTransition(pool, DISCONNECTED);\n      }\n    } // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n\n\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  } // Start reconnection attempts\n\n\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectError = err;\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  } // Do we need to do anything to maintain the minimum pool size\n\n\n  const totalConnections = totalConnectionCount(pool);\n\n  if (totalConnections < pool.minSize) {\n    createConnection(pool);\n  }\n}\n\nfunction attemptReconnect(pool, callback) {\n  return function () {\n    pool.emit('attemptReconnect', pool);\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\n      }\n\n      return;\n    }\n\n    pool.retriesLeft = pool.retriesLeft - 1;\n\n    if (pool.retriesLeft <= 0) {\n      pool.destroy();\n      const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);\n      pool.emit('reconnectFailed', error);\n\n      if (typeof callback === 'function') {\n        callback(error);\n      }\n\n      return;\n    } // clear the reconnect id on retry\n\n\n    pool.reconnectId = null; // now retry creating a connection\n\n    createConnection(pool, (err, conn) => {\n      if (err == null) {\n        pool.reconnectId = null;\n        pool.retriesLeft = pool.options.reconnectTries;\n        pool.emit('reconnect', pool);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, conn);\n      }\n    });\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection); // Move the connection from connecting to available\n\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function (message, connection) {\n    // workItem to execute\n    var workItem = null; // Locate the workItem\n\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i]; // Remove from list of workItems\n\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    } // Reset timeout counter\n\n\n    self.numberOfConsecutiveTimeouts = 0; // Reset the connection timeout if we modified it for\n    // this operation\n\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    } // Log if debug enabled\n\n\n    if (self.logger.isDebug()) {\n      self.logger.debug(f('message [%s] received from %s:%s', message.raw.toString('hex'), self.options.host, self.options.port));\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function () {\n          return cb(err, result);\n        });\n      } // Domain enabled just call the callback\n\n\n      cb(err, result);\n    } // Keep executing, ensure current message handler does not stop execution\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    } // Time to dispatch the message if we have a callback\n\n\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n\n        if (self.topology && document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      } // Establish if we have an error\n\n\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      } // Add the connection details\n\n\n      message.hashedName = connection.hashedName; // Return the documents\n\n      handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n    }\n  };\n}\n/**\r\n * Return the total socket count in the pool.\r\n * @method\r\n * @return {Number} The number of socket available.\r\n */\n\n\nPool.prototype.socketCount = function () {\n  return this.availableConnections.length + this.inUseConnections.length; // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;\n}\n/**\r\n * Return all pool connections\r\n * @method\r\n * @return {Connection[]} The pool connections\r\n */\n\n\nPool.prototype.allConnections = function () {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n/**\r\n * Get a pool connection (round-robin)\r\n * @method\r\n * @return {Connection}\r\n */\n\n\nPool.prototype.get = function () {\n  return this.allConnections()[0];\n};\n/**\r\n * Is the pool connected\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isConnected = function () {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  } // Get connections\n\n\n  var connections = this.availableConnections.concat(this.inUseConnections); // Check if we have any connected connections\n\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  } // Not connected\n\n\n  return false;\n};\n/**\r\n * Was the pool destroyed\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isDestroyed = function () {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n/**\r\n * Is the pool in a disconnected state\r\n * @method\r\n * @return {boolean}\r\n */\n\n\nPool.prototype.isDisconnected = function () {\n  return this.state === DISCONNECTED;\n};\n/**\r\n * Connect pool\r\n */\n\n\nPool.prototype.connect = function (callback) {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  stateTransition(this, CONNECTING);\n  createConnection(this, (err, conn) => {\n    if (err) {\n      if (typeof callback === 'function') {\n        this.destroy();\n        callback(err);\n        return;\n      }\n\n      if (this.state === CONNECTING) {\n        this.emit('error', err);\n      }\n\n      this.destroy();\n      return;\n    }\n\n    stateTransition(this, CONNECTED); // create min connections\n\n    if (this.minSize) {\n      for (let i = 0; i < this.minSize; i++) {\n        createConnection(this);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(null, conn);\n    } else {\n      this.emit('connect', this, conn);\n    }\n  });\n};\n/**\r\n * Authenticate using a specified mechanism\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nPool.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Logout all users against a database\r\n * @param {authResultCallback} callback A callback function\r\n */\n\n\nPool.prototype.logout = function (dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\r\n * Unref the pool\r\n * @method\r\n */\n\n\nPool.prototype.unref = function () {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n  connections.forEach(function (c) {\n    c.unref();\n  });\n}; // Destroy the connections\n\n\nfunction destroy(self, connections, options, callback) {\n  stateTransition(self, DESTROYING); // indicate that in-flight connections should cancel\n\n  self.s.cancellationToken.emit('cancel');\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    } // ignore any errors during destruction\n\n\n    conn.on('error', () => {});\n    conn.destroy(options, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') callback(err, null);\n      return;\n    }\n\n    resetPoolState(self);\n    self.queue = [];\n    stateTransition(self, DESTROYED);\n    if (typeof callback === 'function') callback(null, null);\n  });\n}\n/**\r\n * Destroy pool\r\n * @method\r\n */\n\n\nPool.prototype.destroy = function (force, callback) {\n  var self = this;\n\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  } // Do not try again if the pool is already dead\n\n\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  } // Set state to draining\n\n\n  stateTransition(this, DRAINING); // Are we force closing\n\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections); // Flush any remaining work items with\n    // an error\n\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    } // Destroy the topology\n\n\n    return destroy(self, connections, {\n      force: true\n    }, callback);\n  } // Clear out the reconnect if set\n\n\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  } // Wait for the operations to drain before we close the pool\n\n\n  function checkStatus() {\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections); // Check if we have any in flight operations\n\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections, {\n        force: false\n      }, callback);\n    } else {\n      // Ensure we empty the queue\n      _execute(self)(); // Set timeout\n\n\n      setTimeout(checkStatus, 1);\n    }\n  } // Initiate drain of operations\n\n\n  checkStatus();\n};\n/**\r\n * Reset all connections of this pool\r\n *\r\n * @param {function} [callback]\r\n */\n\n\nPool.prototype.reset = function (callback) {\n  if (this.s.state !== CONNECTED) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('pool is not connected, reset aborted'));\n    }\n\n    return;\n  } // signal in-flight connections should be cancelled\n\n\n  this.s.cancellationToken.emit('cancel'); // destroy existing connections\n\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n\n    conn.destroy({\n      force: true\n    }, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') {\n        callback(err, null);\n        return;\n      }\n    }\n\n    resetPoolState(this); // create a new connection, this will ultimately trigger execution\n\n    createConnection(this, () => {\n      if (typeof callback === 'function') {\n        callback(null, null);\n      }\n    });\n  });\n}; // Prepare the buffer that Pool.prototype.write() uses to send to the server\n\n\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin(); // Check whether we and the server have agreed to use a compressor\n\n  const shouldCompress = !!self.options.agreedCompressor;\n\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  } // Transform originalCommandBuffer into OP_COMPRESSED\n\n\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n  compress(self, messageToBeCompressed, function (err, compressedMessage) {\n    if (err) return callback(err, null); // Create the msgHeader of OP_COMPRESSED\n\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n    // Create the compression details of OP_COMPRESSED\n\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n/**\r\n * Write a message to MongoDB\r\n * @method\r\n * @return {Connection}\r\n */\n\n\nPool.prototype.write = function (command, options, cb) {\n  var self = this; // Ensure we have a callback\n\n  if (typeof options === 'function') {\n    cb = options;\n  } // Always have options\n\n\n  options = options || {}; // We need to have a callback function unless the message returns no response\n\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  } // Pool was destroyed error out\n\n\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    cb(new MongoError('pool destroyed'));\n    return;\n  }\n\n  if (this.state === DRAINING) {\n    cb(new MongoError('pool is draining, new operations prohibited'));\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function () {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      } // bounce off event loop so domain switch takes place\n\n\n      process.nextTick(function () {\n        oldCb.apply(null, args);\n      });\n    });\n  } // Do we have an operation\n\n\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    fullResult: false\n  }; // Set the options for the parsing\n\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null; // Optional per operation socketTimeout\n\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring; // Get the requestId\n\n  operation.requestId = command.requestId; // If command monitoring is enabled we need to modify the callback here\n\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operation.started = now();\n\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operation.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operation.started));\n        } else {\n          self.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operation.started));\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  } // Prepare the operation buffer\n\n\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err; // Set the operation's buffer to the serialization of the commands\n\n    operation.buffer = serializedBuffers; // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    } // Attempt to execute the operation\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n  });\n}; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n} // Remove connection method\n\n\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\n\nfunction createConnection(pool, callback) {\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\n    }\n\n    return;\n  }\n\n  pool.connectingConnections++;\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\n    pool.connectingConnections--;\n\n    if (err) {\n      if (pool.logger.isDebug()) {\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      } // check if reconnect is enabled, and attempt retry if so\n\n\n      if (!pool.reconnectId && pool.options.reconnect) {\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\n          callback(err);\n          return;\n        }\n\n        pool.reconnectError = err;\n        pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    } // the pool might have been closed since we started creating the connection\n\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Pool was destroyed after connection creation'));\n      }\n\n      connection.destroy();\n      return;\n    } // otherwise, connect relevant event handlers and add it to our available connections\n\n\n    connection.on('error', pool._connectionErrorHandler);\n    connection.on('close', pool._connectionCloseHandler);\n    connection.on('timeout', pool._connectionTimeoutHandler);\n    connection.on('parseError', pool._connectionParseErrorHandler);\n    connection.on('message', pool._messageHandler);\n    pool.availableConnections.push(connection); // if a callback was provided, return the connection\n\n    if (typeof callback === 'function') {\n      callback(null, connection);\n    } // immediately execute any waiting work\n\n\n    _execute(pool)();\n  });\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({\n        message: 'no connection available for monitoring',\n        driver: true\n      }));\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function () {\n    if (self.state === DESTROYED) return; // Already executing, skip\n\n    if (self.executing) return; // Set pool as executing\n\n    self.executing = true; // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    } // As long as we have available connections\n    // eslint-disable-next-line\n\n\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self); // No available connections available, flush any monitoring ops\n\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue); // Try to create a new connection to execute stuck operation\n\n        if (totalConnections < self.options.size && self.queue.length > 0) {\n          createConnection(self);\n        }\n\n        break;\n      } // No queue break\n\n\n      if (self.queue.length === 0) {\n        break;\n      }\n\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0); // No connection found that has no work on it, just pick one for pipelining\n\n      if (connections.length === 0) {\n        connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      } // Is the connection connected\n\n\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      } // Get the next work item\n\n\n      var workItem = self.queue.shift(); // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        } // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n\n\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem); // Attempt to grow the pool if it's not yet maxsize\n\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            createConnection(self);\n          } // Re-execute the operation\n\n\n          setTimeout(() => _execute(self)(), 10);\n          break;\n        }\n      } // Don't execute operation until we have a full pool\n\n\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem); // Create a new connection\n\n          createConnection(self); // Break from the loop\n\n          break;\n        }\n      } // Get actual binary commands\n\n\n      var buffer = workItem.buffer; // If we are monitoring take the connection of the availableConnections\n\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      } // Track the executing commands on the mongo server\n      // as long as there is an expected response\n\n\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      } // We have a custom socketTimeout\n\n\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      } // Capture if write was successful\n\n\n      var writeSuccessful = true; // Put operation on the wire\n\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      } // if the command is designated noResponse, call the callback immeditely\n\n\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem); // Remove the disconnected connection\n\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n\n    self.executing = false;\n  };\n} // Make execution loop available for testing\n\n\nPool._execute = _execute;\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Pool#connect\r\n * @type {Pool}\r\n */\n\n/**\r\n * A server reconnect event, used to verify that pool reconnected.\r\n *\r\n * @event Pool#reconnect\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Pool#close\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Pool#error\r\n * @type {Pool}\r\n */\n\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Pool#timeout\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Pool#parseError\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver attempted to reconnect\r\n *\r\n * @event Pool#attemptReconnect\r\n * @type {Pool}\r\n */\n\n/**\r\n * The driver exhausted all reconnect attempts\r\n *\r\n * @event Pool#reconnectFailed\r\n * @type {Pool}\r\n */\n\nmodule.exports = Pool;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/core/connection/pool.js"],"names":["inherits","require","EventEmitter","MongoError","MongoTimeoutError","MongoWriteConcernError","Logger","f","format","Msg","CommandResult","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","opcodes","compress","compressorIDs","uncompressibleCommands","apm","Buffer","connect","updateSessionFromResponse","eachAsync","makeStateMachine","now","DISCONNECTED","CONNECTING","CONNECTED","DRAINING","DESTROYING","DESTROYED","stateTransition","CONNECTION_EVENTS","Set","_id","Pool","topology","options","call","s","state","cancellationToken","setMaxListeners","Infinity","Object","assign","host","port","size","minSize","connectionTimeout","socketTimeout","keepAlive","keepAliveInitialDelay","noDelay","ssl","checkServerIdentity","ca","crl","cert","key","passphrase","rejectUnauthorized","promoteLongs","promoteValues","promoteBuffers","reconnect","reconnectInterval","reconnectTries","domainsEnabled","legacyCompatMode","id","retriesLeft","reconnectId","reconnectError","bson","serialize","deserialize","Error","logger","availableConnections","inUseConnections","connectingConnections","executing","queue","numberOfConsecutiveTimeouts","connectionIndex","pool","_messageHandler","messageHandler","_connectionCloseHandler","err","connection","connectionFailureHandler","_connectionErrorHandler","_connectionTimeoutHandler","_connectionParseErrorHandler","defineProperty","prototype","enumerable","get","resetPoolState","event","conn","_connectionFailHandled","destroy","removeConnection","flush","emit","socketCount","setTimeout","attemptReconnect","totalConnections","totalConnectionCount","createConnection","callback","error","moveConnectionBetween","from","to","index","indexOf","splice","push","self","message","workItem","i","workItems","length","requestId","responseTo","monitoring","resetSocketTimeout","isDebug","debug","raw","toString","handleOperationCallback","cb","result","process","nextTick","_execute","immediateRelease","parse","documents","document","session","$clusterTime","clusterTime","command","responseDoc","writeConcernError","ok","$err","errmsg","code","hashedName","fullResult","allConnections","concat","isConnected","connections","isDestroyed","isDisconnected","auth","credentials","logout","dbName","unref","forEach","c","eventName","removeAllListeners","on","force","shift","clearTimeout","checkStatus","flushMonitoringOperations","reset","serializeCommand","originalCommandBuffer","toBin","shouldCompress","agreedCompressor","canCompress","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compressedMessage","msgHeader","alloc","writeInt32LE","OP_COMPRESSED","compressionDetails","writeUInt8","write","noResponse","domain","oldCb","bind","args","Array","arguments","apply","operation","documentsReturnedIn","monitorCommands","CommandStartedEvent","started","reply","CommandFailedEvent","CommandSucceededEvent","serializedBuffers","buffer","unshift","commandDoc","query","commandName","keys","has","remove","JSON","stringify","driver","filter","foundValidConnection","setSocketTimeout","writeSuccessful","isArray","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst inherits = require('util').inherits;\r\nconst EventEmitter = require('events').EventEmitter;\r\nconst MongoError = require('../error').MongoError;\r\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\r\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\r\nconst Logger = require('./logger');\r\nconst f = require('util').format;\r\nconst Msg = require('./msg').Msg;\r\nconst CommandResult = require('./command_result');\r\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\r\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\r\nconst opcodes = require('../wireprotocol/shared').opcodes;\r\nconst compress = require('../wireprotocol/compression').compress;\r\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\r\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\r\nconst apm = require('./apm');\r\nconst Buffer = require('safe-buffer').Buffer;\r\nconst connect = require('./connect');\r\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\r\nconst eachAsync = require('../utils').eachAsync;\r\nconst makeStateMachine = require('../utils').makeStateMachine;\r\nconst now = require('../../utils').now;\r\n\r\nconst DISCONNECTED = 'disconnected';\r\nconst CONNECTING = 'connecting';\r\nconst CONNECTED = 'connected';\r\nconst DRAINING = 'draining';\r\nconst DESTROYING = 'destroying';\r\nconst DESTROYED = 'destroyed';\r\nconst stateTransition = makeStateMachine({\r\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\r\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\r\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\r\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\r\n  [DESTROYING]: [DESTROYING, DESTROYED],\r\n  [DESTROYED]: [DESTROYED]\r\n});\r\n\r\nconst CONNECTION_EVENTS = new Set([\r\n  'error',\r\n  'close',\r\n  'timeout',\r\n  'parseError',\r\n  'connect',\r\n  'message'\r\n]);\r\n\r\nvar _id = 0;\r\n\r\n/**\r\n * Creates a new Pool instance\r\n * @class\r\n * @param {string} options.host The server host\r\n * @param {number} options.port The server port\r\n * @param {number} [options.size=5] Max server connection pool size\r\n * @param {number} [options.minSize=0] Minimum server connection pool size\r\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\r\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\r\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\r\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\r\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\r\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\r\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\r\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\r\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\r\n * @param {boolean} [options.ssl=false] Use SSL for connection\r\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\r\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\r\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\r\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\r\n * @param {Buffer} [options.key] SSL Key file binary buffer\r\n * @param {string} [options.passphrase] SSL Certificate pass phrase\r\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\r\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\r\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\r\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\r\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\r\n * @fires Pool#connect\r\n * @fires Pool#close\r\n * @fires Pool#error\r\n * @fires Pool#timeout\r\n * @fires Pool#parseError\r\n * @return {Pool} A cursor instance\r\n */\r\nvar Pool = function(topology, options) {\r\n  // Add event listener\r\n  EventEmitter.call(this);\r\n\r\n  // Store topology for later use\r\n  this.topology = topology;\r\n\r\n  this.s = {\r\n    state: DISCONNECTED,\r\n    cancellationToken: new EventEmitter()\r\n  };\r\n\r\n  // we don't care how many connections are listening for cancellation\r\n  this.s.cancellationToken.setMaxListeners(Infinity);\r\n\r\n  // Add the options\r\n  this.options = Object.assign(\r\n    {\r\n      // Host and port settings\r\n      host: 'localhost',\r\n      port: 27017,\r\n      // Pool default max size\r\n      size: 5,\r\n      // Pool default min size\r\n      minSize: 0,\r\n      // socket settings\r\n      connectionTimeout: 30000,\r\n      socketTimeout: 0,\r\n      keepAlive: true,\r\n      keepAliveInitialDelay: 120000,\r\n      noDelay: true,\r\n      // SSL Settings\r\n      ssl: false,\r\n      checkServerIdentity: true,\r\n      ca: null,\r\n      crl: null,\r\n      cert: null,\r\n      key: null,\r\n      passphrase: null,\r\n      rejectUnauthorized: false,\r\n      promoteLongs: true,\r\n      promoteValues: true,\r\n      promoteBuffers: false,\r\n      // Reconnection options\r\n      reconnect: true,\r\n      reconnectInterval: 1000,\r\n      reconnectTries: 30,\r\n      // Enable domains\r\n      domainsEnabled: false,\r\n      // feature flag for determining if we are running with the unified topology or not\r\n      legacyCompatMode: true\r\n    },\r\n    options\r\n  );\r\n\r\n  // Identification information\r\n  this.id = _id++;\r\n  // Current reconnect retries\r\n  this.retriesLeft = this.options.reconnectTries;\r\n  this.reconnectId = null;\r\n  this.reconnectError = null;\r\n  // No bson parser passed in\r\n  if (\r\n    !options.bson ||\r\n    (options.bson &&\r\n      (typeof options.bson.serialize !== 'function' ||\r\n        typeof options.bson.deserialize !== 'function'))\r\n  ) {\r\n    throw new Error('must pass in valid bson parser');\r\n  }\r\n\r\n  // Logger instance\r\n  this.logger = Logger('Pool', options);\r\n  // Connections\r\n  this.availableConnections = [];\r\n  this.inUseConnections = [];\r\n  this.connectingConnections = 0;\r\n  // Currently executing\r\n  this.executing = false;\r\n  // Operation work queue\r\n  this.queue = [];\r\n\r\n  // Number of consecutive timeouts caught\r\n  this.numberOfConsecutiveTimeouts = 0;\r\n  // Current pool Index\r\n  this.connectionIndex = 0;\r\n\r\n  // event handlers\r\n  const pool = this;\r\n  this._messageHandler = messageHandler(this);\r\n  this._connectionCloseHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'close', err, connection);\r\n  };\r\n\r\n  this._connectionErrorHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'error', err, connection);\r\n  };\r\n\r\n  this._connectionTimeoutHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'timeout', err, connection);\r\n  };\r\n\r\n  this._connectionParseErrorHandler = function(err) {\r\n    const connection = this;\r\n    connectionFailureHandler(pool, 'parseError', err, connection);\r\n  };\r\n};\r\n\r\ninherits(Pool, EventEmitter);\r\n\r\nObject.defineProperty(Pool.prototype, 'size', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.size;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'minSize', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.minSize;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.connectionTimeout;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.options.socketTimeout;\r\n  }\r\n});\r\n\r\nObject.defineProperty(Pool.prototype, 'state', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.state;\r\n  }\r\n});\r\n\r\n// clears all pool state\r\nfunction resetPoolState(pool) {\r\n  pool.inUseConnections = [];\r\n  pool.availableConnections = [];\r\n  pool.connectingConnections = 0;\r\n  pool.executing = false;\r\n  pool.numberOfConsecutiveTimeouts = 0;\r\n  pool.connectionIndex = 0;\r\n  pool.retriesLeft = pool.options.reconnectTries;\r\n  pool.reconnectId = null;\r\n}\r\n\r\nfunction connectionFailureHandler(pool, event, err, conn) {\r\n  if (conn) {\r\n    if (conn._connectionFailHandled) {\r\n      return;\r\n    }\r\n\r\n    conn._connectionFailHandled = true;\r\n    conn.destroy();\r\n\r\n    // Remove the connection\r\n    removeConnection(pool, conn);\r\n\r\n    // flush remaining work items\r\n    conn.flush(err);\r\n  }\r\n\r\n  // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\r\n  if (event === 'timeout') {\r\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;\r\n\r\n    // Have we timed out more than reconnectTries in a row ?\r\n    // Force close the pool as we are trying to connect to tcp sink hole\r\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\r\n      pool.numberOfConsecutiveTimeouts = 0;\r\n      // Destroy all connections and pool\r\n      pool.destroy(true);\r\n      // Emit close event\r\n      return pool.emit('close', pool);\r\n    }\r\n  }\r\n\r\n  // No more socket available propegate the event\r\n  if (pool.socketCount() === 0) {\r\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\r\n      if (pool.options.reconnect) {\r\n        stateTransition(pool, DISCONNECTED);\r\n      }\r\n    }\r\n\r\n    // Do not emit error events, they are always close events\r\n    // do not trigger the low level error handler in node\r\n    event = event === 'error' ? 'close' : event;\r\n    pool.emit(event, err);\r\n  }\r\n\r\n  // Start reconnection attempts\r\n  if (!pool.reconnectId && pool.options.reconnect) {\r\n    pool.reconnectError = err;\r\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\r\n  }\r\n\r\n  // Do we need to do anything to maintain the minimum pool size\r\n  const totalConnections = totalConnectionCount(pool);\r\n  if (totalConnections < pool.minSize) {\r\n    createConnection(pool);\r\n  }\r\n}\r\n\r\nfunction attemptReconnect(pool, callback) {\r\n  return function() {\r\n    pool.emit('attemptReconnect', pool);\r\n\r\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\r\n      if (typeof callback === 'function') {\r\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    pool.retriesLeft = pool.retriesLeft - 1;\r\n    if (pool.retriesLeft <= 0) {\r\n      pool.destroy();\r\n\r\n      const error = new MongoTimeoutError(\r\n        `failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`,\r\n        pool.reconnectError\r\n      );\r\n\r\n      pool.emit('reconnectFailed', error);\r\n      if (typeof callback === 'function') {\r\n        callback(error);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // clear the reconnect id on retry\r\n    pool.reconnectId = null;\r\n\r\n    // now retry creating a connection\r\n    createConnection(pool, (err, conn) => {\r\n      if (err == null) {\r\n        pool.reconnectId = null;\r\n        pool.retriesLeft = pool.options.reconnectTries;\r\n        pool.emit('reconnect', pool);\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        callback(err, conn);\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nfunction moveConnectionBetween(connection, from, to) {\r\n  var index = from.indexOf(connection);\r\n  // Move the connection from connecting to available\r\n  if (index !== -1) {\r\n    from.splice(index, 1);\r\n    to.push(connection);\r\n  }\r\n}\r\n\r\nfunction messageHandler(self) {\r\n  return function(message, connection) {\r\n    // workItem to execute\r\n    var workItem = null;\r\n\r\n    // Locate the workItem\r\n    for (var i = 0; i < connection.workItems.length; i++) {\r\n      if (connection.workItems[i].requestId === message.responseTo) {\r\n        // Get the callback\r\n        workItem = connection.workItems[i];\r\n        // Remove from list of workItems\r\n        connection.workItems.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    if (workItem && workItem.monitoring) {\r\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\r\n    }\r\n\r\n    // Reset timeout counter\r\n    self.numberOfConsecutiveTimeouts = 0;\r\n\r\n    // Reset the connection timeout if we modified it for\r\n    // this operation\r\n    if (workItem && workItem.socketTimeout) {\r\n      connection.resetSocketTimeout();\r\n    }\r\n\r\n    // Log if debug enabled\r\n    if (self.logger.isDebug()) {\r\n      self.logger.debug(\r\n        f(\r\n          'message [%s] received from %s:%s',\r\n          message.raw.toString('hex'),\r\n          self.options.host,\r\n          self.options.port\r\n        )\r\n      );\r\n    }\r\n\r\n    function handleOperationCallback(self, cb, err, result) {\r\n      // No domain enabled\r\n      if (!self.options.domainsEnabled) {\r\n        return process.nextTick(function() {\r\n          return cb(err, result);\r\n        });\r\n      }\r\n\r\n      // Domain enabled just call the callback\r\n      cb(err, result);\r\n    }\r\n\r\n    // Keep executing, ensure current message handler does not stop execution\r\n    if (!self.executing) {\r\n      process.nextTick(function() {\r\n        _execute(self)();\r\n      });\r\n    }\r\n\r\n    // Time to dispatch the message if we have a callback\r\n    if (workItem && !workItem.immediateRelease) {\r\n      try {\r\n        // Parse the message according to the provided options\r\n        message.parse(workItem);\r\n      } catch (err) {\r\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\r\n      }\r\n\r\n      if (message.documents[0]) {\r\n        const document = message.documents[0];\r\n        const session = workItem.session;\r\n        if (session) {\r\n          updateSessionFromResponse(session, document);\r\n        }\r\n\r\n        if (self.topology && document.$clusterTime) {\r\n          self.topology.clusterTime = document.$clusterTime;\r\n        }\r\n      }\r\n\r\n      // Establish if we have an error\r\n      if (workItem.command && message.documents[0]) {\r\n        const responseDoc = message.documents[0];\r\n\r\n        if (responseDoc.writeConcernError) {\r\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\r\n          return handleOperationCallback(self, workItem.cb, err);\r\n        }\r\n\r\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\r\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\r\n        }\r\n      }\r\n\r\n      // Add the connection details\r\n      message.hashedName = connection.hashedName;\r\n\r\n      // Return the documents\r\n      handleOperationCallback(\r\n        self,\r\n        workItem.cb,\r\n        null,\r\n        new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Return the total socket count in the pool.\r\n * @method\r\n * @return {Number} The number of socket available.\r\n */\r\nPool.prototype.socketCount = function() {\r\n  return this.availableConnections.length + this.inUseConnections.length;\r\n  // + this.connectingConnections.length;\r\n};\r\n\r\nfunction totalConnectionCount(pool) {\r\n  return (\r\n    pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections\r\n  );\r\n}\r\n\r\n/**\r\n * Return all pool connections\r\n * @method\r\n * @return {Connection[]} The pool connections\r\n */\r\nPool.prototype.allConnections = function() {\r\n  return this.availableConnections.concat(this.inUseConnections);\r\n};\r\n\r\n/**\r\n * Get a pool connection (round-robin)\r\n * @method\r\n * @return {Connection}\r\n */\r\nPool.prototype.get = function() {\r\n  return this.allConnections()[0];\r\n};\r\n\r\n/**\r\n * Is the pool connected\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isConnected = function() {\r\n  // We are in a destroyed state\r\n  if (this.state === DESTROYED || this.state === DESTROYING) {\r\n    return false;\r\n  }\r\n\r\n  // Get connections\r\n  var connections = this.availableConnections.concat(this.inUseConnections);\r\n\r\n  // Check if we have any connected connections\r\n  for (var i = 0; i < connections.length; i++) {\r\n    if (connections[i].isConnected()) return true;\r\n  }\r\n\r\n  // Not connected\r\n  return false;\r\n};\r\n\r\n/**\r\n * Was the pool destroyed\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isDestroyed = function() {\r\n  return this.state === DESTROYED || this.state === DESTROYING;\r\n};\r\n\r\n/**\r\n * Is the pool in a disconnected state\r\n * @method\r\n * @return {boolean}\r\n */\r\nPool.prototype.isDisconnected = function() {\r\n  return this.state === DISCONNECTED;\r\n};\r\n\r\n/**\r\n * Connect pool\r\n */\r\nPool.prototype.connect = function(callback) {\r\n  if (this.state !== DISCONNECTED) {\r\n    throw new MongoError('connection in unlawful state ' + this.state);\r\n  }\r\n\r\n  stateTransition(this, CONNECTING);\r\n  createConnection(this, (err, conn) => {\r\n    if (err) {\r\n      if (typeof callback === 'function') {\r\n        this.destroy();\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      if (this.state === CONNECTING) {\r\n        this.emit('error', err);\r\n      }\r\n\r\n      this.destroy();\r\n      return;\r\n    }\r\n\r\n    stateTransition(this, CONNECTED);\r\n\r\n    // create min connections\r\n    if (this.minSize) {\r\n      for (let i = 0; i < this.minSize; i++) {\r\n        createConnection(this);\r\n      }\r\n    }\r\n\r\n    if (typeof callback === 'function') {\r\n      callback(null, conn);\r\n    } else {\r\n      this.emit('connect', this, conn);\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Authenticate using a specified mechanism\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nPool.prototype.auth = function(credentials, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Logout all users against a database\r\n * @param {authResultCallback} callback A callback function\r\n */\r\nPool.prototype.logout = function(dbName, callback) {\r\n  if (typeof callback === 'function') callback(null, null);\r\n};\r\n\r\n/**\r\n * Unref the pool\r\n * @method\r\n */\r\nPool.prototype.unref = function() {\r\n  // Get all the known connections\r\n  var connections = this.availableConnections.concat(this.inUseConnections);\r\n\r\n  connections.forEach(function(c) {\r\n    c.unref();\r\n  });\r\n};\r\n\r\n// Destroy the connections\r\nfunction destroy(self, connections, options, callback) {\r\n  stateTransition(self, DESTROYING);\r\n\r\n  // indicate that in-flight connections should cancel\r\n  self.s.cancellationToken.emit('cancel');\r\n\r\n  eachAsync(\r\n    connections,\r\n    (conn, cb) => {\r\n      for (const eventName of CONNECTION_EVENTS) {\r\n        conn.removeAllListeners(eventName);\r\n      }\r\n\r\n      // ignore any errors during destruction\r\n      conn.on('error', () => {});\r\n\r\n      conn.destroy(options, cb);\r\n    },\r\n    err => {\r\n      if (err) {\r\n        if (typeof callback === 'function') callback(err, null);\r\n        return;\r\n      }\r\n\r\n      resetPoolState(self);\r\n      self.queue = [];\r\n\r\n      stateTransition(self, DESTROYED);\r\n      if (typeof callback === 'function') callback(null, null);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Destroy pool\r\n * @method\r\n */\r\nPool.prototype.destroy = function(force, callback) {\r\n  var self = this;\r\n  if (typeof force === 'function') {\r\n    callback = force;\r\n    force = false;\r\n  }\r\n\r\n  // Do not try again if the pool is already dead\r\n  if (this.state === DESTROYED || self.state === DESTROYING) {\r\n    if (typeof callback === 'function') callback(null, null);\r\n    return;\r\n  }\r\n\r\n  // Set state to draining\r\n  stateTransition(this, DRAINING);\r\n\r\n  // Are we force closing\r\n  if (force) {\r\n    // Get all the known connections\r\n    var connections = self.availableConnections.concat(self.inUseConnections);\r\n\r\n    // Flush any remaining work items with\r\n    // an error\r\n    while (self.queue.length > 0) {\r\n      var workItem = self.queue.shift();\r\n      if (typeof workItem.cb === 'function') {\r\n        workItem.cb(new MongoError('Pool was force destroyed'));\r\n      }\r\n    }\r\n\r\n    // Destroy the topology\r\n    return destroy(self, connections, { force: true }, callback);\r\n  }\r\n\r\n  // Clear out the reconnect if set\r\n  if (this.reconnectId) {\r\n    clearTimeout(this.reconnectId);\r\n  }\r\n\r\n  // Wait for the operations to drain before we close the pool\r\n  function checkStatus() {\r\n    if (self.state === DESTROYED || self.state === DESTROYING) {\r\n      if (typeof callback === 'function') {\r\n        callback();\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    flushMonitoringOperations(self.queue);\r\n\r\n    if (self.queue.length === 0) {\r\n      // Get all the known connections\r\n      var connections = self.availableConnections.concat(self.inUseConnections);\r\n\r\n      // Check if we have any in flight operations\r\n      for (var i = 0; i < connections.length; i++) {\r\n        // There is an operation still in flight, reschedule a\r\n        // check waiting for it to drain\r\n        if (connections[i].workItems.length > 0) {\r\n          return setTimeout(checkStatus, 1);\r\n        }\r\n      }\r\n\r\n      destroy(self, connections, { force: false }, callback);\r\n    } else {\r\n      // Ensure we empty the queue\r\n      _execute(self)();\r\n      // Set timeout\r\n      setTimeout(checkStatus, 1);\r\n    }\r\n  }\r\n\r\n  // Initiate drain of operations\r\n  checkStatus();\r\n};\r\n\r\n/**\r\n * Reset all connections of this pool\r\n *\r\n * @param {function} [callback]\r\n */\r\nPool.prototype.reset = function(callback) {\r\n  if (this.s.state !== CONNECTED) {\r\n    if (typeof callback === 'function') {\r\n      callback(new MongoError('pool is not connected, reset aborted'));\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  // signal in-flight connections should be cancelled\r\n  this.s.cancellationToken.emit('cancel');\r\n\r\n  // destroy existing connections\r\n  const connections = this.availableConnections.concat(this.inUseConnections);\r\n  eachAsync(\r\n    connections,\r\n    (conn, cb) => {\r\n      for (const eventName of CONNECTION_EVENTS) {\r\n        conn.removeAllListeners(eventName);\r\n      }\r\n\r\n      conn.destroy({ force: true }, cb);\r\n    },\r\n    err => {\r\n      if (err) {\r\n        if (typeof callback === 'function') {\r\n          callback(err, null);\r\n          return;\r\n        }\r\n      }\r\n\r\n      resetPoolState(this);\r\n\r\n      // create a new connection, this will ultimately trigger execution\r\n      createConnection(this, () => {\r\n        if (typeof callback === 'function') {\r\n          callback(null, null);\r\n        }\r\n      });\r\n    }\r\n  );\r\n};\r\n\r\n// Prepare the buffer that Pool.prototype.write() uses to send to the server\r\nfunction serializeCommand(self, command, callback) {\r\n  const originalCommandBuffer = command.toBin();\r\n\r\n  // Check whether we and the server have agreed to use a compressor\r\n  const shouldCompress = !!self.options.agreedCompressor;\r\n  if (!shouldCompress || !canCompress(command)) {\r\n    return callback(null, originalCommandBuffer);\r\n  }\r\n\r\n  // Transform originalCommandBuffer into OP_COMPRESSED\r\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\r\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\r\n\r\n  // Extract information needed for OP_COMPRESSED from the uncompressed message\r\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\r\n\r\n  // Compress the message body\r\n  compress(self, messageToBeCompressed, function(err, compressedMessage) {\r\n    if (err) return callback(err, null);\r\n\r\n    // Create the msgHeader of OP_COMPRESSED\r\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\r\n    msgHeader.writeInt32LE(\r\n      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\r\n      0\r\n    ); // messageLength\r\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\r\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\r\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\r\n\r\n    // Create the compression details of OP_COMPRESSED\r\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\r\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\r\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\r\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\r\n\r\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\r\n  });\r\n}\r\n\r\n/**\r\n * Write a message to MongoDB\r\n * @method\r\n * @return {Connection}\r\n */\r\nPool.prototype.write = function(command, options, cb) {\r\n  var self = this;\r\n  // Ensure we have a callback\r\n  if (typeof options === 'function') {\r\n    cb = options;\r\n  }\r\n\r\n  // Always have options\r\n  options = options || {};\r\n\r\n  // We need to have a callback function unless the message returns no response\r\n  if (!(typeof cb === 'function') && !options.noResponse) {\r\n    throw new MongoError('write method must provide a callback');\r\n  }\r\n\r\n  // Pool was destroyed error out\r\n  if (this.state === DESTROYED || this.state === DESTROYING) {\r\n    cb(new MongoError('pool destroyed'));\r\n    return;\r\n  }\r\n\r\n  if (this.state === DRAINING) {\r\n    cb(new MongoError('pool is draining, new operations prohibited'));\r\n    return;\r\n  }\r\n\r\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\r\n    // if we have a domain bind to it\r\n    var oldCb = cb;\r\n    cb = process.domain.bind(function() {\r\n      // v8 - argumentsToArray one-liner\r\n      var args = new Array(arguments.length);\r\n      for (var i = 0; i < arguments.length; i++) {\r\n        args[i] = arguments[i];\r\n      }\r\n      // bounce off event loop so domain switch takes place\r\n      process.nextTick(function() {\r\n        oldCb.apply(null, args);\r\n      });\r\n    });\r\n  }\r\n\r\n  // Do we have an operation\r\n  var operation = {\r\n    cb: cb,\r\n    raw: false,\r\n    promoteLongs: true,\r\n    promoteValues: true,\r\n    promoteBuffers: false,\r\n    fullResult: false\r\n  };\r\n\r\n  // Set the options for the parsing\r\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\r\n  operation.promoteValues =\r\n    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\r\n  operation.promoteBuffers =\r\n    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\r\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\r\n  operation.immediateRelease =\r\n    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\r\n  operation.documentsReturnedIn = options.documentsReturnedIn;\r\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\r\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\r\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\r\n  operation.session = options.session || null;\r\n\r\n  // Optional per operation socketTimeout\r\n  operation.socketTimeout = options.socketTimeout;\r\n  operation.monitoring = options.monitoring;\r\n\r\n  // Get the requestId\r\n  operation.requestId = command.requestId;\r\n\r\n  // If command monitoring is enabled we need to modify the callback here\r\n  if (self.options.monitorCommands) {\r\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\r\n\r\n    operation.started = now();\r\n    operation.cb = (err, reply) => {\r\n      if (err) {\r\n        self.emit(\r\n          'commandFailed',\r\n          new apm.CommandFailedEvent(this, command, err, operation.started)\r\n        );\r\n      } else {\r\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\r\n          self.emit(\r\n            'commandFailed',\r\n            new apm.CommandFailedEvent(this, command, reply.result, operation.started)\r\n          );\r\n        } else {\r\n          self.emit(\r\n            'commandSucceeded',\r\n            new apm.CommandSucceededEvent(this, command, reply, operation.started)\r\n          );\r\n        }\r\n      }\r\n\r\n      if (typeof cb === 'function') cb(err, reply);\r\n    };\r\n  }\r\n\r\n  // Prepare the operation buffer\r\n  serializeCommand(self, command, (err, serializedBuffers) => {\r\n    if (err) throw err;\r\n\r\n    // Set the operation's buffer to the serialization of the commands\r\n    operation.buffer = serializedBuffers;\r\n\r\n    // If we have a monitoring operation schedule as the very first operation\r\n    // Otherwise add to back of queue\r\n    if (options.monitoring) {\r\n      self.queue.unshift(operation);\r\n    } else {\r\n      self.queue.push(operation);\r\n    }\r\n\r\n    // Attempt to execute the operation\r\n    if (!self.executing) {\r\n      process.nextTick(function() {\r\n        _execute(self)();\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\n// Return whether a command contains an uncompressible command term\r\n// Will return true if command contains no uncompressible command terms\r\nfunction canCompress(command) {\r\n  const commandDoc = command instanceof Msg ? command.command : command.query;\r\n  const commandName = Object.keys(commandDoc)[0];\r\n  return !uncompressibleCommands.has(commandName);\r\n}\r\n\r\n// Remove connection method\r\nfunction remove(connection, connections) {\r\n  for (var i = 0; i < connections.length; i++) {\r\n    if (connections[i] === connection) {\r\n      connections.splice(i, 1);\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction removeConnection(self, connection) {\r\n  if (remove(connection, self.availableConnections)) return;\r\n  if (remove(connection, self.inUseConnections)) return;\r\n}\r\n\r\nfunction createConnection(pool, callback) {\r\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\r\n    if (typeof callback === 'function') {\r\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  pool.connectingConnections++;\r\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\r\n    pool.connectingConnections--;\r\n\r\n    if (err) {\r\n      if (pool.logger.isDebug()) {\r\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\r\n      }\r\n\r\n      // check if reconnect is enabled, and attempt retry if so\r\n      if (!pool.reconnectId && pool.options.reconnect) {\r\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\r\n          callback(err);\r\n          return;\r\n        }\r\n\r\n        pool.reconnectError = err;\r\n        pool.reconnectId = setTimeout(\r\n          attemptReconnect(pool, callback),\r\n          pool.options.reconnectInterval\r\n        );\r\n\r\n        return;\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        callback(err);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // the pool might have been closed since we started creating the connection\r\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\r\n      if (typeof callback === 'function') {\r\n        callback(new MongoError('Pool was destroyed after connection creation'));\r\n      }\r\n\r\n      connection.destroy();\r\n      return;\r\n    }\r\n\r\n    // otherwise, connect relevant event handlers and add it to our available connections\r\n    connection.on('error', pool._connectionErrorHandler);\r\n    connection.on('close', pool._connectionCloseHandler);\r\n    connection.on('timeout', pool._connectionTimeoutHandler);\r\n    connection.on('parseError', pool._connectionParseErrorHandler);\r\n    connection.on('message', pool._messageHandler);\r\n\r\n    pool.availableConnections.push(connection);\r\n\r\n    // if a callback was provided, return the connection\r\n    if (typeof callback === 'function') {\r\n      callback(null, connection);\r\n    }\r\n\r\n    // immediately execute any waiting work\r\n    _execute(pool)();\r\n  });\r\n}\r\n\r\nfunction flushMonitoringOperations(queue) {\r\n  for (var i = 0; i < queue.length; i++) {\r\n    if (queue[i].monitoring) {\r\n      var workItem = queue[i];\r\n      queue.splice(i, 1);\r\n      workItem.cb(\r\n        new MongoError({ message: 'no connection available for monitoring', driver: true })\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction _execute(self) {\r\n  return function() {\r\n    if (self.state === DESTROYED) return;\r\n    // Already executing, skip\r\n    if (self.executing) return;\r\n    // Set pool as executing\r\n    self.executing = true;\r\n\r\n    // New pool connections are in progress, wait them to finish\r\n    // before executing any more operation to ensure distribution of\r\n    // operations\r\n    if (self.connectingConnections > 0) {\r\n      self.executing = false;\r\n      return;\r\n    }\r\n\r\n    // As long as we have available connections\r\n    // eslint-disable-next-line\r\n    while (true) {\r\n      // Total availble connections\r\n      const totalConnections = totalConnectionCount(self);\r\n\r\n      // No available connections available, flush any monitoring ops\r\n      if (self.availableConnections.length === 0) {\r\n        // Flush any monitoring operations\r\n        flushMonitoringOperations(self.queue);\r\n\r\n        // Try to create a new connection to execute stuck operation\r\n        if (totalConnections < self.options.size && self.queue.length > 0) {\r\n          createConnection(self);\r\n        }\r\n\r\n        break;\r\n      }\r\n\r\n      // No queue break\r\n      if (self.queue.length === 0) {\r\n        break;\r\n      }\r\n\r\n      var connection = null;\r\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);\r\n\r\n      // No connection found that has no work on it, just pick one for pipelining\r\n      if (connections.length === 0) {\r\n        connection =\r\n          self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\r\n      } else {\r\n        connection = connections[self.connectionIndex++ % connections.length];\r\n      }\r\n\r\n      // Is the connection connected\r\n      if (!connection.isConnected()) {\r\n        // Remove the disconnected connection\r\n        removeConnection(self, connection);\r\n        // Flush any monitoring operations in the queue, failing fast\r\n        flushMonitoringOperations(self.queue);\r\n        break;\r\n      }\r\n\r\n      // Get the next work item\r\n      var workItem = self.queue.shift();\r\n\r\n      // If we are monitoring we need to use a connection that is not\r\n      // running another operation to avoid socket timeout changes\r\n      // affecting an existing operation\r\n      if (workItem.monitoring) {\r\n        var foundValidConnection = false;\r\n\r\n        for (let i = 0; i < self.availableConnections.length; i++) {\r\n          // If the connection is connected\r\n          // And there are no pending workItems on it\r\n          // Then we can safely use it for monitoring.\r\n          if (\r\n            self.availableConnections[i].isConnected() &&\r\n            self.availableConnections[i].workItems.length === 0\r\n          ) {\r\n            foundValidConnection = true;\r\n            connection = self.availableConnections[i];\r\n            break;\r\n          }\r\n        }\r\n\r\n        // No safe connection found, attempt to grow the connections\r\n        // if possible and break from the loop\r\n        if (!foundValidConnection) {\r\n          // Put workItem back on the queue\r\n          self.queue.unshift(workItem);\r\n\r\n          // Attempt to grow the pool if it's not yet maxsize\r\n          if (totalConnections < self.options.size && self.queue.length > 0) {\r\n            // Create a new connection\r\n            createConnection(self);\r\n          }\r\n\r\n          // Re-execute the operation\r\n          setTimeout(() => _execute(self)(), 10);\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Don't execute operation until we have a full pool\r\n      if (totalConnections < self.options.size) {\r\n        // Connection has work items, then put it back on the queue\r\n        // and create a new connection\r\n        if (connection.workItems.length > 0) {\r\n          // Lets put the workItem back on the list\r\n          self.queue.unshift(workItem);\r\n          // Create a new connection\r\n          createConnection(self);\r\n          // Break from the loop\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Get actual binary commands\r\n      var buffer = workItem.buffer;\r\n\r\n      // If we are monitoring take the connection of the availableConnections\r\n      if (workItem.monitoring) {\r\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\r\n      }\r\n\r\n      // Track the executing commands on the mongo server\r\n      // as long as there is an expected response\r\n      if (!workItem.noResponse) {\r\n        connection.workItems.push(workItem);\r\n      }\r\n\r\n      // We have a custom socketTimeout\r\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\r\n        connection.setSocketTimeout(workItem.socketTimeout);\r\n      }\r\n\r\n      // Capture if write was successful\r\n      var writeSuccessful = true;\r\n\r\n      // Put operation on the wire\r\n      if (Array.isArray(buffer)) {\r\n        for (let i = 0; i < buffer.length; i++) {\r\n          writeSuccessful = connection.write(buffer[i]);\r\n        }\r\n      } else {\r\n        writeSuccessful = connection.write(buffer);\r\n      }\r\n\r\n      // if the command is designated noResponse, call the callback immeditely\r\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\r\n        workItem.cb(null, null);\r\n      }\r\n\r\n      if (writeSuccessful === false) {\r\n        // If write not successful put back on queue\r\n        self.queue.unshift(workItem);\r\n        // Remove the disconnected connection\r\n        removeConnection(self, connection);\r\n        // Flush any monitoring operations in the queue, failing fast\r\n        flushMonitoringOperations(self.queue);\r\n        break;\r\n      }\r\n    }\r\n\r\n    self.executing = false;\r\n  };\r\n}\r\n\r\n// Make execution loop available for testing\r\nPool._execute = _execute;\r\n\r\n/**\r\n * A server connect event, used to verify that the connection is up and running\r\n *\r\n * @event Pool#connect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * A server reconnect event, used to verify that pool reconnected.\r\n *\r\n * @event Pool#reconnect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection closed, all pool connections closed\r\n *\r\n * @event Pool#close\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection caused an error, all pool connections closed\r\n *\r\n * @event Pool#error\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The server connection timed out, all pool connections closed\r\n *\r\n * @event Pool#timeout\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver experienced an invalid message, all pool connections closed\r\n *\r\n * @event Pool#parseError\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver attempted to reconnect\r\n *\r\n * @event Pool#attemptReconnect\r\n * @type {Pool}\r\n */\r\n\r\n/**\r\n * The driver exhausted all reconnect attempts\r\n *\r\n * @event Pool#reconnectFailed\r\n * @type {Pool}\r\n */\r\n\r\nmodule.exports = Pool;\r\n"]},"metadata":{},"sourceType":"script"}