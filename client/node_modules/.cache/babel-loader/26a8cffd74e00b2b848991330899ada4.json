{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nfunction aes256CbcEncryptHook(key, iv, input, output) {\n  let result;\n\n  try {\n    let cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n    cipher.setAutoPadding(false);\n    result = cipher.update(input);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction aes256CbcDecryptHook(key, iv, input, output) {\n  let result;\n\n  try {\n    let cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n    cipher.setAutoPadding(false);\n    result = cipher.update(input);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction randomHook(buffer, count) {\n  try {\n    crypto.randomFillSync(buffer, 0, count);\n  } catch (e) {\n    return e;\n  }\n\n  return count;\n}\n\nfunction randomHookNode4(buffer, count) {\n  let result;\n\n  try {\n    result = crypto.randomBytes(count);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(buffer);\n  return count;\n}\n\nfunction sha256Hook(input, output) {\n  let result;\n\n  try {\n    result = crypto.createHash('sha256').update(input).digest();\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction makeHmacHook(algorithm) {\n  return (key, input, output) => {\n    let result;\n\n    try {\n      result = crypto.createHmac(algorithm, key).update(input).digest();\n    } catch (e) {\n      return e;\n    }\n\n    result.copy(output);\n    return result.length;\n  };\n}\n\nfunction signRsaSha256Hook(key, input, output) {\n  let result;\n\n  try {\n    const signer = crypto.createSign('sha256WithRSAEncryption');\n    const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----\\n${key.toString('base64')}\\n-----END PRIVATE KEY-----\\n`);\n    result = signer.update(input).end().sign(privateKey);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nmodule.exports = {\n  aes256CbcEncryptHook,\n  aes256CbcDecryptHook,\n  randomHook: typeof crypto.randomFillSync === 'function' ? randomHook : randomHookNode4,\n  hmacSha512Hook: makeHmacHook('sha512'),\n  hmacSha256Hook: makeHmacHook('sha256'),\n  sha256Hook,\n  signRsaSha256Hook\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb-client-encryption/lib/cryptoCallbacks.js"],"names":["crypto","require","aes256CbcEncryptHook","key","iv","input","output","result","cipher","createCipheriv","setAutoPadding","update","e","copy","length","aes256CbcDecryptHook","createDecipheriv","randomHook","buffer","count","randomFillSync","randomHookNode4","randomBytes","sha256Hook","createHash","digest","makeHmacHook","algorithm","createHmac","signRsaSha256Hook","signer","createSign","privateKey","Buffer","from","toString","end","sign","module","exports","hmacSha512Hook","hmacSha256Hook"],"mappings":"AAAA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AAEA,SAASC,oBAAT,CAA8BC,GAA9B,EAAmCC,EAAnC,EAAuCC,KAAvC,EAA8CC,MAA9C,EAAsD;AACpD,MAAIC,MAAJ;;AAEA,MAAI;AACF,QAAIC,MAAM,GAAGR,MAAM,CAACS,cAAP,CAAsB,aAAtB,EAAqCN,GAArC,EAA0CC,EAA1C,CAAb;AACAI,IAAAA,MAAM,CAACE,cAAP,CAAsB,KAAtB;AACAH,IAAAA,MAAM,GAAGC,MAAM,CAACG,MAAP,CAAcN,KAAd,CAAT;AACD,GAJD,CAIE,OAAOO,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AAEDL,EAAAA,MAAM,CAACM,IAAP,CAAYP,MAAZ;AACA,SAAOC,MAAM,CAACO,MAAd;AACD;;AAED,SAASC,oBAAT,CAA8BZ,GAA9B,EAAmCC,EAAnC,EAAuCC,KAAvC,EAA8CC,MAA9C,EAAsD;AACpD,MAAIC,MAAJ;;AACA,MAAI;AACF,QAAIC,MAAM,GAAGR,MAAM,CAACgB,gBAAP,CAAwB,aAAxB,EAAuCb,GAAvC,EAA4CC,EAA5C,CAAb;AACAI,IAAAA,MAAM,CAACE,cAAP,CAAsB,KAAtB;AACAH,IAAAA,MAAM,GAAGC,MAAM,CAACG,MAAP,CAAcN,KAAd,CAAT;AACD,GAJD,CAIE,OAAOO,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AAEDL,EAAAA,MAAM,CAACM,IAAP,CAAYP,MAAZ;AACA,SAAOC,MAAM,CAACO,MAAd;AACD;;AAED,SAASG,UAAT,CAAoBC,MAApB,EAA4BC,KAA5B,EAAmC;AACjC,MAAI;AACFnB,IAAAA,MAAM,CAACoB,cAAP,CAAsBF,MAAtB,EAA8B,CAA9B,EAAiCC,KAAjC;AACD,GAFD,CAEE,OAAOP,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AACD,SAAOO,KAAP;AACD;;AAED,SAASE,eAAT,CAAyBH,MAAzB,EAAiCC,KAAjC,EAAwC;AACtC,MAAIZ,MAAJ;;AACA,MAAI;AACFA,IAAAA,MAAM,GAAGP,MAAM,CAACsB,WAAP,CAAmBH,KAAnB,CAAT;AACD,GAFD,CAEE,OAAOP,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AAEDL,EAAAA,MAAM,CAACM,IAAP,CAAYK,MAAZ;AACA,SAAOC,KAAP;AACD;;AAED,SAASI,UAAT,CAAoBlB,KAApB,EAA2BC,MAA3B,EAAmC;AACjC,MAAIC,MAAJ;;AACA,MAAI;AACFA,IAAAA,MAAM,GAAGP,MAAM,CACZwB,UADM,CACK,QADL,EAENb,MAFM,CAECN,KAFD,EAGNoB,MAHM,EAAT;AAID,GALD,CAKE,OAAOb,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AAEDL,EAAAA,MAAM,CAACM,IAAP,CAAYP,MAAZ;AACA,SAAOC,MAAM,CAACO,MAAd;AACD;;AAED,SAASY,YAAT,CAAsBC,SAAtB,EAAiC;AAC/B,SAAO,CAACxB,GAAD,EAAME,KAAN,EAAaC,MAAb,KAAwB;AAC7B,QAAIC,MAAJ;;AACA,QAAI;AACFA,MAAAA,MAAM,GAAGP,MAAM,CACZ4B,UADM,CACKD,SADL,EACgBxB,GADhB,EAENQ,MAFM,CAECN,KAFD,EAGNoB,MAHM,EAAT;AAID,KALD,CAKE,OAAOb,CAAP,EAAU;AACV,aAAOA,CAAP;AACD;;AAEDL,IAAAA,MAAM,CAACM,IAAP,CAAYP,MAAZ;AACA,WAAOC,MAAM,CAACO,MAAd;AACD,GAbD;AAcD;;AAED,SAASe,iBAAT,CAA2B1B,GAA3B,EAAgCE,KAAhC,EAAuCC,MAAvC,EAA+C;AAC7C,MAAIC,MAAJ;;AACA,MAAI;AACF,UAAMuB,MAAM,GAAG9B,MAAM,CAAC+B,UAAP,CAAkB,yBAAlB,CAAf;AACA,UAAMC,UAAU,GAAGC,MAAM,CAACC,IAAP,CAChB,gCAA+B/B,GAAG,CAACgC,QAAJ,CAAa,QAAb,CAAuB,+BADtC,CAAnB;AAIA5B,IAAAA,MAAM,GAAGuB,MAAM,CACZnB,MADM,CACCN,KADD,EAEN+B,GAFM,GAGNC,IAHM,CAGDL,UAHC,CAAT;AAID,GAVD,CAUE,OAAOpB,CAAP,EAAU;AACV,WAAOA,CAAP;AACD;;AAEDL,EAAAA,MAAM,CAACM,IAAP,CAAYP,MAAZ;AACA,SAAOC,MAAM,CAACO,MAAd;AACD;;AAEDwB,MAAM,CAACC,OAAP,GAAiB;AACfrC,EAAAA,oBADe;AAEfa,EAAAA,oBAFe;AAGfE,EAAAA,UAAU,EAAE,OAAOjB,MAAM,CAACoB,cAAd,KAAiC,UAAjC,GAA8CH,UAA9C,GAA2DI,eAHxD;AAIfmB,EAAAA,cAAc,EAAEd,YAAY,CAAC,QAAD,CAJb;AAKfe,EAAAA,cAAc,EAAEf,YAAY,CAAC,QAAD,CALb;AAMfH,EAAAA,UANe;AAOfM,EAAAA;AAPe,CAAjB","sourcesContent":["'use strict';\nconst crypto = require('crypto');\n\nfunction aes256CbcEncryptHook(key, iv, input, output) {\n  let result;\n\n  try {\n    let cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n    cipher.setAutoPadding(false);\n    result = cipher.update(input);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction aes256CbcDecryptHook(key, iv, input, output) {\n  let result;\n  try {\n    let cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n    cipher.setAutoPadding(false);\n    result = cipher.update(input);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction randomHook(buffer, count) {\n  try {\n    crypto.randomFillSync(buffer, 0, count);\n  } catch (e) {\n    return e;\n  }\n  return count;\n}\n\nfunction randomHookNode4(buffer, count) {\n  let result;\n  try {\n    result = crypto.randomBytes(count);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(buffer);\n  return count;\n}\n\nfunction sha256Hook(input, output) {\n  let result;\n  try {\n    result = crypto\n      .createHash('sha256')\n      .update(input)\n      .digest();\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nfunction makeHmacHook(algorithm) {\n  return (key, input, output) => {\n    let result;\n    try {\n      result = crypto\n        .createHmac(algorithm, key)\n        .update(input)\n        .digest();\n    } catch (e) {\n      return e;\n    }\n\n    result.copy(output);\n    return result.length;\n  };\n}\n\nfunction signRsaSha256Hook(key, input, output) {\n  let result;\n  try {\n    const signer = crypto.createSign('sha256WithRSAEncryption');\n    const privateKey = Buffer.from(\n      `-----BEGIN PRIVATE KEY-----\\n${key.toString('base64')}\\n-----END PRIVATE KEY-----\\n`\n    );\n\n    result = signer\n      .update(input)\n      .end()\n      .sign(privateKey);\n  } catch (e) {\n    return e;\n  }\n\n  result.copy(output);\n  return result.length;\n}\n\nmodule.exports = {\n  aes256CbcEncryptHook,\n  aes256CbcDecryptHook,\n  randomHook: typeof crypto.randomFillSync === 'function' ? randomHook : randomHookNode4,\n  hmacSha512Hook: makeHmacHook('sha512'),\n  hmacSha256Hook: makeHmacHook('sha256'),\n  sha256Hook,\n  signRsaSha256Hook\n};\n"]},"metadata":{},"sourceType":"script"}