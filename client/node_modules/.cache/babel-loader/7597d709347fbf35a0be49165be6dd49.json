{"ast":null,"code":"'use strict';\n\nconst Denque = require('denque');\n\nconst EventEmitter = require('events');\n\nconst isResumableError = require('./error').isResumableError;\n\nconst MongoError = require('./core').MongoError;\n\nconst Cursor = require('./cursor');\n\nconst relayEvents = require('./core/utils').relayEvents;\n\nconst maxWireVersion = require('./core/utils').maxWireVersion;\n\nconst maybePromise = require('./utils').maybePromise;\n\nconst now = require('./utils').now;\n\nconst calculateDurationInMs = require('./utils').calculateDurationInMs;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst kResumeQueue = Symbol('resumeQueue');\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n/**\r\n * @typedef ResumeToken\r\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\r\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\r\n */\n\n/**\r\n * @typedef OperationTime\r\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\r\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\r\n */\n\n/**\r\n * @typedef ChangeStreamOptions\r\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\r\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\r\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\r\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\r\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\r\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\r\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\r\n */\n\n/**\r\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\r\n * @class ChangeStream\r\n * @since 3.0.0\r\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\r\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\r\n * @param {ChangeStreamOptions} [options] Optional settings\r\n * @fires ChangeStream#close\r\n * @fires ChangeStream#change\r\n * @fires ChangeStream#end\r\n * @fires ChangeStream#error\r\n * @fires ChangeStream#resumeTokenChanged\r\n * @return {ChangeStream} a ChangeStream instance.\r\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n\n    const Collection = require('./collection');\n\n    const Db = require('./db');\n\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    }\n\n    this[kResumeQueue] = new Denque(); // Create contained Change Stream cursor\n\n    this.cursor = createChangeStreamCursor(this, options);\n    this.closed = false; // Listen for any `change` listeners being added to ChangeStream\n\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change => processNewChange(this, change));\n      }\n    }); // Listen for all `change` listeners being removed from ChangeStream\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n  /**\r\n   * @property {ResumeToken} resumeToken\r\n   * The cached resume token that will be used to resume\r\n   * after the most recently returned change.\r\n   */\n\n\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n  /**\r\n   * Check if there is any document still available in the Change Stream\r\n   * @function ChangeStream.prototype.hasNext\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @throws {MongoError}\r\n   * @returns {Promise|void} returns Promise if no callback passed\r\n   */\n\n\n  hasNext(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n\n        cursor.hasNext(cb);\n      });\n    });\n  }\n  /**\r\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\r\n   * @function ChangeStream.prototype.next\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @throws {MongoError}\r\n   * @returns {Promise|void} returns Promise if no callback passed\r\n   */\n\n\n  next(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n\n          processNewChange(this, change, cb);\n        });\n      });\n    });\n  }\n  /**\r\n   * Is the change stream closed\r\n   * @method ChangeStream.prototype.isClosed\r\n   * @return {boolean}\r\n   */\n\n\n  isClosed() {\n    return this.closed || this.cursor && this.cursor.isClosed();\n  }\n  /**\r\n   * Close the Change Stream\r\n   * @method ChangeStream.prototype.close\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @return {Promise} returns Promise if no callback passed\r\n   */\n\n\n  close(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      if (this.closed) return cb(); // flag the change stream as explicitly closed\n\n      this.closed = true;\n      if (!this.cursor) return cb(); // Tidy up the existing cursor\n\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n  /**\r\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\r\n   * @method\r\n   * @param {Writable} destination The destination for writing data\r\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\r\n   * @return {null}\r\n   */\n\n\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n  /**\r\n   * This method will remove the hooks set up for a previous pipe() call.\r\n   * @param {Writable} [destination] The destination for writing data\r\n   * @return {null}\r\n   */\n\n\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n\n    return this.cursor.unpipe(destination);\n  }\n  /**\r\n   * Return a modified Readable stream including a possible transform method.\r\n   * @method\r\n   * @param {object} [options] Optional settings.\r\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\r\n   * @return {Cursor}\r\n   */\n\n\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n  /**\r\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\r\n   * @return {null}\r\n   */\n\n\n  pause() {\n    return this.cursor.pause();\n  }\n  /**\r\n   * This method will cause the readable stream to resume emitting data events.\r\n   * @return {null}\r\n   */\n\n\n  resume() {\n    return this.cursor.resume();\n  }\n\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        const resumeKey = this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        result[resumeKey] = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {\n      this.resumeToken = this.cursorState.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n\n    this.hasReceived = true;\n  }\n\n  _processBatch(batchName, response) {\n    const cursor = response.cursor;\n\n    if (cursor.postBatchResumeToken) {\n      this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err || result == null) {\n        callback(err, result);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch('firstBatch', response);\n\n      this.emit('init', result);\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      this._processBatch('nextBatch', response);\n\n      this.emit('more', response);\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n\n}\n/**\r\n * @event ChangeStreamCursor#response\r\n * internal event DO NOT USE\r\n * @ignore\r\n */\n// Create a new change stream cursor based on self's configuration\n\n\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline, options), cursorOptions);\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n  /**\r\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\r\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\r\n   * then be passed as soon as it is available.\r\n   *\r\n   * @event ChangeStream#change\r\n   * @type {object}\r\n   */\n\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function (change) {\n      processNewChange(self, change);\n    });\n  }\n  /**\r\n   * Change stream close event\r\n   *\r\n   * @event ChangeStream#close\r\n   * @type {null}\r\n   */\n\n  /**\r\n   * Change stream end event\r\n   *\r\n   * @event ChangeStream#end\r\n   * @type {null}\r\n   */\n\n  /**\r\n   * Emitted each time the change stream stores a new resume token.\r\n   *\r\n   * @event ChangeStream#resumeTokenChanged\r\n   * @type {ResumeToken}\r\n   */\n\n  /**\r\n   * Fired when the stream encounters an error.\r\n   *\r\n   * @event ChangeStream#error\r\n   * @type {Error}\r\n   */\n\n\n  changeStreamCursor.on('error', function (error) {\n    processError(self, error);\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n\n    for (let pipeDestination of self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n} // This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\n\n\nconst SELECTION_TIMEOUT = 30000;\n\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = now();\n    }\n\n    const start = options.start || now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n\n    if (topology.isConnected({\n      readPreference\n    })) {\n      return callback();\n    }\n\n    if (calculateDurationInMs(start) > timeout) {\n      return callback(new MongoError('Timed out waiting for connection'));\n    }\n\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction processNewChange(changeStream, change, callback) {\n  const cursor = changeStream.cursor; // a null change means the cursor has been notified, implicitly closing the change stream\n\n  if (change == null) {\n    changeStream.closed = true;\n  }\n\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  }\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error('A change stream document has been received that lacks a resume token (_id).');\n    if (!callback) return changeStream.emit('error', noResumeTokenError);\n    return callback(noResumeTokenError);\n  } // cache the resume token\n\n\n  cursor.cacheResumeToken(change._id); // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n\n  changeStream.options.startAtOperationTime = undefined; // Return the change\n\n  if (!callback) return changeStream.emit('change', change);\n  return callback(undefined, change);\n}\n\nfunction processError(changeStream, error, callback) {\n  const topology = changeStream.topology;\n  const cursor = changeStream.cursor; // If the change stream has been closed explictly, do not process error.\n\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  } // if the resume succeeds, continue with the new cursor\n\n\n  function resumeWithCursor(newCursor) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  } // otherwise, raise an error and close the change stream\n\n\n  function unresumableError(err) {\n    if (!callback) {\n      changeStream.emit('error', err);\n      changeStream.emit('close');\n    }\n\n    processResumeQueue(changeStream, err);\n    changeStream.closed = true;\n  }\n\n  if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined; // stop listening to all events from old cursor\n\n    ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event)); // close internal cursor, ignore errors\n\n    cursor.close();\n    waitForTopologyConnected(topology, {\n      readPreference: cursor.options.readPreference\n    }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err); // create a new cursor, preserving the old cursor's options\n\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions); // attempt to continue in emitter mode\n\n      if (!callback) return resumeWithCursor(newCursor); // attempt to continue in iterator mode\n\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n\n  if (!callback) return changeStream.emit('error', error);\n  return callback(error);\n}\n/**\r\n * Safely provides a cursor across resume attempts\r\n *\r\n * @param {ChangeStream} changeStream the parent ChangeStream\r\n * @param {function} callback gets the cursor or error\r\n * @param {ChangeStreamCursor} [oldCursor] when resuming from an error, carry over options from previous cursor\r\n */\n\n\nfunction getCursor(changeStream, callback) {\n  if (changeStream.isClosed()) {\n    callback(new MongoError('ChangeStream is closed.'));\n    return;\n  } // if a cursor exists and it is open, return it\n\n\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  } // no cursor, queue callback until topology reconnects\n\n\n  changeStream[kResumeQueue].push(callback);\n}\n/**\r\n * Drain the resume queue when a new has become available\r\n *\r\n * @param {ChangeStream} changeStream the parent ChangeStream\r\n * @param {ChangeStreamCursor?} changeStream.cursor the new cursor\r\n * @param {Error} [err] error getting a new cursor\r\n */\n\n\nfunction processResumeQueue(changeStream, err) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n\n    if (changeStream.isClosed() && !err) {\n      request(new MongoError('Change Stream is not open.'));\n      return;\n    }\n\n    request(err, changeStream.cursor);\n  }\n}\n/**\r\n * The callback format for results\r\n * @callback ChangeStream~resultCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {(object|null)} result The result object if the command was executed successfully.\r\n */\n\n\nmodule.exports = ChangeStream;","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/change_stream.js"],"names":["Denque","require","EventEmitter","isResumableError","MongoError","Cursor","relayEvents","maxWireVersion","maybePromise","now","calculateDurationInMs","AggregateOperation","kResumeQueue","Symbol","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","DATABASE","CLUSTER","ChangeStream","constructor","parent","pipeline","options","Collection","Db","MongoClient","namespace","s","type","topology","db","serverConfig","TypeError","promiseLibrary","readPreference","cursor","createChangeStreamCursor","closed","on","eventName","listenerCount","change","processNewChange","removeAllListeners","resumeToken","hasNext","callback","cb","getCursor","err","next","error","push","processError","isClosed","close","forEach","event","undefined","pipe","destination","pipeDestinations","unpipe","indexOf","splice","stream","streamOptions","pause","resume","ChangeStreamCursor","operation","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","resumeOptions","result","optionName","key","resumeKey","hasReceived","server","cacheResumeToken","bufferedCount","cursorState","postBatchResumeToken","_processBatch","batchName","response","length","_initializeCursor","documents","operationTime","_getMore","self","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","cursorOptions","changeStreamCursor","cursorStream","pipeDestination","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","timeout","isConnected","changeStream","_id","noResumeTokenError","Error","resumeWithCursor","newCursor","processResumeQueue","unresumableError","request","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Denque = require('denque');\r\nconst EventEmitter = require('events');\r\nconst isResumableError = require('./error').isResumableError;\r\nconst MongoError = require('./core').MongoError;\r\nconst Cursor = require('./cursor');\r\nconst relayEvents = require('./core/utils').relayEvents;\r\nconst maxWireVersion = require('./core/utils').maxWireVersion;\r\nconst maybePromise = require('./utils').maybePromise;\r\nconst now = require('./utils').now;\r\nconst calculateDurationInMs = require('./utils').calculateDurationInMs;\r\nconst AggregateOperation = require('./operations/aggregate');\r\n\r\nconst kResumeQueue = Symbol('resumeQueue');\r\n\r\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\r\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\r\n  CHANGE_STREAM_OPTIONS\r\n);\r\n\r\nconst CHANGE_DOMAIN_TYPES = {\r\n  COLLECTION: Symbol('Collection'),\r\n  DATABASE: Symbol('Database'),\r\n  CLUSTER: Symbol('Cluster')\r\n};\r\n\r\n/**\r\n * @typedef ResumeToken\r\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\r\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\r\n */\r\n\r\n/**\r\n * @typedef OperationTime\r\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\r\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\r\n */\r\n\r\n/**\r\n * @typedef ChangeStreamOptions\r\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\r\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\r\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\r\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\r\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\r\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\r\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\r\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\r\n */\r\n\r\n/**\r\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\r\n * @class ChangeStream\r\n * @since 3.0.0\r\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\r\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\r\n * @param {ChangeStreamOptions} [options] Optional settings\r\n * @fires ChangeStream#close\r\n * @fires ChangeStream#change\r\n * @fires ChangeStream#end\r\n * @fires ChangeStream#error\r\n * @fires ChangeStream#resumeTokenChanged\r\n * @return {ChangeStream} a ChangeStream instance.\r\n */\r\nclass ChangeStream extends EventEmitter {\r\n  constructor(parent, pipeline, options) {\r\n    super();\r\n    const Collection = require('./collection');\r\n    const Db = require('./db');\r\n    const MongoClient = require('./mongo_client');\r\n\r\n    this.pipeline = pipeline || [];\r\n    this.options = options || {};\r\n\r\n    this.parent = parent;\r\n    this.namespace = parent.s.namespace;\r\n    if (parent instanceof Collection) {\r\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\r\n      this.topology = parent.s.db.serverConfig;\r\n    } else if (parent instanceof Db) {\r\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\r\n      this.topology = parent.serverConfig;\r\n    } else if (parent instanceof MongoClient) {\r\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\r\n      this.topology = parent.topology;\r\n    } else {\r\n      throw new TypeError(\r\n        'parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'\r\n      );\r\n    }\r\n\r\n    this.promiseLibrary = parent.s.promiseLibrary;\r\n    if (!this.options.readPreference && parent.s.readPreference) {\r\n      this.options.readPreference = parent.s.readPreference;\r\n    }\r\n\r\n    this[kResumeQueue] = new Denque();\r\n\r\n    // Create contained Change Stream cursor\r\n    this.cursor = createChangeStreamCursor(this, options);\r\n\r\n    this.closed = false;\r\n\r\n    // Listen for any `change` listeners being added to ChangeStream\r\n    this.on('newListener', eventName => {\r\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\r\n        this.cursor.on('data', change => processNewChange(this, change));\r\n      }\r\n    });\r\n\r\n    // Listen for all `change` listeners being removed from ChangeStream\r\n    this.on('removeListener', eventName => {\r\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\r\n        this.cursor.removeAllListeners('data');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @property {ResumeToken} resumeToken\r\n   * The cached resume token that will be used to resume\r\n   * after the most recently returned change.\r\n   */\r\n  get resumeToken() {\r\n    return this.cursor.resumeToken;\r\n  }\r\n\r\n  /**\r\n   * Check if there is any document still available in the Change Stream\r\n   * @function ChangeStream.prototype.hasNext\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @throws {MongoError}\r\n   * @returns {Promise|void} returns Promise if no callback passed\r\n   */\r\n  hasNext(callback) {\r\n    return maybePromise(this.parent, callback, cb => {\r\n      getCursor(this, (err, cursor) => {\r\n        if (err) return cb(err); // failed to resume, raise an error\r\n        cursor.hasNext(cb);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\r\n   * @function ChangeStream.prototype.next\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @throws {MongoError}\r\n   * @returns {Promise|void} returns Promise if no callback passed\r\n   */\r\n  next(callback) {\r\n    return maybePromise(this.parent, callback, cb => {\r\n      getCursor(this, (err, cursor) => {\r\n        if (err) return cb(err); // failed to resume, raise an error\r\n        cursor.next((error, change) => {\r\n          if (error) {\r\n            this[kResumeQueue].push(() => this.next(cb));\r\n            processError(this, error, cb);\r\n            return;\r\n          }\r\n          processNewChange(this, change, cb);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Is the change stream closed\r\n   * @method ChangeStream.prototype.isClosed\r\n   * @return {boolean}\r\n   */\r\n  isClosed() {\r\n    return this.closed || (this.cursor && this.cursor.isClosed());\r\n  }\r\n\r\n  /**\r\n   * Close the Change Stream\r\n   * @method ChangeStream.prototype.close\r\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\r\n   * @return {Promise} returns Promise if no callback passed\r\n   */\r\n  close(callback) {\r\n    return maybePromise(this.parent, callback, cb => {\r\n      if (this.closed) return cb();\r\n\r\n      // flag the change stream as explicitly closed\r\n      this.closed = true;\r\n\r\n      if (!this.cursor) return cb();\r\n\r\n      // Tidy up the existing cursor\r\n      const cursor = this.cursor;\r\n\r\n      return cursor.close(err => {\r\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\r\n        this.cursor = undefined;\r\n\r\n        return cb(err);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\r\n   * @method\r\n   * @param {Writable} destination The destination for writing data\r\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\r\n   * @return {null}\r\n   */\r\n  pipe(destination, options) {\r\n    if (!this.pipeDestinations) {\r\n      this.pipeDestinations = [];\r\n    }\r\n    this.pipeDestinations.push(destination);\r\n    return this.cursor.pipe(destination, options);\r\n  }\r\n\r\n  /**\r\n   * This method will remove the hooks set up for a previous pipe() call.\r\n   * @param {Writable} [destination] The destination for writing data\r\n   * @return {null}\r\n   */\r\n  unpipe(destination) {\r\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\r\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\r\n    }\r\n    return this.cursor.unpipe(destination);\r\n  }\r\n\r\n  /**\r\n   * Return a modified Readable stream including a possible transform method.\r\n   * @method\r\n   * @param {object} [options] Optional settings.\r\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\r\n   * @return {Cursor}\r\n   */\r\n  stream(options) {\r\n    this.streamOptions = options;\r\n    return this.cursor.stream(options);\r\n  }\r\n\r\n  /**\r\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\r\n   * @return {null}\r\n   */\r\n  pause() {\r\n    return this.cursor.pause();\r\n  }\r\n\r\n  /**\r\n   * This method will cause the readable stream to resume emitting data events.\r\n   * @return {null}\r\n   */\r\n  resume() {\r\n    return this.cursor.resume();\r\n  }\r\n}\r\n\r\nclass ChangeStreamCursor extends Cursor {\r\n  constructor(topology, operation, options) {\r\n    super(topology, operation, options);\r\n\r\n    options = options || {};\r\n    this._resumeToken = null;\r\n    this.startAtOperationTime = options.startAtOperationTime;\r\n\r\n    if (options.startAfter) {\r\n      this.resumeToken = options.startAfter;\r\n    } else if (options.resumeAfter) {\r\n      this.resumeToken = options.resumeAfter;\r\n    }\r\n  }\r\n\r\n  set resumeToken(token) {\r\n    this._resumeToken = token;\r\n    this.emit('resumeTokenChanged', token);\r\n  }\r\n\r\n  get resumeToken() {\r\n    return this._resumeToken;\r\n  }\r\n\r\n  get resumeOptions() {\r\n    const result = {};\r\n    for (const optionName of CURSOR_OPTIONS) {\r\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\r\n    }\r\n\r\n    if (this.resumeToken || this.startAtOperationTime) {\r\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\r\n\r\n      if (this.resumeToken) {\r\n        const resumeKey =\r\n          this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\r\n        result[resumeKey] = this.resumeToken;\r\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\r\n        result.startAtOperationTime = this.startAtOperationTime;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  cacheResumeToken(resumeToken) {\r\n    if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {\r\n      this.resumeToken = this.cursorState.postBatchResumeToken;\r\n    } else {\r\n      this.resumeToken = resumeToken;\r\n    }\r\n    this.hasReceived = true;\r\n  }\r\n\r\n  _processBatch(batchName, response) {\r\n    const cursor = response.cursor;\r\n    if (cursor.postBatchResumeToken) {\r\n      this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\r\n\r\n      if (cursor[batchName].length === 0) {\r\n        this.resumeToken = cursor.postBatchResumeToken;\r\n      }\r\n    }\r\n  }\r\n\r\n  _initializeCursor(callback) {\r\n    super._initializeCursor((err, result) => {\r\n      if (err || result == null) {\r\n        callback(err, result);\r\n        return;\r\n      }\r\n\r\n      const response = result.documents[0];\r\n\r\n      if (\r\n        this.startAtOperationTime == null &&\r\n        this.resumeAfter == null &&\r\n        this.startAfter == null &&\r\n        maxWireVersion(this.server) >= 7\r\n      ) {\r\n        this.startAtOperationTime = response.operationTime;\r\n      }\r\n\r\n      this._processBatch('firstBatch', response);\r\n\r\n      this.emit('init', result);\r\n      this.emit('response');\r\n      callback(err, result);\r\n    });\r\n  }\r\n\r\n  _getMore(callback) {\r\n    super._getMore((err, response) => {\r\n      if (err) {\r\n        callback(err);\r\n        return;\r\n      }\r\n\r\n      this._processBatch('nextBatch', response);\r\n\r\n      this.emit('more', response);\r\n      this.emit('response');\r\n      callback(err, response);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * @event ChangeStreamCursor#response\r\n * internal event DO NOT USE\r\n * @ignore\r\n */\r\n\r\n// Create a new change stream cursor based on self's configuration\r\nfunction createChangeStreamCursor(self, options) {\r\n  const changeStreamStageOptions = { fullDocument: options.fullDocument || 'default' };\r\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\r\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\r\n    changeStreamStageOptions.allChangesForCluster = true;\r\n  }\r\n\r\n  const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self.pipeline);\r\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\r\n\r\n  const changeStreamCursor = new ChangeStreamCursor(\r\n    self.topology,\r\n    new AggregateOperation(self.parent, pipeline, options),\r\n    cursorOptions\r\n  );\r\n\r\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\r\n\r\n  /**\r\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\r\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\r\n   * then be passed as soon as it is available.\r\n   *\r\n   * @event ChangeStream#change\r\n   * @type {object}\r\n   */\r\n  if (self.listenerCount('change') > 0) {\r\n    changeStreamCursor.on('data', function(change) {\r\n      processNewChange(self, change);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Change stream close event\r\n   *\r\n   * @event ChangeStream#close\r\n   * @type {null}\r\n   */\r\n\r\n  /**\r\n   * Change stream end event\r\n   *\r\n   * @event ChangeStream#end\r\n   * @type {null}\r\n   */\r\n\r\n  /**\r\n   * Emitted each time the change stream stores a new resume token.\r\n   *\r\n   * @event ChangeStream#resumeTokenChanged\r\n   * @type {ResumeToken}\r\n   */\r\n\r\n  /**\r\n   * Fired when the stream encounters an error.\r\n   *\r\n   * @event ChangeStream#error\r\n   * @type {Error}\r\n   */\r\n  changeStreamCursor.on('error', function(error) {\r\n    processError(self, error);\r\n  });\r\n\r\n  if (self.pipeDestinations) {\r\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\r\n    for (let pipeDestination of self.pipeDestinations) {\r\n      cursorStream.pipe(pipeDestination);\r\n    }\r\n  }\r\n\r\n  return changeStreamCursor;\r\n}\r\n\r\nfunction applyKnownOptions(target, source, optionNames) {\r\n  optionNames.forEach(name => {\r\n    if (source[name]) {\r\n      target[name] = source[name];\r\n    }\r\n  });\r\n\r\n  return target;\r\n}\r\n\r\n// This method performs a basic server selection loop, satisfying the requirements of\r\n// ChangeStream resumability until the new SDAM layer can be used.\r\nconst SELECTION_TIMEOUT = 30000;\r\nfunction waitForTopologyConnected(topology, options, callback) {\r\n  setTimeout(() => {\r\n    if (options && options.start == null) {\r\n      options.start = now();\r\n    }\r\n\r\n    const start = options.start || now();\r\n    const timeout = options.timeout || SELECTION_TIMEOUT;\r\n    const readPreference = options.readPreference;\r\n    if (topology.isConnected({ readPreference })) {\r\n      return callback();\r\n    }\r\n\r\n    if (calculateDurationInMs(start) > timeout) {\r\n      return callback(new MongoError('Timed out waiting for connection'));\r\n    }\r\n\r\n    waitForTopologyConnected(topology, options, callback);\r\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\r\n}\r\n\r\nfunction processNewChange(changeStream, change, callback) {\r\n  const cursor = changeStream.cursor;\r\n\r\n  // a null change means the cursor has been notified, implicitly closing the change stream\r\n  if (change == null) {\r\n    changeStream.closed = true;\r\n  }\r\n\r\n  if (changeStream.closed) {\r\n    if (callback) callback(new MongoError('ChangeStream is closed'));\r\n    return;\r\n  }\r\n\r\n  if (change && !change._id) {\r\n    const noResumeTokenError = new Error(\r\n      'A change stream document has been received that lacks a resume token (_id).'\r\n    );\r\n\r\n    if (!callback) return changeStream.emit('error', noResumeTokenError);\r\n    return callback(noResumeTokenError);\r\n  }\r\n\r\n  // cache the resume token\r\n  cursor.cacheResumeToken(change._id);\r\n\r\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\r\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\r\n  changeStream.options.startAtOperationTime = undefined;\r\n\r\n  // Return the change\r\n  if (!callback) return changeStream.emit('change', change);\r\n  return callback(undefined, change);\r\n}\r\n\r\nfunction processError(changeStream, error, callback) {\r\n  const topology = changeStream.topology;\r\n  const cursor = changeStream.cursor;\r\n\r\n  // If the change stream has been closed explictly, do not process error.\r\n  if (changeStream.closed) {\r\n    if (callback) callback(new MongoError('ChangeStream is closed'));\r\n    return;\r\n  }\r\n\r\n  // if the resume succeeds, continue with the new cursor\r\n  function resumeWithCursor(newCursor) {\r\n    changeStream.cursor = newCursor;\r\n    processResumeQueue(changeStream);\r\n  }\r\n\r\n  // otherwise, raise an error and close the change stream\r\n  function unresumableError(err) {\r\n    if (!callback) {\r\n      changeStream.emit('error', err);\r\n      changeStream.emit('close');\r\n    }\r\n    processResumeQueue(changeStream, err);\r\n    changeStream.closed = true;\r\n  }\r\n\r\n  if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {\r\n    changeStream.cursor = undefined;\r\n\r\n    // stop listening to all events from old cursor\r\n    ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\r\n\r\n    // close internal cursor, ignore errors\r\n    cursor.close();\r\n\r\n    waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, err => {\r\n      // if the topology can't reconnect, close the stream\r\n      if (err) return unresumableError(err);\r\n\r\n      // create a new cursor, preserving the old cursor's options\r\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\r\n\r\n      // attempt to continue in emitter mode\r\n      if (!callback) return resumeWithCursor(newCursor);\r\n\r\n      // attempt to continue in iterator mode\r\n      newCursor.hasNext(err => {\r\n        // if there's an error immediately after resuming, close the stream\r\n        if (err) return unresumableError(err);\r\n        resumeWithCursor(newCursor);\r\n      });\r\n    });\r\n    return;\r\n  }\r\n\r\n  if (!callback) return changeStream.emit('error', error);\r\n  return callback(error);\r\n}\r\n\r\n/**\r\n * Safely provides a cursor across resume attempts\r\n *\r\n * @param {ChangeStream} changeStream the parent ChangeStream\r\n * @param {function} callback gets the cursor or error\r\n * @param {ChangeStreamCursor} [oldCursor] when resuming from an error, carry over options from previous cursor\r\n */\r\nfunction getCursor(changeStream, callback) {\r\n  if (changeStream.isClosed()) {\r\n    callback(new MongoError('ChangeStream is closed.'));\r\n    return;\r\n  }\r\n\r\n  // if a cursor exists and it is open, return it\r\n  if (changeStream.cursor) {\r\n    callback(undefined, changeStream.cursor);\r\n    return;\r\n  }\r\n\r\n  // no cursor, queue callback until topology reconnects\r\n  changeStream[kResumeQueue].push(callback);\r\n}\r\n\r\n/**\r\n * Drain the resume queue when a new has become available\r\n *\r\n * @param {ChangeStream} changeStream the parent ChangeStream\r\n * @param {ChangeStreamCursor?} changeStream.cursor the new cursor\r\n * @param {Error} [err] error getting a new cursor\r\n */\r\nfunction processResumeQueue(changeStream, err) {\r\n  while (changeStream[kResumeQueue].length) {\r\n    const request = changeStream[kResumeQueue].pop();\r\n    if (changeStream.isClosed() && !err) {\r\n      request(new MongoError('Change Stream is not open.'));\r\n      return;\r\n    }\r\n    request(err, changeStream.cursor);\r\n  }\r\n}\r\n\r\n/**\r\n * The callback format for results\r\n * @callback ChangeStream~resultCallback\r\n * @param {MongoError} error An error instance representing the error during the execution.\r\n * @param {(object|null)} result The result object if the command was executed successfully.\r\n */\r\n\r\nmodule.exports = ChangeStream;\r\n"]},"metadata":{},"sourceType":"script"}