{"ast":null,"code":"'use strict';\n\nmodule.exports = function (modules) {\n  const mc = require('bindings')('mongocrypt');\n\n  const common = require('./common');\n\n  const databaseNamespace = common.databaseNamespace;\n  const StateMachine = modules.stateMachine.StateMachine;\n\n  const MongocryptdManager = require('./mongocryptdManager').MongocryptdManager;\n\n  const MongoClient = modules.mongodb.MongoClient;\n  const MongoError = modules.mongodb.MongoError;\n\n  const cryptoCallbacks = require('./cryptoCallbacks');\n  /**\n   * Configuration options for a automatic client encryption.\n   *\n   * @typedef {Object} AutoEncrypter~AutoEncryptionOptions\n   * @property {MongoClient} [keyVaultClient] A `MongoClient` used to fetch keys from a key vault\n   * @property {string} [keyVaultNamespace] The namespace where keys are stored in the key vault\n   * @property {KMSProviders} [kmsProviders] Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [schemaMap] A map of namespaces to a local JSON schema for encryption\n   * @property {boolean} [bypassAutoEncryption] Allows the user to bypass auto encryption, maintaining implicit decryption\n   * @property {AutoEncrypter~logger} [options.logger] An optional hook to catch logging messages from the underlying encryption engine\n   * @property {AutoEncrypter~AutoEncryptionExtraOptions} [extraOptions] Extra options related to the mongocryptd process\n   */\n\n  /**\n   * Extra options related to the mongocryptd process\n   * @typedef {object} AutoEncrypter~AutoEncryptionExtraOptions\n   * @property {string} [mongocryptdURI] A local process the driver communicates with to determine how to encrypt values in a command. Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\n   * @property {boolean} [mongocryptdBypassSpawn=false] If true, autoEncryption will not attempt to spawn a mongocryptd before connecting\n   * @property {string} [mongocryptdSpawnPath] The path to the mongocryptd executable on the system\n   * @property {string[]} [mongocryptdSpawnArgs] Command line arguments to use when auto-spawning a mongocryptd\n   */\n\n  /**\n   * @callback AutoEncrypter~logger\n   * @description A callback that is invoked with logging information from\n   * the underlying C++ Bindings.\n   * @param {AutoEncrypter~logLevel} level The level of logging.\n   * @param {string} message The message to log\n   */\n\n  /**\n   * @name AutoEncrypter~logLevel\n   * @enum {number}\n   * @description\n   * The level of severity of the log message\n   *\n   * | Value | Level |\n   * |-------|-------|\n   * | 0 | Fatal Error |\n   * | 1 | Error |\n   * | 2 | Warning |\n   * | 3 | Info |\n   * | 4 | Trace |\n   */\n\n  /**\n   * @classdesc An internal class to be used by the driver for auto encryption\n   * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n   */\n\n\n  class AutoEncrypter {\n    /**\n     * Create an AutoEncrypter\n     *\n     * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n     *\n     * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n     * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n     * Schemas supplied in the schemaMap only apply to configuring automatic encryption for client side encryption.\n     * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n     * @param {MongoClient} client The client autoEncryption is enabled on\n     * @param {AutoEncrypter~AutoEncryptionOptions} [options] Optional settings\n     *\n     * @example\n     * // Enabling autoEncryption via a MongoClient\n     * const { MongoClient } = require('mongodb');\n     * const client = new MongoClient(URL, {\n     *   autoEncryption: {\n     *     kmsProviders: {\n     *       aws: {\n     *         accessKeyId: AWS_ACCESS_KEY,\n     *         secretAccessKey: AWS_SECRET_KEY\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * await client.connect();\n     * // From here on, the client will be encrypting / decrypting automatically\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n      this._mongocryptdManager = new MongocryptdManager(options.extraOptions);\n      this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, {\n        useNewUrlParser: true,\n        useUnifiedTopology: true,\n        serverSelectionTimeoutMS: 1000\n      });\n      this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._metaDataClient = options.metadataClient || client;\n      this._bypassEncryption = typeof options.bypassAutoEncryption === 'boolean' ? options.bypassAutoEncryption : false;\n      const mongoCryptOptions = {};\n\n      if (options.schemaMap) {\n        mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : this._bson.serialize(options.schemaMap);\n      }\n\n      if (options.kmsProviders) {\n        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options.kmsProviders) ? this._bson.serialize(options.kmsProviders) : options.kmsProviders;\n      }\n\n      if (options.logger) {\n        mongoCryptOptions.logger = options.logger;\n      }\n\n      Object.assign(mongoCryptOptions, {\n        cryptoCallbacks\n      });\n      this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);\n      this._contextCounter = 0;\n    }\n    /**\n     * @ignore\n     * @param {Function} callback Invoked when the mongocryptd client either successfully connects or errors\n     */\n\n\n    init(callback) {\n      const _callback = (err, res) => {\n        if (err && err.message && (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))) {\n          callback(new MongoError('Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn'));\n          return;\n        }\n\n        callback(err, res);\n      };\n\n      if (this._mongocryptdManager.bypassSpawn) {\n        return this._mongocryptdClient.connect(_callback);\n      }\n\n      this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));\n    }\n    /**\n     * @ignore\n     * @param {Function} callback Invoked when the mongocryptd client either successfully disconnects or errors\n     */\n\n\n    teardown(force, callback) {\n      this._mongocryptdClient.close(force, callback);\n    }\n    /**\n     * @ignore\n     * Encrypt a command for a given namespace.\n     *\n     * @param {string} ns The namespace for this encryption context\n     * @param {object} cmd The command to encrypt\n     * @param {Function} callback\n     */\n\n\n    encrypt(ns, cmd, options, callback) {\n      if (typeof ns !== 'string') {\n        throw new TypeError('Parameter `ns` must be a string');\n      }\n\n      if (typeof cmd !== 'object') {\n        throw new TypeError('Parameter `cmd` must be an object');\n      }\n\n      if (typeof options === 'function' && callback == null) {\n        callback = options;\n        options = {};\n      } // If `bypassAutoEncryption` has been specified, don't encrypt\n\n\n      if (this._bypassEncryption) {\n        callback(undefined, cmd);\n        return;\n      }\n\n      const bson = this._bson;\n      const commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson.serialize(cmd, options);\n      let context;\n\n      try {\n        context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);\n      } catch (err) {\n        callback(err, null);\n        return;\n      } // TODO: should these be accessors from the addon?\n\n\n      context.id = this._contextCounter++;\n      context.ns = ns;\n      context.document = cmd;\n      const stateMachine = new StateMachine(Object.assign({\n        bson\n      }, options));\n      stateMachine.execute(this, context, callback);\n    }\n    /**\n     * @ignore\n     * Decrypt a command response\n     *\n     * @param {Buffer} buffer\n     * @param {Function} callback\n     */\n\n\n    decrypt(response, options, callback) {\n      if (typeof options === 'function' && callback == null) {\n        callback = options;\n        options = {};\n      }\n\n      const bson = this._bson;\n      const buffer = Buffer.isBuffer(response) ? response : bson.serialize(response, options);\n      let context;\n\n      try {\n        context = this._mongocrypt.makeDecryptionContext(buffer);\n      } catch (err) {\n        callback(err, null);\n        return;\n      } // TODO: should this be an accessor from the addon?\n\n\n      context.id = this._contextCounter++;\n      const stateMachine = new StateMachine(Object.assign({\n        bson\n      }, options));\n      stateMachine.execute(this, context, callback);\n    }\n\n  }\n\n  return {\n    AutoEncrypter\n  };\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/node_modules/mongodb-client-encryption/lib/autoEncrypter.js"],"names":["module","exports","modules","mc","require","common","databaseNamespace","StateMachine","stateMachine","MongocryptdManager","MongoClient","mongodb","MongoError","cryptoCallbacks","AutoEncrypter","constructor","client","options","_client","_bson","bson","topology","_mongocryptdManager","extraOptions","_mongocryptdClient","uri","useNewUrlParser","useUnifiedTopology","serverSelectionTimeoutMS","_keyVaultNamespace","keyVaultNamespace","_keyVaultClient","keyVaultClient","_metaDataClient","metadataClient","_bypassEncryption","bypassAutoEncryption","mongoCryptOptions","schemaMap","Buffer","isBuffer","serialize","kmsProviders","logger","Object","assign","_mongocrypt","MongoCrypt","_contextCounter","init","callback","_callback","err","res","message","match","bypassSpawn","connect","spawn","teardown","force","close","encrypt","ns","cmd","TypeError","undefined","commandBuffer","context","makeEncryptionContext","id","document","execute","decrypt","response","buffer","makeDecryptionContext"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = function(modules) {\n  const mc = require('bindings')('mongocrypt');\n  const common = require('./common');\n  const databaseNamespace = common.databaseNamespace;\n  const StateMachine = modules.stateMachine.StateMachine;\n  const MongocryptdManager = require('./mongocryptdManager').MongocryptdManager;\n  const MongoClient = modules.mongodb.MongoClient;\n  const MongoError = modules.mongodb.MongoError;\n  const cryptoCallbacks = require('./cryptoCallbacks');\n\n  /**\n   * Configuration options for a automatic client encryption.\n   *\n   * @typedef {Object} AutoEncrypter~AutoEncryptionOptions\n   * @property {MongoClient} [keyVaultClient] A `MongoClient` used to fetch keys from a key vault\n   * @property {string} [keyVaultNamespace] The namespace where keys are stored in the key vault\n   * @property {KMSProviders} [kmsProviders] Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.\n   * @property {object} [schemaMap] A map of namespaces to a local JSON schema for encryption\n   * @property {boolean} [bypassAutoEncryption] Allows the user to bypass auto encryption, maintaining implicit decryption\n   * @property {AutoEncrypter~logger} [options.logger] An optional hook to catch logging messages from the underlying encryption engine\n   * @property {AutoEncrypter~AutoEncryptionExtraOptions} [extraOptions] Extra options related to the mongocryptd process\n   */\n\n  /**\n   * Extra options related to the mongocryptd process\n   * @typedef {object} AutoEncrypter~AutoEncryptionExtraOptions\n   * @property {string} [mongocryptdURI] A local process the driver communicates with to determine how to encrypt values in a command. Defaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise\n   * @property {boolean} [mongocryptdBypassSpawn=false] If true, autoEncryption will not attempt to spawn a mongocryptd before connecting\n   * @property {string} [mongocryptdSpawnPath] The path to the mongocryptd executable on the system\n   * @property {string[]} [mongocryptdSpawnArgs] Command line arguments to use when auto-spawning a mongocryptd\n   */\n\n  /**\n   * @callback AutoEncrypter~logger\n   * @description A callback that is invoked with logging information from\n   * the underlying C++ Bindings.\n   * @param {AutoEncrypter~logLevel} level The level of logging.\n   * @param {string} message The message to log\n   */\n\n  /**\n   * @name AutoEncrypter~logLevel\n   * @enum {number}\n   * @description\n   * The level of severity of the log message\n   *\n   * | Value | Level |\n   * |-------|-------|\n   * | 0 | Fatal Error |\n   * | 1 | Error |\n   * | 2 | Warning |\n   * | 3 | Info |\n   * | 4 | Trace |\n   */\n\n  /**\n   * @classdesc An internal class to be used by the driver for auto encryption\n   * **NOTE**: Not meant to be instantiated directly, this is for internal use only.\n   */\n  class AutoEncrypter {\n    /**\n     * Create an AutoEncrypter\n     *\n     * **Note**: Do not instantiate this class directly. Rather, supply the relevant options to a MongoClient\n     *\n     * **Note**: Supplying `options.schemaMap` provides more security than relying on JSON Schemas obtained from the server.\n     * It protects against a malicious server advertising a false JSON Schema, which could trick the client into sending unencrypted data that should be encrypted.\n     * Schemas supplied in the schemaMap only apply to configuring automatic encryption for client side encryption.\n     * Other validation rules in the JSON schema will not be enforced by the driver and will result in an error.\n     * @param {MongoClient} client The client autoEncryption is enabled on\n     * @param {AutoEncrypter~AutoEncryptionOptions} [options] Optional settings\n     *\n     * @example\n     * // Enabling autoEncryption via a MongoClient\n     * const { MongoClient } = require('mongodb');\n     * const client = new MongoClient(URL, {\n     *   autoEncryption: {\n     *     kmsProviders: {\n     *       aws: {\n     *         accessKeyId: AWS_ACCESS_KEY,\n     *         secretAccessKey: AWS_SECRET_KEY\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * await client.connect();\n     * // From here on, the client will be encrypting / decrypting automatically\n     */\n    constructor(client, options) {\n      this._client = client;\n      this._bson = options.bson || client.topology.bson;\n      this._mongocryptdManager = new MongocryptdManager(options.extraOptions);\n      this._mongocryptdClient = new MongoClient(this._mongocryptdManager.uri, {\n        useNewUrlParser: true,\n        useUnifiedTopology: true,\n        serverSelectionTimeoutMS: 1000\n      });\n      this._keyVaultNamespace = options.keyVaultNamespace || 'admin.datakeys';\n      this._keyVaultClient = options.keyVaultClient || client;\n      this._metaDataClient = options.metadataClient || client;\n      this._bypassEncryption =\n        typeof options.bypassAutoEncryption === 'boolean' ? options.bypassAutoEncryption : false;\n\n      const mongoCryptOptions = {};\n      if (options.schemaMap) {\n        mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap)\n          ? options.schemaMap\n          : this._bson.serialize(options.schemaMap);\n      }\n\n      if (options.kmsProviders) {\n        mongoCryptOptions.kmsProviders = !Buffer.isBuffer(options.kmsProviders)\n          ? this._bson.serialize(options.kmsProviders)\n          : options.kmsProviders;\n      }\n\n      if (options.logger) {\n        mongoCryptOptions.logger = options.logger;\n      }\n\n      Object.assign(mongoCryptOptions, { cryptoCallbacks });\n      this._mongocrypt = new mc.MongoCrypt(mongoCryptOptions);\n      this._contextCounter = 0;\n    }\n\n    /**\n     * @ignore\n     * @param {Function} callback Invoked when the mongocryptd client either successfully connects or errors\n     */\n    init(callback) {\n      const _callback = (err, res) => {\n        if (\n          err &&\n          err.message &&\n          (err.message.match(/timed out after/) || err.message.match(/ENOTFOUND/))\n        ) {\n          callback(\n            new MongoError(\n              'Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn'\n            )\n          );\n          return;\n        }\n\n        callback(err, res);\n      };\n\n      if (this._mongocryptdManager.bypassSpawn) {\n        return this._mongocryptdClient.connect(_callback);\n      }\n\n      this._mongocryptdManager.spawn(() => this._mongocryptdClient.connect(_callback));\n    }\n\n    /**\n     * @ignore\n     * @param {Function} callback Invoked when the mongocryptd client either successfully disconnects or errors\n     */\n    teardown(force, callback) {\n      this._mongocryptdClient.close(force, callback);\n    }\n\n    /**\n     * @ignore\n     * Encrypt a command for a given namespace.\n     *\n     * @param {string} ns The namespace for this encryption context\n     * @param {object} cmd The command to encrypt\n     * @param {Function} callback\n     */\n    encrypt(ns, cmd, options, callback) {\n      if (typeof ns !== 'string') {\n        throw new TypeError('Parameter `ns` must be a string');\n      }\n\n      if (typeof cmd !== 'object') {\n        throw new TypeError('Parameter `cmd` must be an object');\n      }\n\n      if (typeof options === 'function' && callback == null) {\n        callback = options;\n        options = {};\n      }\n\n      // If `bypassAutoEncryption` has been specified, don't encrypt\n      if (this._bypassEncryption) {\n        callback(undefined, cmd);\n        return;\n      }\n\n      const bson = this._bson;\n      const commandBuffer = Buffer.isBuffer(cmd) ? cmd : bson.serialize(cmd, options);\n\n      let context;\n      try {\n        context = this._mongocrypt.makeEncryptionContext(databaseNamespace(ns), commandBuffer);\n      } catch (err) {\n        callback(err, null);\n        return;\n      }\n\n      // TODO: should these be accessors from the addon?\n      context.id = this._contextCounter++;\n      context.ns = ns;\n      context.document = cmd;\n\n      const stateMachine = new StateMachine(Object.assign({ bson }, options));\n      stateMachine.execute(this, context, callback);\n    }\n\n    /**\n     * @ignore\n     * Decrypt a command response\n     *\n     * @param {Buffer} buffer\n     * @param {Function} callback\n     */\n    decrypt(response, options, callback) {\n      if (typeof options === 'function' && callback == null) {\n        callback = options;\n        options = {};\n      }\n\n      const bson = this._bson;\n      const buffer = Buffer.isBuffer(response) ? response : bson.serialize(response, options);\n\n      let context;\n      try {\n        context = this._mongocrypt.makeDecryptionContext(buffer);\n      } catch (err) {\n        callback(err, null);\n        return;\n      }\n\n      // TODO: should this be an accessor from the addon?\n      context.id = this._contextCounter++;\n\n      const stateMachine = new StateMachine(Object.assign({ bson }, options));\n      stateMachine.execute(this, context, callback);\n    }\n  }\n\n  return { AutoEncrypter };\n};\n"]},"metadata":{},"sourceType":"script"}