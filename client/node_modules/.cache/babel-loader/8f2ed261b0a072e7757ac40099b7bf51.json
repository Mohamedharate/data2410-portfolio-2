{"ast":null,"code":"'use strict';\n\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst push = Array.prototype.push;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\r\n * Get the count of documents for this cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to count.\r\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\r\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\r\n * @param {Cursor~countResultCallback} [callback] The result callback.\r\n */\n\n\nfunction count(cursor, applySkipLimit, opts, callback) {\n  if (applySkipLimit) {\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\n  } // Ensure we have the right read preference inheritance\n\n\n  if (opts.readPreference) {\n    cursor.setReadPreference(opts.readPreference);\n  }\n\n  if (typeof opts.maxTimeMS !== 'number' && cursor.cmd && typeof cursor.cmd.maxTimeMS === 'number') {\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\n  }\n\n  let options = {};\n  options.skip = opts.skip;\n  options.limit = opts.limit;\n  options.hint = opts.hint;\n  options.maxTimeMS = opts.maxTimeMS; // Command\n\n  options.collectionName = cursor.namespace.collection;\n  let command;\n\n  try {\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\n  } catch (err) {\n    return callback(err);\n  } // Set cursor server to the same as the topology\n\n\n  cursor.server = cursor.topology.s.coreTopology; // Execute the command\n\n  cursor.topology.command(cursor.namespace.withCollection('$cmd'), command, cursor.options, (err, result) => {\n    callback(err, result ? result.result.n : null);\n  });\n}\n/**\r\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\r\n *\r\n * @method\r\n * @deprecated\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} callback The result callback.\r\n */\n\n\nfunction each(cursor, callback) {\n  if (!callback) throw MongoError.create({\n    message: 'callback is mandatory',\n    driver: true\n  });\n  if (cursor.isNotified()) return;\n\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT) {\n    cursor.s.state = CursorState.OPEN;\n  } // Define function to avoid global scope escape\n\n\n  let fn = null; // Trampoline all the entries\n\n  if (cursor.bufferedCount() > 0) {\n    while (fn = loop(cursor, callback)) fn(cursor, callback);\n\n    each(cursor, callback);\n  } else {\n    cursor.next((err, item) => {\n      if (err) return handleCallback(callback, err);\n\n      if (item == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, null));\n      }\n\n      if (handleCallback(callback, null, item) === false) return;\n      each(cursor, callback);\n    });\n  }\n} // Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\n\n\nfunction loop(cursor, callback) {\n  // No more items we are done\n  if (cursor.bufferedCount() === 0) return; // Get the next document\n\n  cursor._next(callback); // Loop\n\n\n  return loop;\n}\n/**\r\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\r\n */\n\n\nfunction toArray(cursor, callback) {\n  const items = []; // Reset cursor\n\n  cursor.rewind();\n  cursor.s.state = CursorState.INIT; // Fetch all the documents\n\n  const fetchDocs = () => {\n    cursor._next((err, doc) => {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      if (doc == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, items));\n      } // Add doc to items\n\n\n      items.push(doc); // Get all buffered objects\n\n      if (cursor.bufferedCount() > 0) {\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount()); // Transform the doc if transform method added\n\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\n          docs = docs.map(cursor.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      } // Attempt a fetch\n\n\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n}\n\nmodule.exports = {\n  count,\n  each,\n  toArray\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/operations/cursor_ops.js"],"names":["buildCountCommand","require","handleCallback","MongoError","push","Array","prototype","CursorState","count","cursor","applySkipLimit","opts","callback","cursorSkip","skip","cursorLimit","limit","readPreference","setReadPreference","maxTimeMS","cmd","options","hint","collectionName","namespace","collection","command","query","err","server","topology","s","coreTopology","withCollection","result","n","each","create","message","driver","isNotified","state","CLOSED","isDead","INIT","OPEN","fn","bufferedCount","loop","next","item","close","skipKillCursors","_next","toArray","items","rewind","fetchDocs","doc","docs","readBufferedDocuments","transforms","map","apply","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst MongoError = require('../core').MongoError;\r\nconst push = Array.prototype.push;\r\nconst CursorState = require('../core/cursor').CursorState;\r\n\r\n/**\r\n * Get the count of documents for this cursor.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance on which to count.\r\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\r\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\r\n * @param {Cursor~countResultCallback} [callback] The result callback.\r\n */\r\nfunction count(cursor, applySkipLimit, opts, callback) {\r\n  if (applySkipLimit) {\r\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\r\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\r\n  }\r\n\r\n  // Ensure we have the right read preference inheritance\r\n  if (opts.readPreference) {\r\n    cursor.setReadPreference(opts.readPreference);\r\n  }\r\n\r\n  if (\r\n    typeof opts.maxTimeMS !== 'number' &&\r\n    cursor.cmd &&\r\n    typeof cursor.cmd.maxTimeMS === 'number'\r\n  ) {\r\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\r\n  }\r\n\r\n  let options = {};\r\n  options.skip = opts.skip;\r\n  options.limit = opts.limit;\r\n  options.hint = opts.hint;\r\n  options.maxTimeMS = opts.maxTimeMS;\r\n\r\n  // Command\r\n  options.collectionName = cursor.namespace.collection;\r\n\r\n  let command;\r\n  try {\r\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\r\n  } catch (err) {\r\n    return callback(err);\r\n  }\r\n\r\n  // Set cursor server to the same as the topology\r\n  cursor.server = cursor.topology.s.coreTopology;\r\n\r\n  // Execute the command\r\n  cursor.topology.command(\r\n    cursor.namespace.withCollection('$cmd'),\r\n    command,\r\n    cursor.options,\r\n    (err, result) => {\r\n      callback(err, result ? result.result.n : null);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\r\n *\r\n * @method\r\n * @deprecated\r\n * @param {Cursor} cursor The Cursor instance on which to run.\r\n * @param {Cursor~resultCallback} callback The result callback.\r\n */\r\nfunction each(cursor, callback) {\r\n  if (!callback) throw MongoError.create({ message: 'callback is mandatory', driver: true });\r\n  if (cursor.isNotified()) return;\r\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\r\n    return handleCallback(\r\n      callback,\r\n      MongoError.create({ message: 'Cursor is closed', driver: true })\r\n    );\r\n  }\r\n\r\n  if (cursor.s.state === CursorState.INIT) {\r\n    cursor.s.state = CursorState.OPEN;\r\n  }\r\n\r\n  // Define function to avoid global scope escape\r\n  let fn = null;\r\n  // Trampoline all the entries\r\n  if (cursor.bufferedCount() > 0) {\r\n    while ((fn = loop(cursor, callback))) fn(cursor, callback);\r\n    each(cursor, callback);\r\n  } else {\r\n    cursor.next((err, item) => {\r\n      if (err) return handleCallback(callback, err);\r\n      if (item == null) {\r\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));\r\n      }\r\n\r\n      if (handleCallback(callback, null, item) === false) return;\r\n      each(cursor, callback);\r\n    });\r\n  }\r\n}\r\n\r\n// Trampoline emptying the number of retrieved items\r\n// without incurring a nextTick operation\r\nfunction loop(cursor, callback) {\r\n  // No more items we are done\r\n  if (cursor.bufferedCount() === 0) return;\r\n  // Get the next document\r\n  cursor._next(callback);\r\n  // Loop\r\n  return loop;\r\n}\r\n\r\n/**\r\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\r\n *\r\n * @method\r\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\r\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\r\n */\r\nfunction toArray(cursor, callback) {\r\n  const items = [];\r\n\r\n  // Reset cursor\r\n  cursor.rewind();\r\n  cursor.s.state = CursorState.INIT;\r\n\r\n  // Fetch all the documents\r\n  const fetchDocs = () => {\r\n    cursor._next((err, doc) => {\r\n      if (err) {\r\n        return handleCallback(callback, err);\r\n      }\r\n\r\n      if (doc == null) {\r\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));\r\n      }\r\n\r\n      // Add doc to items\r\n      items.push(doc);\r\n\r\n      // Get all buffered objects\r\n      if (cursor.bufferedCount() > 0) {\r\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount());\r\n\r\n        // Transform the doc if transform method added\r\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\r\n          docs = docs.map(cursor.s.transforms.doc);\r\n        }\r\n\r\n        push.apply(items, docs);\r\n      }\r\n\r\n      // Attempt a fetch\r\n      fetchDocs();\r\n    });\r\n  };\r\n\r\n  fetchDocs();\r\n}\r\n\r\nmodule.exports = { count, each, toArray };\r\n"]},"metadata":{},"sourceType":"script"}