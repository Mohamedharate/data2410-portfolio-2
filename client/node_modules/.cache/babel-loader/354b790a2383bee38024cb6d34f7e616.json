{"ast":null,"code":"'use strict';\n\nconst Long = require('../core').BSON.Long;\n\nconst MongoError = require('../core').MongoError;\n\nconst ObjectID = require('../core').BSON.ObjectID;\n\nconst BSON = require('../core').BSON;\n\nconst MongoWriteConcernError = require('../core').MongoWriteConcernError;\n\nconst toError = require('../utils').toError;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nconst isPromiseLike = require('../utils').isPromiseLike;\n\nconst hasAtomicOperators = require('../utils').hasAtomicOperators;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion; // Error codes\n\n\nconst WRITE_CONCERN_ERROR = 64; // Insert types\n\nconst INSERT = 1;\nconst UPDATE = 2;\nconst REMOVE = 3;\nconst bson = new BSON([BSON.Binary, BSON.Code, BSON.DBRef, BSON.Decimal128, BSON.Double, BSON.Int32, BSON.Long, BSON.Map, BSON.MaxKey, BSON.MinKey, BSON.ObjectId, BSON.BSONRegExp, BSON.Symbol, BSON.Timestamp]);\n/**\r\n * Keeps the state of a unordered batch so we can rewrite the results\r\n * correctly after command execution\r\n * @ignore\r\n */\n\nclass Batch {\n  constructor(batchType, originalZeroIndex) {\n    this.originalZeroIndex = originalZeroIndex;\n    this.currentIndex = 0;\n    this.originalIndexes = [];\n    this.batchType = batchType;\n    this.operations = [];\n    this.size = 0;\n    this.sizeBytes = 0;\n  }\n\n}\n/**\r\n * @classdesc\r\n * The result of a bulk write.\r\n */\n\n\nclass BulkWriteResult {\n  /**\r\n   * Create a new BulkWriteResult instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\n  constructor(bulkResult) {\n    this.result = bulkResult;\n  }\n  /**\r\n   * Evaluates to true if the bulk operation correctly executes\r\n   * @type {boolean}\r\n   */\n\n\n  get ok() {\n    return this.result.ok;\n  }\n  /**\r\n   * The number of inserted documents\r\n   * @type {number}\r\n   */\n\n\n  get nInserted() {\n    return this.result.nInserted;\n  }\n  /**\r\n   * Number of upserted documents\r\n   * @type {number}\r\n   */\n\n\n  get nUpserted() {\n    return this.result.nUpserted;\n  }\n  /**\r\n   * Number of matched documents\r\n   * @type {number}\r\n   */\n\n\n  get nMatched() {\n    return this.result.nMatched;\n  }\n  /**\r\n   * Number of documents updated physically on disk\r\n   * @type {number}\r\n   */\n\n\n  get nModified() {\n    return this.result.nModified;\n  }\n  /**\r\n   * Number of removed documents\r\n   * @type {number}\r\n   */\n\n\n  get nRemoved() {\n    return this.result.nRemoved;\n  }\n  /**\r\n   * Returns an array of all inserted ids\r\n   *\r\n   * @return {object[]}\r\n   */\n\n\n  getInsertedIds() {\n    return this.result.insertedIds;\n  }\n  /**\r\n   * Returns an array of all upserted ids\r\n   *\r\n   * @return {object[]}\r\n   */\n\n\n  getUpsertedIds() {\n    return this.result.upserted;\n  }\n  /**\r\n   * Returns the upserted id at the given index\r\n   *\r\n   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\r\n   * @return {object}\r\n   */\n\n\n  getUpsertedIdAt(index) {\n    return this.result.upserted[index];\n  }\n  /**\r\n   * Returns raw internal result\r\n   *\r\n   * @return {object}\r\n   */\n\n\n  getRawResponse() {\n    return this.result;\n  }\n  /**\r\n   * Returns true if the bulk operation contains a write error\r\n   *\r\n   * @return {boolean}\r\n   */\n\n\n  hasWriteErrors() {\n    return this.result.writeErrors.length > 0;\n  }\n  /**\r\n   * Returns the number of write errors off the bulk operation\r\n   *\r\n   * @return {number}\r\n   */\n\n\n  getWriteErrorCount() {\n    return this.result.writeErrors.length;\n  }\n  /**\r\n   * Returns a specific write error object\r\n   *\r\n   * @param {number} index of the write error to return, returns null if there is no result for passed in index\r\n   * @return {WriteError}\r\n   */\n\n\n  getWriteErrorAt(index) {\n    if (index < this.result.writeErrors.length) {\n      return this.result.writeErrors[index];\n    }\n\n    return null;\n  }\n  /**\r\n   * Retrieve all write errors\r\n   *\r\n   * @return {WriteError[]}\r\n   */\n\n\n  getWriteErrors() {\n    return this.result.writeErrors;\n  }\n  /**\r\n   * Retrieve lastOp if available\r\n   *\r\n   * @return {object}\r\n   */\n\n\n  getLastOp() {\n    return this.result.lastOp;\n  }\n  /**\r\n   * Retrieve the write concern error if any\r\n   *\r\n   * @return {WriteConcernError}\r\n   */\n\n\n  getWriteConcernError() {\n    if (this.result.writeConcernErrors.length === 0) {\n      return null;\n    } else if (this.result.writeConcernErrors.length === 1) {\n      // Return the error\n      return this.result.writeConcernErrors[0];\n    } else {\n      // Combine the errors\n      let errmsg = '';\n\n      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {\n        const err = this.result.writeConcernErrors[i];\n        errmsg = errmsg + err.errmsg; // TODO: Something better\n\n        if (i === 0) errmsg = errmsg + ' and ';\n      }\n\n      return new WriteConcernError({\n        errmsg: errmsg,\n        code: WRITE_CONCERN_ERROR\n      });\n    }\n  }\n  /**\r\n   * @return {object}\r\n   */\n\n\n  toJSON() {\n    return this.result;\n  }\n  /**\r\n   * @return {string}\r\n   */\n\n\n  toString() {\n    return `BulkWriteResult(${this.toJSON(this.result)})`;\n  }\n  /**\r\n   * @return {boolean}\r\n   */\n\n\n  isOk() {\n    return this.result.ok === 1;\n  }\n\n}\n/**\r\n * @classdesc An error representing a failure by the server to apply the requested write concern to the bulk operation.\r\n */\n\n\nclass WriteConcernError {\n  /**\r\n   * Create a new WriteConcernError instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\n  constructor(err) {\n    this.err = err;\n  }\n  /**\r\n   * Write concern error code.\r\n   * @type {number}\r\n   */\n\n\n  get code() {\n    return this.err.code;\n  }\n  /**\r\n   * Write concern error message.\r\n   * @type {string}\r\n   */\n\n\n  get errmsg() {\n    return this.err.errmsg;\n  }\n  /**\r\n   * @return {object}\r\n   */\n\n\n  toJSON() {\n    return {\n      code: this.err.code,\n      errmsg: this.err.errmsg\n    };\n  }\n  /**\r\n   * @return {string}\r\n   */\n\n\n  toString() {\n    return `WriteConcernError(${this.err.errmsg})`;\n  }\n\n}\n/**\r\n * @classdesc An error that occurred during a BulkWrite on the server.\r\n */\n\n\nclass WriteError {\n  /**\r\n   * Create a new WriteError instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\n  constructor(err) {\n    this.err = err;\n  }\n  /**\r\n   * WriteError code.\r\n   * @type {number}\r\n   */\n\n\n  get code() {\n    return this.err.code;\n  }\n  /**\r\n   * WriteError original bulk operation index.\r\n   * @type {number}\r\n   */\n\n\n  get index() {\n    return this.err.index;\n  }\n  /**\r\n   * WriteError message.\r\n   * @type {string}\r\n   */\n\n\n  get errmsg() {\n    return this.err.errmsg;\n  }\n  /**\r\n   * Returns the underlying operation that caused the error\r\n   * @return {object}\r\n   */\n\n\n  getOperation() {\n    return this.err.op;\n  }\n  /**\r\n   * @return {object}\r\n   */\n\n\n  toJSON() {\n    return {\n      code: this.err.code,\n      index: this.err.index,\n      errmsg: this.err.errmsg,\n      op: this.err.op\n    };\n  }\n  /**\r\n   * @return {string}\r\n   */\n\n\n  toString() {\n    return `WriteError(${JSON.stringify(this.toJSON())})`;\n  }\n\n}\n/**\r\n * Merges results into shared data structure\r\n * @ignore\r\n */\n\n\nfunction mergeBatchResults(batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  } else if (result == null) {\n    return;\n  } // Do we have a top level error stop processing and return\n\n\n  if (result.ok === 0 && bulkResult.ok === 1) {\n    bulkResult.ok = 0;\n    const writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\n    return;\n  } // Deal with opTime if available\n\n\n  if (result.opTime || result.lastOp) {\n    const opTime = result.lastOp || result.opTime;\n    let lastOpTS = null;\n    let lastOpT = null; // We have a time stamp\n\n    if (opTime && opTime._bsontype === 'Timestamp') {\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\n        bulkResult.lastOp = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.lastOp) {\n        lastOpTS = typeof bulkResult.lastOp.ts === 'number' ? Long.fromNumber(bulkResult.lastOp.ts) : bulkResult.lastOp.ts;\n        lastOpT = typeof bulkResult.lastOp.t === 'number' ? Long.fromNumber(bulkResult.lastOp.t) : bulkResult.lastOp.t;\n      } // Current OpTime TS\n\n\n      const opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\n      const opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t; // Compare the opTime's\n\n      if (bulkResult.lastOp == null) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.lastOp = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.lastOp = opTime;\n        }\n      }\n    }\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === INSERT && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  } // If we have an insert Batch type\n\n\n  if (batch.batchType === REMOVE && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  let nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes\n\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (let i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  } // If we have an update Batch type\n\n\n  if (batch.batchType === UPDATE && result.n) {\n    const nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified === 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = null;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (let i = 0; i < result.writeErrors.length; i++) {\n      const writeError = {\n        index: batch.originalIndexes[result.writeErrors[i].index],\n        code: result.writeErrors[i].code,\n        errmsg: result.writeErrors[i].errmsg,\n        op: batch.operations[result.writeErrors[i].index]\n      };\n      bulkResult.writeErrors.push(new WriteError(writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}\n\nfunction executeCommands(bulkOperation, options, callback) {\n  if (bulkOperation.s.batches.length === 0) {\n    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));\n  }\n\n  const batch = bulkOperation.s.batches.shift();\n\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, terminate\n    if ((err && err.driver || err && err.message) && !(err instanceof MongoWriteConcernError)) {\n      return handleCallback(callback, err);\n    } // If we have and error\n\n\n    if (err) err.ok = 0;\n\n    if (err instanceof MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\n    } // Merge the results together\n\n\n    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n    const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\n\n    if (mergeResult != null) {\n      return handleCallback(callback, null, writeResult);\n    }\n\n    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line\n\n    executeCommands(bulkOperation, options, callback);\n  }\n\n  bulkOperation.finalOptionsHandler({\n    options,\n    batch,\n    resultHandler\n  }, callback);\n}\n/**\r\n * handles write concern error\r\n *\r\n * @ignore\r\n * @param {object} batch\r\n * @param {object} bulkResult\r\n * @param {boolean} ordered\r\n * @param {WriteConcernError} err\r\n * @param {function} callback\r\n */\n\n\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\n  mergeBatchResults(batch, bulkResult, null, err.result);\n  const wrappedWriteConcernError = new WriteConcernError({\n    errmsg: err.result.writeConcernError.errmsg,\n    code: err.result.writeConcernError.result\n  });\n  return handleCallback(callback, new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)), null);\n}\n/**\r\n * @classdesc An error indicating an unsuccessful Bulk Write\r\n */\n\n\nclass BulkWriteError extends MongoError {\n  /**\r\n   * Creates a new BulkWriteError\r\n   *\r\n   * @param {Error|string|object} message The error message\r\n   * @param {BulkWriteResult} result The result of the bulk write operation\r\n   * @extends {MongoError}\r\n   */\n  constructor(error, result) {\n    const message = error.err || error.errmsg || error.errMessage || error;\n    super(message);\n    Object.assign(this, error);\n    this.name = 'BulkWriteError';\n    this.result = result;\n  }\n\n}\n/**\r\n * @classdesc A builder object that is returned from {@link BulkOperationBase#find}.\r\n * Is used to build a write operation that involves a query filter.\r\n */\n\n\nclass FindOperators {\n  /**\r\n   * Creates a new FindOperators object.\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation\r\n   */\n  constructor(bulkOperation) {\n    this.s = bulkOperation.s;\n  }\n  /**\r\n   * Add a multiple update operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\n\n\n  update(updateDocument) {\n    // Perform upsert\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n    const document = {\n      q: this.s.currentOp.selector,\n      u: updateDocument,\n      multi: true,\n      upsert: upsert\n    };\n\n    if (updateDocument.hint) {\n      document.hint = updateDocument.hint;\n    } // Clear out current Op\n\n\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, UPDATE, document);\n  }\n  /**\r\n   * Add a single update operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\n\n\n  updateOne(updateDocument) {\n    // Perform upsert\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n    const document = {\n      q: this.s.currentOp.selector,\n      u: updateDocument,\n      multi: false,\n      upsert: upsert\n    };\n\n    if (updateDocument.hint) {\n      document.hint = updateDocument.hint;\n    }\n\n    if (!hasAtomicOperators(updateDocument)) {\n      throw new TypeError('Update document requires atomic operators');\n    } // Clear out current Op\n\n\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, UPDATE, document);\n  }\n  /**\r\n   * Add a replace one operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} replacement the new document to replace the existing one with\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\n\n\n  replaceOne(replacement) {\n    // Perform upsert\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false; // Establish the update command\n\n    const document = {\n      q: this.s.currentOp.selector,\n      u: replacement,\n      multi: false,\n      upsert: upsert\n    };\n\n    if (replacement.hint) {\n      document.hint = replacement.hint;\n    }\n\n    if (hasAtomicOperators(replacement)) {\n      throw new TypeError('Replacement document must not use atomic operators');\n    } // Clear out current Op\n\n\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, UPDATE, document);\n  }\n  /**\r\n   * Upsert modifier for update bulk operation, noting that this operation is an upsert.\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {FindOperators} reference to self\r\n   */\n\n\n  upsert() {\n    this.s.currentOp.upsert = true;\n    return this;\n  }\n  /**\r\n   * Add a delete one operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\n\n\n  deleteOne() {\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      limit: 1\n    }; // Clear out current Op\n\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, REMOVE, document);\n  }\n  /**\r\n   * Add a delete many operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\n\n\n  delete() {\n    // Establish the update command\n    const document = {\n      q: this.s.currentOp.selector,\n      limit: 0\n    }; // Clear out current Op\n\n    this.s.currentOp = null;\n    return this.s.options.addToOperationsList(this, REMOVE, document);\n  }\n  /**\r\n   * backwards compatability for deleteOne\r\n   */\n\n\n  removeOne() {\n    return this.deleteOne();\n  }\n  /**\r\n   * backwards compatability for delete\r\n   */\n\n\n  remove() {\n    return this.delete();\n  }\n\n}\n/**\r\n * @classdesc Parent class to OrderedBulkOperation and UnorderedBulkOperation\r\n *\r\n * **NOTE:** Internal Type, do not instantiate directly\r\n */\n\n\nclass BulkOperationBase {\n  /**\r\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\r\n   * @property {number} length Get the number of operations in the bulk.\r\n   */\n  constructor(topology, collection, options, isOrdered) {\n    // determine whether bulkOperation is ordered or unordered\n    this.isOrdered = isOrdered;\n    options = options == null ? {} : options; // TODO Bring from driver information in isMaster\n    // Get the namespace for the write operations\n\n    const namespace = collection.s.namespace; // Used to mark operation as executed\n\n    const executed = false; // Current item\n\n    const currentOp = null; // Handle to the bson serializer, used to calculate running sizes\n\n    const bson = topology.bson; // Set max byte size\n\n    const isMaster = topology.lastIsMaster(); // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\n    // over 2mb are still allowed\n\n    const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\n    const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n    const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\n    const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000; // Calculates the largest possible size of an Array key, represented as a BSON string\n    // element. This calculation:\n    //     1 byte for BSON type\n    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\n    //   + 1 bytes for null terminator\n\n    const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2; // Final options for retryable writes and write concern\n\n    let finalOptions = Object.assign({}, options);\n    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);\n    finalOptions = applyWriteConcern(finalOptions, {\n      collection: collection\n    }, options);\n    const writeConcern = finalOptions.writeConcern; // Get the promiseLibrary\n\n    const promiseLibrary = options.promiseLibrary || Promise; // Final results\n\n    const bulkResult = {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    }; // Internal state\n\n    this.s = {\n      // Final result\n      bulkResult: bulkResult,\n      // Current batch state\n      currentBatch: null,\n      currentIndex: 0,\n      // ordered specific\n      currentBatchSize: 0,\n      currentBatchSizeBytes: 0,\n      // unordered specific\n      currentInsertBatch: null,\n      currentUpdateBatch: null,\n      currentRemoveBatch: null,\n      batches: [],\n      // Write concern\n      writeConcern: writeConcern,\n      // Max batch size options\n      maxBsonObjectSize,\n      maxBatchSizeBytes,\n      maxWriteBatchSize,\n      maxKeySize,\n      // Namespace\n      namespace: namespace,\n      // BSON\n      bson: bson,\n      // Topology\n      topology: topology,\n      // Options\n      options: finalOptions,\n      // Current operation\n      currentOp: currentOp,\n      // Executed\n      executed: executed,\n      // Collection\n      collection: collection,\n      // Promise Library\n      promiseLibrary: promiseLibrary,\n      // Fundamental error\n      err: null,\n      // check keys\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true\n    }; // bypass Validation\n\n    if (options.bypassDocumentValidation === true) {\n      this.s.bypassDocumentValidation = true;\n    }\n  }\n  /**\r\n   * Add a single insert document to the bulk operation\r\n   *\r\n   * @param {object} document the document to insert\r\n   * @throws {MongoError}\r\n   * @return {BulkOperationBase} A reference to self\r\n   *\r\n   * @example\r\n   * const bulkOp = collection.initializeOrderedBulkOp();\r\n   * // Adds three inserts to the bulkOp.\r\n   * bulkOp\r\n   *   .insert({ a: 1 })\r\n   *   .insert({ b: 2 })\r\n   *   .insert({ c: 3 });\r\n   * await bulkOp.execute();\r\n   */\n\n\n  insert(document) {\n    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null) document._id = new ObjectID();\n    return this.s.options.addToOperationsList(this, INSERT, document);\n  }\n  /**\r\n   * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\r\n   * Returns a builder object used to complete the definition of the operation.\r\n   *\r\n   * @method\r\n   * @param {object} selector The selector for the bulk operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-q q documentation}\r\n   * @throws {MongoError} if a selector is not specified\r\n   * @return {FindOperators} A helper object with which the write operation can be defined.\r\n   *\r\n   * @example\r\n   * const bulkOp = collection.initializeOrderedBulkOp();\r\n   *\r\n   * // Add an updateOne to the bulkOp\r\n   * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\r\n   *\r\n   * // Add an updateMany to the bulkOp\r\n   * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\r\n   *\r\n   * // Add an upsert\r\n   * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\r\n   *\r\n   * // Add a deletion\r\n   * bulkOp.find({ g: 7 }).deleteOne();\r\n   *\r\n   * // Add a multi deletion\r\n   * bulkOp.find({ h: 8 }).delete();\r\n   *\r\n   * // Add a replaceOne\r\n   * bulkOp.find({ i: 9 }).replaceOne({ j: 10 });\r\n   *\r\n   * // Update using a pipeline (requires Mongodb 4.2 or higher)\r\n   * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\r\n   *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\r\n   * ]);\r\n   *\r\n   * // All of the ops will now be executed\r\n   * await bulkOp.execute();\r\n   */\n\n\n  find(selector) {\n    if (!selector) {\n      throw toError('Bulk find operation must specify a selector');\n    } // Save a current selector\n\n\n    this.s.currentOp = {\n      selector: selector\n    };\n    return new FindOperators(this);\n  }\n  /**\r\n   * Specifies a raw operation to perform in the bulk write.\r\n   *\r\n   * @method\r\n   * @param {object} op The raw operation to perform.\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @return {BulkOperationBase} A reference to self\r\n   */\n\n\n  raw(op) {\n    const key = Object.keys(op)[0]; // Set up the force server object id\n\n    const forceServerObjectId = typeof this.s.options.forceServerObjectId === 'boolean' ? this.s.options.forceServerObjectId : this.s.collection.s.db.options.forceServerObjectId; // Update operations\n\n    if (op.updateOne && op.updateOne.q || op.updateMany && op.updateMany.q || op.replaceOne && op.replaceOne.q) {\n      op[key].multi = op.updateOne || op.replaceOne ? false : true;\n      return this.s.options.addToOperationsList(this, UPDATE, op[key]);\n    } // Crud spec update format\n\n\n    if (op.updateOne || op.updateMany || op.replaceOne) {\n      if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {\n        throw new TypeError('Replacement document must not use atomic operators');\n      } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {\n        throw new TypeError('Update document requires atomic operators');\n      }\n\n      const multi = op.updateOne || op.replaceOne ? false : true;\n      const operation = {\n        q: op[key].filter,\n        u: op[key].update || op[key].replacement,\n        multi: multi\n      };\n\n      if (op[key].hint) {\n        operation.hint = op[key].hint;\n      }\n\n      if (this.isOrdered) {\n        operation.upsert = op[key].upsert ? true : false;\n        if (op.collation) operation.collation = op.collation;\n      } else {\n        if (op[key].upsert) operation.upsert = true;\n      }\n\n      if (op[key].arrayFilters) {\n        // TODO: this check should be done at command construction against a connection, not a topology\n        if (maxWireVersion(this.s.topology) < 6) {\n          throw new TypeError('arrayFilters are only supported on MongoDB 3.6+');\n        }\n\n        operation.arrayFilters = op[key].arrayFilters;\n      }\n\n      return this.s.options.addToOperationsList(this, UPDATE, operation);\n    } // Remove operations\n\n\n    if (op.removeOne || op.removeMany || op.deleteOne && op.deleteOne.q || op.deleteMany && op.deleteMany.q) {\n      op[key].limit = op.removeOne ? 1 : 0;\n      return this.s.options.addToOperationsList(this, REMOVE, op[key]);\n    } // Crud spec delete operations, less efficient\n\n\n    if (op.deleteOne || op.deleteMany) {\n      const limit = op.deleteOne ? 1 : 0;\n      const operation = {\n        q: op[key].filter,\n        limit: limit\n      };\n\n      if (op[key].hint) {\n        operation.hint = op[key].hint;\n      }\n\n      if (this.isOrdered) {\n        if (op.collation) operation.collation = op.collation;\n      }\n\n      return this.s.options.addToOperationsList(this, REMOVE, operation);\n    } // Insert operations\n\n\n    if (op.insertOne && op.insertOne.document == null) {\n      if (forceServerObjectId !== true && op.insertOne._id == null) op.insertOne._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne);\n    } else if (op.insertOne && op.insertOne.document) {\n      if (forceServerObjectId !== true && op.insertOne.document._id == null) op.insertOne.document._id = new ObjectID();\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);\n    }\n\n    if (op.insertMany) {\n      for (let i = 0; i < op.insertMany.length; i++) {\n        if (forceServerObjectId !== true && op.insertMany[i]._id == null) op.insertMany[i]._id = new ObjectID();\n        this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);\n      }\n\n      return;\n    } // No valid type of operation\n\n\n    throw toError('bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany');\n  }\n  /**\r\n   * helper function to assist with promiseOrCallback behavior\r\n   * @ignore\r\n   * @param {*} err\r\n   * @param {*} callback\r\n   */\n\n\n  _handleEarlyError(err, callback) {\n    if (typeof callback === 'function') {\n      callback(err, null);\n      return;\n    }\n\n    return this.s.promiseLibrary.reject(err);\n  }\n  /**\r\n   * An internal helper method. Do not invoke directly. Will be going away in the future\r\n   *\r\n   * @ignore\r\n   * @method\r\n   * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation\r\n   * @param {object} writeConcern\r\n   * @param {object} options\r\n   * @param {function} callback\r\n   */\n\n\n  bulkExecute(_writeConcern, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {};\n\n    if (typeof _writeConcern === 'function') {\n      callback = _writeConcern;\n    } else if (_writeConcern && typeof _writeConcern === 'object') {\n      this.s.writeConcern = _writeConcern;\n    }\n\n    if (this.s.executed) {\n      const executedError = toError('batch cannot be re-executed');\n      return this._handleEarlyError(executedError, callback);\n    } // If we have current batch\n\n\n    if (this.isOrdered) {\n      if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\n    } else {\n      if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n      if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n      if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\n    } // If we have no operations in the bulk raise an error\n\n\n    if (this.s.batches.length === 0) {\n      const emptyBatchError = toError('Invalid Operation, no operations specified');\n      return this._handleEarlyError(emptyBatchError, callback);\n    }\n\n    return {\n      options,\n      callback\n    };\n  }\n  /**\r\n   * The callback format for results\r\n   * @callback BulkOperationBase~resultCallback\r\n   * @param {MongoError} error An error instance representing the error during the execution.\r\n   * @param {BulkWriteResult} result The bulk write result.\r\n   */\n\n  /**\r\n   * Execute the bulk operation\r\n   *\r\n   * @method\r\n   * @param {WriteConcern} [_writeConcern] Optional write concern. Can also be specified through options.\r\n   * @param {object} [options] Optional settings.\r\n   * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\r\n   * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\r\n   * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\r\n   * @param {boolean} [options.fsync=false] **Deprecated** Specify a file sync write concern. Use writeConcern instead.\r\n   * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\r\n   * @param {BulkOperationBase~resultCallback} [callback] A callback that will be invoked when bulkWrite finishes/errors\r\n   * @throws {MongoError} Throws error if the bulk object has already been executed\r\n   * @throws {MongoError} Throws error if the bulk object does not have any operations\r\n   * @return {Promise|void} returns Promise if no callback passed\r\n   */\n\n\n  execute(_writeConcern, options, callback) {\n    const ret = this.bulkExecute(_writeConcern, options, callback);\n\n    if (!ret || isPromiseLike(ret)) {\n      return ret;\n    }\n\n    options = ret.options;\n    callback = ret.callback;\n    return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);\n  }\n  /**\r\n   * Handles final options before executing command\r\n   *\r\n   * An internal method. Do not invoke. Will not be accessible in the future\r\n   *\r\n   * @ignore\r\n   * @param {object} config\r\n   * @param {object} config.options\r\n   * @param {number} config.batch\r\n   * @param {function} config.resultHandler\r\n   * @param {function} callback\r\n   */\n\n\n  finalOptionsHandler(config, callback) {\n    const finalOptions = Object.assign({\n      ordered: this.isOrdered\n    }, config.options);\n\n    if (this.s.writeConcern != null) {\n      finalOptions.writeConcern = this.s.writeConcern;\n    }\n\n    if (finalOptions.bypassDocumentValidation !== true) {\n      delete finalOptions.bypassDocumentValidation;\n    } // Set an operationIf if provided\n\n\n    if (this.operationId) {\n      config.resultHandler.operationId = this.operationId;\n    } // Serialize functions\n\n\n    if (this.s.options.serializeFunctions) {\n      finalOptions.serializeFunctions = true;\n    } // Ignore undefined\n\n\n    if (this.s.options.ignoreUndefined) {\n      finalOptions.ignoreUndefined = true;\n    } // Is the bypassDocumentValidation options specific\n\n\n    if (this.s.bypassDocumentValidation === true) {\n      finalOptions.bypassDocumentValidation = true;\n    } // Is the checkKeys option disabled\n\n\n    if (this.s.checkKeys === false) {\n      finalOptions.checkKeys = false;\n    }\n\n    if (finalOptions.retryWrites) {\n      if (config.batch.batchType === UPDATE) {\n        finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(op => op.multi);\n      }\n\n      if (config.batch.batchType === REMOVE) {\n        finalOptions.retryWrites = finalOptions.retryWrites && !config.batch.operations.some(op => op.limit === 0);\n      }\n    }\n\n    try {\n      if (config.batch.batchType === INSERT) {\n        this.s.topology.insert(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n      } else if (config.batch.batchType === UPDATE) {\n        this.s.topology.update(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n      } else if (config.batch.batchType === REMOVE) {\n        this.s.topology.remove(this.s.namespace, config.batch.operations, finalOptions, config.resultHandler);\n      }\n    } catch (err) {\n      // Force top level error\n      err.ok = 0; // Merge top level error and return\n\n      handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));\n    }\n  }\n  /**\r\n   * Handles the write error before executing commands\r\n   *\r\n   * An internal helper method. Do not invoke directly. Will be going away in the future\r\n   *\r\n   * @ignore\r\n   * @param {function} callback\r\n   * @param {BulkWriteResult} writeResult\r\n   * @param {class} self either OrderedBulkOperation or UnorderedBulkOperation\r\n   */\n\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.bulkResult.writeErrors.length > 0) {\n      const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : 'write operation failed';\n      handleCallback(callback, new BulkWriteError(toError({\n        message: msg,\n        code: this.s.bulkResult.writeErrors[0].code,\n        writeErrors: this.s.bulkResult.writeErrors\n      }), writeResult), null);\n      return true;\n    }\n\n    if (writeResult.getWriteConcernError()) {\n      handleCallback(callback, new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult), null);\n      return true;\n    }\n  }\n\n}\n\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n  enumerable: true,\n  get: function () {\n    return this.s.currentIndex;\n  }\n}); // Exports symbols\n\nmodule.exports = {\n  Batch,\n  BulkOperationBase,\n  bson,\n  INSERT: INSERT,\n  UPDATE: UPDATE,\n  REMOVE: REMOVE,\n  BulkWriteError\n};","map":{"version":3,"sources":["C:/Users/Tanja Aakerholt/Documents/GitHub/portfolio2/client/node_modules/mongodb/lib/bulk/common.js"],"names":["Long","require","BSON","MongoError","ObjectID","MongoWriteConcernError","toError","handleCallback","applyRetryableWrites","applyWriteConcern","executeLegacyOperation","isPromiseLike","hasAtomicOperators","maxWireVersion","WRITE_CONCERN_ERROR","INSERT","UPDATE","REMOVE","bson","Binary","Code","DBRef","Decimal128","Double","Int32","Map","MaxKey","MinKey","ObjectId","BSONRegExp","Symbol","Timestamp","Batch","constructor","batchType","originalZeroIndex","currentIndex","originalIndexes","operations","size","sizeBytes","BulkWriteResult","bulkResult","result","ok","nInserted","nUpserted","nMatched","nModified","nRemoved","getInsertedIds","insertedIds","getUpsertedIds","upserted","getUpsertedIdAt","index","getRawResponse","hasWriteErrors","writeErrors","length","getWriteErrorCount","getWriteErrorAt","getWriteErrors","getLastOp","lastOp","getWriteConcernError","writeConcernErrors","errmsg","i","err","WriteConcernError","code","toJSON","toString","isOk","WriteError","getOperation","op","JSON","stringify","mergeBatchResults","batch","writeError","message","push","opTime","lastOpTS","lastOpT","_bsontype","greaterThan","ts","fromNumber","t","opTimeTS","opTimeT","equals","n","Array","isArray","_id","writeConcernError","executeCommands","bulkOperation","options","callback","s","batches","shift","resultHandler","driver","handleMongoWriteConcernError","writeResult","mergeResult","handleWriteError","finalOptionsHandler","wrappedWriteConcernError","BulkWriteError","error","errMessage","Object","assign","name","FindOperators","update","updateDocument","upsert","currentOp","document","q","selector","u","multi","hint","addToOperationsList","updateOne","TypeError","replaceOne","replacement","deleteOne","limit","delete","removeOne","remove","BulkOperationBase","topology","collection","isOrdered","namespace","executed","isMaster","lastIsMaster","usingAutoEncryption","autoEncrypter","maxBsonObjectSize","maxBatchSizeBytes","maxWriteBatchSize","maxKeySize","finalOptions","db","writeConcern","promiseLibrary","Promise","currentBatch","currentBatchSize","currentBatchSizeBytes","currentInsertBatch","currentUpdateBatch","currentRemoveBatch","checkKeys","bypassDocumentValidation","insert","forceServerObjectId","find","raw","key","keys","updateMany","operation","filter","collation","arrayFilters","removeMany","deleteMany","insertOne","insertMany","_handleEarlyError","reject","bulkExecute","_writeConcern","executedError","emptyBatchError","execute","ret","config","ordered","operationId","serializeFunctions","ignoreUndefined","retryWrites","some","msg","defineProperty","prototype","enumerable","get","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst Long = require('../core').BSON.Long;\r\nconst MongoError = require('../core').MongoError;\r\nconst ObjectID = require('../core').BSON.ObjectID;\r\nconst BSON = require('../core').BSON;\r\nconst MongoWriteConcernError = require('../core').MongoWriteConcernError;\r\nconst toError = require('../utils').toError;\r\nconst handleCallback = require('../utils').handleCallback;\r\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\r\nconst applyWriteConcern = require('../utils').applyWriteConcern;\r\nconst executeLegacyOperation = require('../utils').executeLegacyOperation;\r\nconst isPromiseLike = require('../utils').isPromiseLike;\r\nconst hasAtomicOperators = require('../utils').hasAtomicOperators;\r\nconst maxWireVersion = require('../core/utils').maxWireVersion;\r\n\r\n// Error codes\r\nconst WRITE_CONCERN_ERROR = 64;\r\n\r\n// Insert types\r\nconst INSERT = 1;\r\nconst UPDATE = 2;\r\nconst REMOVE = 3;\r\n\r\nconst bson = new BSON([\r\n  BSON.Binary,\r\n  BSON.Code,\r\n  BSON.DBRef,\r\n  BSON.Decimal128,\r\n  BSON.Double,\r\n  BSON.Int32,\r\n  BSON.Long,\r\n  BSON.Map,\r\n  BSON.MaxKey,\r\n  BSON.MinKey,\r\n  BSON.ObjectId,\r\n  BSON.BSONRegExp,\r\n  BSON.Symbol,\r\n  BSON.Timestamp\r\n]);\r\n\r\n/**\r\n * Keeps the state of a unordered batch so we can rewrite the results\r\n * correctly after command execution\r\n * @ignore\r\n */\r\nclass Batch {\r\n  constructor(batchType, originalZeroIndex) {\r\n    this.originalZeroIndex = originalZeroIndex;\r\n    this.currentIndex = 0;\r\n    this.originalIndexes = [];\r\n    this.batchType = batchType;\r\n    this.operations = [];\r\n    this.size = 0;\r\n    this.sizeBytes = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc\r\n * The result of a bulk write.\r\n */\r\nclass BulkWriteResult {\r\n  /**\r\n   * Create a new BulkWriteResult instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\r\n  constructor(bulkResult) {\r\n    this.result = bulkResult;\r\n  }\r\n\r\n  /**\r\n   * Evaluates to true if the bulk operation correctly executes\r\n   * @type {boolean}\r\n   */\r\n  get ok() {\r\n    return this.result.ok;\r\n  }\r\n\r\n  /**\r\n   * The number of inserted documents\r\n   * @type {number}\r\n   */\r\n  get nInserted() {\r\n    return this.result.nInserted;\r\n  }\r\n\r\n  /**\r\n   * Number of upserted documents\r\n   * @type {number}\r\n   */\r\n  get nUpserted() {\r\n    return this.result.nUpserted;\r\n  }\r\n\r\n  /**\r\n   * Number of matched documents\r\n   * @type {number}\r\n   */\r\n  get nMatched() {\r\n    return this.result.nMatched;\r\n  }\r\n\r\n  /**\r\n   * Number of documents updated physically on disk\r\n   * @type {number}\r\n   */\r\n  get nModified() {\r\n    return this.result.nModified;\r\n  }\r\n\r\n  /**\r\n   * Number of removed documents\r\n   * @type {number}\r\n   */\r\n  get nRemoved() {\r\n    return this.result.nRemoved;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all inserted ids\r\n   *\r\n   * @return {object[]}\r\n   */\r\n  getInsertedIds() {\r\n    return this.result.insertedIds;\r\n  }\r\n\r\n  /**\r\n   * Returns an array of all upserted ids\r\n   *\r\n   * @return {object[]}\r\n   */\r\n  getUpsertedIds() {\r\n    return this.result.upserted;\r\n  }\r\n\r\n  /**\r\n   * Returns the upserted id at the given index\r\n   *\r\n   * @param {number} index the number of the upserted id to return, returns undefined if no result for passed in index\r\n   * @return {object}\r\n   */\r\n  getUpsertedIdAt(index) {\r\n    return this.result.upserted[index];\r\n  }\r\n\r\n  /**\r\n   * Returns raw internal result\r\n   *\r\n   * @return {object}\r\n   */\r\n  getRawResponse() {\r\n    return this.result;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the bulk operation contains a write error\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  hasWriteErrors() {\r\n    return this.result.writeErrors.length > 0;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of write errors off the bulk operation\r\n   *\r\n   * @return {number}\r\n   */\r\n  getWriteErrorCount() {\r\n    return this.result.writeErrors.length;\r\n  }\r\n\r\n  /**\r\n   * Returns a specific write error object\r\n   *\r\n   * @param {number} index of the write error to return, returns null if there is no result for passed in index\r\n   * @return {WriteError}\r\n   */\r\n  getWriteErrorAt(index) {\r\n    if (index < this.result.writeErrors.length) {\r\n      return this.result.writeErrors[index];\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Retrieve all write errors\r\n   *\r\n   * @return {WriteError[]}\r\n   */\r\n  getWriteErrors() {\r\n    return this.result.writeErrors;\r\n  }\r\n\r\n  /**\r\n   * Retrieve lastOp if available\r\n   *\r\n   * @return {object}\r\n   */\r\n  getLastOp() {\r\n    return this.result.lastOp;\r\n  }\r\n\r\n  /**\r\n   * Retrieve the write concern error if any\r\n   *\r\n   * @return {WriteConcernError}\r\n   */\r\n  getWriteConcernError() {\r\n    if (this.result.writeConcernErrors.length === 0) {\r\n      return null;\r\n    } else if (this.result.writeConcernErrors.length === 1) {\r\n      // Return the error\r\n      return this.result.writeConcernErrors[0];\r\n    } else {\r\n      // Combine the errors\r\n      let errmsg = '';\r\n      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {\r\n        const err = this.result.writeConcernErrors[i];\r\n        errmsg = errmsg + err.errmsg;\r\n\r\n        // TODO: Something better\r\n        if (i === 0) errmsg = errmsg + ' and ';\r\n      }\r\n\r\n      return new WriteConcernError({ errmsg: errmsg, code: WRITE_CONCERN_ERROR });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {object}\r\n   */\r\n  toJSON() {\r\n    return this.result;\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return `BulkWriteResult(${this.toJSON(this.result)})`;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean}\r\n   */\r\n  isOk() {\r\n    return this.result.ok === 1;\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc An error representing a failure by the server to apply the requested write concern to the bulk operation.\r\n */\r\nclass WriteConcernError {\r\n  /**\r\n   * Create a new WriteConcernError instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\r\n  constructor(err) {\r\n    this.err = err;\r\n  }\r\n\r\n  /**\r\n   * Write concern error code.\r\n   * @type {number}\r\n   */\r\n  get code() {\r\n    return this.err.code;\r\n  }\r\n\r\n  /**\r\n   * Write concern error message.\r\n   * @type {string}\r\n   */\r\n  get errmsg() {\r\n    return this.err.errmsg;\r\n  }\r\n\r\n  /**\r\n   * @return {object}\r\n   */\r\n  toJSON() {\r\n    return { code: this.err.code, errmsg: this.err.errmsg };\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return `WriteConcernError(${this.err.errmsg})`;\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc An error that occurred during a BulkWrite on the server.\r\n */\r\nclass WriteError {\r\n  /**\r\n   * Create a new WriteError instance\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   */\r\n  constructor(err) {\r\n    this.err = err;\r\n  }\r\n\r\n  /**\r\n   * WriteError code.\r\n   * @type {number}\r\n   */\r\n  get code() {\r\n    return this.err.code;\r\n  }\r\n\r\n  /**\r\n   * WriteError original bulk operation index.\r\n   * @type {number}\r\n   */\r\n  get index() {\r\n    return this.err.index;\r\n  }\r\n\r\n  /**\r\n   * WriteError message.\r\n   * @type {string}\r\n   */\r\n  get errmsg() {\r\n    return this.err.errmsg;\r\n  }\r\n\r\n  /**\r\n   * Returns the underlying operation that caused the error\r\n   * @return {object}\r\n   */\r\n  getOperation() {\r\n    return this.err.op;\r\n  }\r\n\r\n  /**\r\n   * @return {object}\r\n   */\r\n  toJSON() {\r\n    return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    return `WriteError(${JSON.stringify(this.toJSON())})`;\r\n  }\r\n}\r\n\r\n/**\r\n * Merges results into shared data structure\r\n * @ignore\r\n */\r\nfunction mergeBatchResults(batch, bulkResult, err, result) {\r\n  // If we have an error set the result to be the err object\r\n  if (err) {\r\n    result = err;\r\n  } else if (result && result.result) {\r\n    result = result.result;\r\n  } else if (result == null) {\r\n    return;\r\n  }\r\n\r\n  // Do we have a top level error stop processing and return\r\n  if (result.ok === 0 && bulkResult.ok === 1) {\r\n    bulkResult.ok = 0;\r\n\r\n    const writeError = {\r\n      index: 0,\r\n      code: result.code || 0,\r\n      errmsg: result.message,\r\n      op: batch.operations[0]\r\n    };\r\n\r\n    bulkResult.writeErrors.push(new WriteError(writeError));\r\n    return;\r\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\r\n    return;\r\n  }\r\n\r\n  // Deal with opTime if available\r\n  if (result.opTime || result.lastOp) {\r\n    const opTime = result.lastOp || result.opTime;\r\n    let lastOpTS = null;\r\n    let lastOpT = null;\r\n\r\n    // We have a time stamp\r\n    if (opTime && opTime._bsontype === 'Timestamp') {\r\n      if (bulkResult.lastOp == null) {\r\n        bulkResult.lastOp = opTime;\r\n      } else if (opTime.greaterThan(bulkResult.lastOp)) {\r\n        bulkResult.lastOp = opTime;\r\n      }\r\n    } else {\r\n      // Existing TS\r\n      if (bulkResult.lastOp) {\r\n        lastOpTS =\r\n          typeof bulkResult.lastOp.ts === 'number'\r\n            ? Long.fromNumber(bulkResult.lastOp.ts)\r\n            : bulkResult.lastOp.ts;\r\n        lastOpT =\r\n          typeof bulkResult.lastOp.t === 'number'\r\n            ? Long.fromNumber(bulkResult.lastOp.t)\r\n            : bulkResult.lastOp.t;\r\n      }\r\n\r\n      // Current OpTime TS\r\n      const opTimeTS = typeof opTime.ts === 'number' ? Long.fromNumber(opTime.ts) : opTime.ts;\r\n      const opTimeT = typeof opTime.t === 'number' ? Long.fromNumber(opTime.t) : opTime.t;\r\n\r\n      // Compare the opTime's\r\n      if (bulkResult.lastOp == null) {\r\n        bulkResult.lastOp = opTime;\r\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\r\n        bulkResult.lastOp = opTime;\r\n      } else if (opTimeTS.equals(lastOpTS)) {\r\n        if (opTimeT.greaterThan(lastOpT)) {\r\n          bulkResult.lastOp = opTime;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we have an insert Batch type\r\n  if (batch.batchType === INSERT && result.n) {\r\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\r\n  }\r\n\r\n  // If we have an insert Batch type\r\n  if (batch.batchType === REMOVE && result.n) {\r\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\r\n  }\r\n\r\n  let nUpserted = 0;\r\n\r\n  // We have an array of upserted values, we need to rewrite the indexes\r\n  if (Array.isArray(result.upserted)) {\r\n    nUpserted = result.upserted.length;\r\n\r\n    for (let i = 0; i < result.upserted.length; i++) {\r\n      bulkResult.upserted.push({\r\n        index: result.upserted[i].index + batch.originalZeroIndex,\r\n        _id: result.upserted[i]._id\r\n      });\r\n    }\r\n  } else if (result.upserted) {\r\n    nUpserted = 1;\r\n\r\n    bulkResult.upserted.push({\r\n      index: batch.originalZeroIndex,\r\n      _id: result.upserted\r\n    });\r\n  }\r\n\r\n  // If we have an update Batch type\r\n  if (batch.batchType === UPDATE && result.n) {\r\n    const nModified = result.nModified;\r\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\r\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\r\n\r\n    if (typeof nModified === 'number') {\r\n      bulkResult.nModified = bulkResult.nModified + nModified;\r\n    } else {\r\n      bulkResult.nModified = null;\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(result.writeErrors)) {\r\n    for (let i = 0; i < result.writeErrors.length; i++) {\r\n      const writeError = {\r\n        index: batch.originalIndexes[result.writeErrors[i].index],\r\n        code: result.writeErrors[i].code,\r\n        errmsg: result.writeErrors[i].errmsg,\r\n        op: batch.operations[result.writeErrors[i].index]\r\n      };\r\n\r\n      bulkResult.writeErrors.push(new WriteError(writeError));\r\n    }\r\n  }\r\n\r\n  if (result.writeConcernError) {\r\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\r\n  }\r\n}\r\n\r\nfunction executeCommands(bulkOperation, options, callback) {\r\n  if (bulkOperation.s.batches.length === 0) {\r\n    return handleCallback(callback, null, new BulkWriteResult(bulkOperation.s.bulkResult));\r\n  }\r\n\r\n  const batch = bulkOperation.s.batches.shift();\r\n\r\n  function resultHandler(err, result) {\r\n    // Error is a driver related error not a bulk op error, terminate\r\n    if (((err && err.driver) || (err && err.message)) && !(err instanceof MongoWriteConcernError)) {\r\n      return handleCallback(callback, err);\r\n    }\r\n\r\n    // If we have and error\r\n    if (err) err.ok = 0;\r\n    if (err instanceof MongoWriteConcernError) {\r\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\r\n    }\r\n\r\n    // Merge the results together\r\n    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\r\n    const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\r\n    if (mergeResult != null) {\r\n      return handleCallback(callback, null, writeResult);\r\n    }\r\n\r\n    if (bulkOperation.handleWriteError(callback, writeResult)) return;\r\n\r\n    // Execute the next command in line\r\n    executeCommands(bulkOperation, options, callback);\r\n  }\r\n\r\n  bulkOperation.finalOptionsHandler({ options, batch, resultHandler }, callback);\r\n}\r\n\r\n/**\r\n * handles write concern error\r\n *\r\n * @ignore\r\n * @param {object} batch\r\n * @param {object} bulkResult\r\n * @param {boolean} ordered\r\n * @param {WriteConcernError} err\r\n * @param {function} callback\r\n */\r\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\r\n  mergeBatchResults(batch, bulkResult, null, err.result);\r\n\r\n  const wrappedWriteConcernError = new WriteConcernError({\r\n    errmsg: err.result.writeConcernError.errmsg,\r\n    code: err.result.writeConcernError.result\r\n  });\r\n  return handleCallback(\r\n    callback,\r\n    new BulkWriteError(toError(wrappedWriteConcernError), new BulkWriteResult(bulkResult)),\r\n    null\r\n  );\r\n}\r\n\r\n/**\r\n * @classdesc An error indicating an unsuccessful Bulk Write\r\n */\r\nclass BulkWriteError extends MongoError {\r\n  /**\r\n   * Creates a new BulkWriteError\r\n   *\r\n   * @param {Error|string|object} message The error message\r\n   * @param {BulkWriteResult} result The result of the bulk write operation\r\n   * @extends {MongoError}\r\n   */\r\n  constructor(error, result) {\r\n    const message = error.err || error.errmsg || error.errMessage || error;\r\n    super(message);\r\n\r\n    Object.assign(this, error);\r\n\r\n    this.name = 'BulkWriteError';\r\n    this.result = result;\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc A builder object that is returned from {@link BulkOperationBase#find}.\r\n * Is used to build a write operation that involves a query filter.\r\n */\r\nclass FindOperators {\r\n  /**\r\n   * Creates a new FindOperators object.\r\n   *\r\n   * **NOTE:** Internal Type, do not instantiate directly\r\n   * @param {OrderedBulkOperation|UnorderedBulkOperation} bulkOperation\r\n   */\r\n  constructor(bulkOperation) {\r\n    this.s = bulkOperation.s;\r\n  }\r\n\r\n  /**\r\n   * Add a multiple update operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\r\n  update(updateDocument) {\r\n    // Perform upsert\r\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;\r\n\r\n    // Establish the update command\r\n    const document = {\r\n      q: this.s.currentOp.selector,\r\n      u: updateDocument,\r\n      multi: true,\r\n      upsert: upsert\r\n    };\r\n\r\n    if (updateDocument.hint) {\r\n      document.hint = updateDocument.hint;\r\n    }\r\n\r\n    // Clear out current Op\r\n    this.s.currentOp = null;\r\n    return this.s.options.addToOperationsList(this, UPDATE, document);\r\n  }\r\n\r\n  /**\r\n   * Add a single update operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} updateDocument An update field for an update operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-u u documentation}\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\r\n  updateOne(updateDocument) {\r\n    // Perform upsert\r\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;\r\n\r\n    // Establish the update command\r\n    const document = {\r\n      q: this.s.currentOp.selector,\r\n      u: updateDocument,\r\n      multi: false,\r\n      upsert: upsert\r\n    };\r\n\r\n    if (updateDocument.hint) {\r\n      document.hint = updateDocument.hint;\r\n    }\r\n\r\n    if (!hasAtomicOperators(updateDocument)) {\r\n      throw new TypeError('Update document requires atomic operators');\r\n    }\r\n\r\n    // Clear out current Op\r\n    this.s.currentOp = null;\r\n    return this.s.options.addToOperationsList(this, UPDATE, document);\r\n  }\r\n\r\n  /**\r\n   * Add a replace one operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @param {object} replacement the new document to replace the existing one with\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\r\n  replaceOne(replacement) {\r\n    // Perform upsert\r\n    const upsert = typeof this.s.currentOp.upsert === 'boolean' ? this.s.currentOp.upsert : false;\r\n\r\n    // Establish the update command\r\n    const document = {\r\n      q: this.s.currentOp.selector,\r\n      u: replacement,\r\n      multi: false,\r\n      upsert: upsert\r\n    };\r\n\r\n    if (replacement.hint) {\r\n      document.hint = replacement.hint;\r\n    }\r\n\r\n    if (hasAtomicOperators(replacement)) {\r\n      throw new TypeError('Replacement document must not use atomic operators');\r\n    }\r\n\r\n    // Clear out current Op\r\n    this.s.currentOp = null;\r\n    return this.s.options.addToOperationsList(this, UPDATE, document);\r\n  }\r\n\r\n  /**\r\n   * Upsert modifier for update bulk operation, noting that this operation is an upsert.\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {FindOperators} reference to self\r\n   */\r\n  upsert() {\r\n    this.s.currentOp.upsert = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Add a delete one operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\r\n  deleteOne() {\r\n    // Establish the update command\r\n    const document = {\r\n      q: this.s.currentOp.selector,\r\n      limit: 1\r\n    };\r\n\r\n    // Clear out current Op\r\n    this.s.currentOp = null;\r\n    return this.s.options.addToOperationsList(this, REMOVE, document);\r\n  }\r\n\r\n  /**\r\n   * Add a delete many operation to the bulk operation\r\n   *\r\n   * @method\r\n   * @throws {MongoError} If operation cannot be added to bulk write\r\n   * @return {OrderedBulkOperation|UnorderedBulkOperation} A reference to the parent BulkOperation\r\n   */\r\n  delete() {\r\n    // Establish the update command\r\n    const document = {\r\n      q: this.s.currentOp.selector,\r\n      limit: 0\r\n    };\r\n\r\n    // Clear out current Op\r\n    this.s.currentOp = null;\r\n    return this.s.options.addToOperationsList(this, REMOVE, document);\r\n  }\r\n\r\n  /**\r\n   * backwards compatability for deleteOne\r\n   */\r\n  removeOne() {\r\n    return this.deleteOne();\r\n  }\r\n\r\n  /**\r\n   * backwards compatability for delete\r\n   */\r\n  remove() {\r\n    return this.delete();\r\n  }\r\n}\r\n\r\n/**\r\n * @classdesc Parent class to OrderedBulkOperation and UnorderedBulkOperation\r\n *\r\n * **NOTE:** Internal Type, do not instantiate directly\r\n */\r\nclass BulkOperationBase {\r\n  /**\r\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\r\n   * @property {number} length Get the number of operations in the bulk.\r\n   */\r\n  constructor(topology, collection, options, isOrdered) {\r\n    // determine whether bulkOperation is ordered or unordered\r\n    this.isOrdered = isOrdered;\r\n\r\n    options = options == null ? {} : options;\r\n    // TODO Bring from driver information in isMaster\r\n    // Get the namespace for the write operations\r\n    const namespace = collection.s.namespace;\r\n    // Used to mark operation as executed\r\n    const executed = false;\r\n\r\n    // Current item\r\n    const currentOp = null;\r\n\r\n    // Handle to the bson serializer, used to calculate running sizes\r\n    const bson = topology.bson;\r\n    // Set max byte size\r\n    const isMaster = topology.lastIsMaster();\r\n\r\n    // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\r\n    // over 2mb are still allowed\r\n    const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\r\n    const maxBsonObjectSize =\r\n      isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\r\n    const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\r\n    const maxWriteBatchSize =\r\n      isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000;\r\n\r\n    // Calculates the largest possible size of an Array key, represented as a BSON string\r\n    // element. This calculation:\r\n    //     1 byte for BSON type\r\n    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\r\n    //   + 1 bytes for null terminator\r\n    const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;\r\n\r\n    // Final options for retryable writes and write concern\r\n    let finalOptions = Object.assign({}, options);\r\n    finalOptions = applyRetryableWrites(finalOptions, collection.s.db);\r\n    finalOptions = applyWriteConcern(finalOptions, { collection: collection }, options);\r\n    const writeConcern = finalOptions.writeConcern;\r\n\r\n    // Get the promiseLibrary\r\n    const promiseLibrary = options.promiseLibrary || Promise;\r\n\r\n    // Final results\r\n    const bulkResult = {\r\n      ok: 1,\r\n      writeErrors: [],\r\n      writeConcernErrors: [],\r\n      insertedIds: [],\r\n      nInserted: 0,\r\n      nUpserted: 0,\r\n      nMatched: 0,\r\n      nModified: 0,\r\n      nRemoved: 0,\r\n      upserted: []\r\n    };\r\n\r\n    // Internal state\r\n    this.s = {\r\n      // Final result\r\n      bulkResult: bulkResult,\r\n      // Current batch state\r\n      currentBatch: null,\r\n      currentIndex: 0,\r\n      // ordered specific\r\n      currentBatchSize: 0,\r\n      currentBatchSizeBytes: 0,\r\n      // unordered specific\r\n      currentInsertBatch: null,\r\n      currentUpdateBatch: null,\r\n      currentRemoveBatch: null,\r\n      batches: [],\r\n      // Write concern\r\n      writeConcern: writeConcern,\r\n      // Max batch size options\r\n      maxBsonObjectSize,\r\n      maxBatchSizeBytes,\r\n      maxWriteBatchSize,\r\n      maxKeySize,\r\n      // Namespace\r\n      namespace: namespace,\r\n      // BSON\r\n      bson: bson,\r\n      // Topology\r\n      topology: topology,\r\n      // Options\r\n      options: finalOptions,\r\n      // Current operation\r\n      currentOp: currentOp,\r\n      // Executed\r\n      executed: executed,\r\n      // Collection\r\n      collection: collection,\r\n      // Promise Library\r\n      promiseLibrary: promiseLibrary,\r\n      // Fundamental error\r\n      err: null,\r\n      // check keys\r\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : true\r\n    };\r\n\r\n    // bypass Validation\r\n    if (options.bypassDocumentValidation === true) {\r\n      this.s.bypassDocumentValidation = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a single insert document to the bulk operation\r\n   *\r\n   * @param {object} document the document to insert\r\n   * @throws {MongoError}\r\n   * @return {BulkOperationBase} A reference to self\r\n   *\r\n   * @example\r\n   * const bulkOp = collection.initializeOrderedBulkOp();\r\n   * // Adds three inserts to the bulkOp.\r\n   * bulkOp\r\n   *   .insert({ a: 1 })\r\n   *   .insert({ b: 2 })\r\n   *   .insert({ c: 3 });\r\n   * await bulkOp.execute();\r\n   */\r\n  insert(document) {\r\n    if (this.s.collection.s.db.options.forceServerObjectId !== true && document._id == null)\r\n      document._id = new ObjectID();\r\n    return this.s.options.addToOperationsList(this, INSERT, document);\r\n  }\r\n\r\n  /**\r\n   * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\r\n   * Returns a builder object used to complete the definition of the operation.\r\n   *\r\n   * @method\r\n   * @param {object} selector The selector for the bulk operation. See {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-q q documentation}\r\n   * @throws {MongoError} if a selector is not specified\r\n   * @return {FindOperators} A helper object with which the write operation can be defined.\r\n   *\r\n   * @example\r\n   * const bulkOp = collection.initializeOrderedBulkOp();\r\n   *\r\n   * // Add an updateOne to the bulkOp\r\n   * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\r\n   *\r\n   * // Add an updateMany to the bulkOp\r\n   * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\r\n   *\r\n   * // Add an upsert\r\n   * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\r\n   *\r\n   * // Add a deletion\r\n   * bulkOp.find({ g: 7 }).deleteOne();\r\n   *\r\n   * // Add a multi deletion\r\n   * bulkOp.find({ h: 8 }).delete();\r\n   *\r\n   * // Add a replaceOne\r\n   * bulkOp.find({ i: 9 }).replaceOne({ j: 10 });\r\n   *\r\n   * // Update using a pipeline (requires Mongodb 4.2 or higher)\r\n   * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\r\n   *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\r\n   * ]);\r\n   *\r\n   * // All of the ops will now be executed\r\n   * await bulkOp.execute();\r\n   */\r\n  find(selector) {\r\n    if (!selector) {\r\n      throw toError('Bulk find operation must specify a selector');\r\n    }\r\n\r\n    // Save a current selector\r\n    this.s.currentOp = {\r\n      selector: selector\r\n    };\r\n\r\n    return new FindOperators(this);\r\n  }\r\n\r\n  /**\r\n   * Specifies a raw operation to perform in the bulk write.\r\n   *\r\n   * @method\r\n   * @param {object} op The raw operation to perform.\r\n   * @param {object} [options.hint] An optional hint for query optimization. See the {@link https://docs.mongodb.com/manual/reference/command/update/#update-command-hint|update command} reference for more information.\r\n   * @return {BulkOperationBase} A reference to self\r\n   */\r\n  raw(op) {\r\n    const key = Object.keys(op)[0];\r\n\r\n    // Set up the force server object id\r\n    const forceServerObjectId =\r\n      typeof this.s.options.forceServerObjectId === 'boolean'\r\n        ? this.s.options.forceServerObjectId\r\n        : this.s.collection.s.db.options.forceServerObjectId;\r\n\r\n    // Update operations\r\n    if (\r\n      (op.updateOne && op.updateOne.q) ||\r\n      (op.updateMany && op.updateMany.q) ||\r\n      (op.replaceOne && op.replaceOne.q)\r\n    ) {\r\n      op[key].multi = op.updateOne || op.replaceOne ? false : true;\r\n      return this.s.options.addToOperationsList(this, UPDATE, op[key]);\r\n    }\r\n\r\n    // Crud spec update format\r\n    if (op.updateOne || op.updateMany || op.replaceOne) {\r\n      if (op.replaceOne && hasAtomicOperators(op[key].replacement)) {\r\n        throw new TypeError('Replacement document must not use atomic operators');\r\n      } else if ((op.updateOne || op.updateMany) && !hasAtomicOperators(op[key].update)) {\r\n        throw new TypeError('Update document requires atomic operators');\r\n      }\r\n\r\n      const multi = op.updateOne || op.replaceOne ? false : true;\r\n      const operation = {\r\n        q: op[key].filter,\r\n        u: op[key].update || op[key].replacement,\r\n        multi: multi\r\n      };\r\n\r\n      if (op[key].hint) {\r\n        operation.hint = op[key].hint;\r\n      }\r\n\r\n      if (this.isOrdered) {\r\n        operation.upsert = op[key].upsert ? true : false;\r\n        if (op.collation) operation.collation = op.collation;\r\n      } else {\r\n        if (op[key].upsert) operation.upsert = true;\r\n      }\r\n      if (op[key].arrayFilters) {\r\n        // TODO: this check should be done at command construction against a connection, not a topology\r\n        if (maxWireVersion(this.s.topology) < 6) {\r\n          throw new TypeError('arrayFilters are only supported on MongoDB 3.6+');\r\n        }\r\n\r\n        operation.arrayFilters = op[key].arrayFilters;\r\n      }\r\n\r\n      return this.s.options.addToOperationsList(this, UPDATE, operation);\r\n    }\r\n\r\n    // Remove operations\r\n    if (\r\n      op.removeOne ||\r\n      op.removeMany ||\r\n      (op.deleteOne && op.deleteOne.q) ||\r\n      (op.deleteMany && op.deleteMany.q)\r\n    ) {\r\n      op[key].limit = op.removeOne ? 1 : 0;\r\n      return this.s.options.addToOperationsList(this, REMOVE, op[key]);\r\n    }\r\n\r\n    // Crud spec delete operations, less efficient\r\n    if (op.deleteOne || op.deleteMany) {\r\n      const limit = op.deleteOne ? 1 : 0;\r\n      const operation = { q: op[key].filter, limit: limit };\r\n      if (op[key].hint) {\r\n        operation.hint = op[key].hint;\r\n      }\r\n      if (this.isOrdered) {\r\n        if (op.collation) operation.collation = op.collation;\r\n      }\r\n      return this.s.options.addToOperationsList(this, REMOVE, operation);\r\n    }\r\n\r\n    // Insert operations\r\n    if (op.insertOne && op.insertOne.document == null) {\r\n      if (forceServerObjectId !== true && op.insertOne._id == null)\r\n        op.insertOne._id = new ObjectID();\r\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne);\r\n    } else if (op.insertOne && op.insertOne.document) {\r\n      if (forceServerObjectId !== true && op.insertOne.document._id == null)\r\n        op.insertOne.document._id = new ObjectID();\r\n      return this.s.options.addToOperationsList(this, INSERT, op.insertOne.document);\r\n    }\r\n\r\n    if (op.insertMany) {\r\n      for (let i = 0; i < op.insertMany.length; i++) {\r\n        if (forceServerObjectId !== true && op.insertMany[i]._id == null)\r\n          op.insertMany[i]._id = new ObjectID();\r\n        this.s.options.addToOperationsList(this, INSERT, op.insertMany[i]);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    // No valid type of operation\r\n    throw toError(\r\n      'bulkWrite only supports insertOne, insertMany, updateOne, updateMany, removeOne, removeMany, deleteOne, deleteMany'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * helper function to assist with promiseOrCallback behavior\r\n   * @ignore\r\n   * @param {*} err\r\n   * @param {*} callback\r\n   */\r\n  _handleEarlyError(err, callback) {\r\n    if (typeof callback === 'function') {\r\n      callback(err, null);\r\n      return;\r\n    }\r\n\r\n    return this.s.promiseLibrary.reject(err);\r\n  }\r\n\r\n  /**\r\n   * An internal helper method. Do not invoke directly. Will be going away in the future\r\n   *\r\n   * @ignore\r\n   * @method\r\n   * @param {class} bulk either OrderedBulkOperation or UnorderdBulkOperation\r\n   * @param {object} writeConcern\r\n   * @param {object} options\r\n   * @param {function} callback\r\n   */\r\n  bulkExecute(_writeConcern, options, callback) {\r\n    if (typeof options === 'function') (callback = options), (options = {});\r\n    options = options || {};\r\n\r\n    if (typeof _writeConcern === 'function') {\r\n      callback = _writeConcern;\r\n    } else if (_writeConcern && typeof _writeConcern === 'object') {\r\n      this.s.writeConcern = _writeConcern;\r\n    }\r\n\r\n    if (this.s.executed) {\r\n      const executedError = toError('batch cannot be re-executed');\r\n      return this._handleEarlyError(executedError, callback);\r\n    }\r\n\r\n    // If we have current batch\r\n    if (this.isOrdered) {\r\n      if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\r\n    } else {\r\n      if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\r\n      if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\r\n      if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\r\n    }\r\n    // If we have no operations in the bulk raise an error\r\n    if (this.s.batches.length === 0) {\r\n      const emptyBatchError = toError('Invalid Operation, no operations specified');\r\n      return this._handleEarlyError(emptyBatchError, callback);\r\n    }\r\n    return { options, callback };\r\n  }\r\n\r\n  /**\r\n   * The callback format for results\r\n   * @callback BulkOperationBase~resultCallback\r\n   * @param {MongoError} error An error instance representing the error during the execution.\r\n   * @param {BulkWriteResult} result The bulk write result.\r\n   */\r\n\r\n  /**\r\n   * Execute the bulk operation\r\n   *\r\n   * @method\r\n   * @param {WriteConcern} [_writeConcern] Optional write concern. Can also be specified through options.\r\n   * @param {object} [options] Optional settings.\r\n   * @param {(number|string)} [options.w] **Deprecated** The write concern. Use writeConcern instead.\r\n   * @param {number} [options.wtimeout] **Deprecated** The write concern timeout. Use writeConcern instead.\r\n   * @param {boolean} [options.j=false] **Deprecated** Specify a journal write concern. Use writeConcern instead.\r\n   * @param {boolean} [options.fsync=false] **Deprecated** Specify a file sync write concern. Use writeConcern instead.\r\n   * @param {object|WriteConcern} [options.writeConcern] Specify write concern settings.\r\n   * @param {BulkOperationBase~resultCallback} [callback] A callback that will be invoked when bulkWrite finishes/errors\r\n   * @throws {MongoError} Throws error if the bulk object has already been executed\r\n   * @throws {MongoError} Throws error if the bulk object does not have any operations\r\n   * @return {Promise|void} returns Promise if no callback passed\r\n   */\r\n  execute(_writeConcern, options, callback) {\r\n    const ret = this.bulkExecute(_writeConcern, options, callback);\r\n    if (!ret || isPromiseLike(ret)) {\r\n      return ret;\r\n    }\r\n\r\n    options = ret.options;\r\n    callback = ret.callback;\r\n\r\n    return executeLegacyOperation(this.s.topology, executeCommands, [this, options, callback]);\r\n  }\r\n\r\n  /**\r\n   * Handles final options before executing command\r\n   *\r\n   * An internal method. Do not invoke. Will not be accessible in the future\r\n   *\r\n   * @ignore\r\n   * @param {object} config\r\n   * @param {object} config.options\r\n   * @param {number} config.batch\r\n   * @param {function} config.resultHandler\r\n   * @param {function} callback\r\n   */\r\n  finalOptionsHandler(config, callback) {\r\n    const finalOptions = Object.assign({ ordered: this.isOrdered }, config.options);\r\n    if (this.s.writeConcern != null) {\r\n      finalOptions.writeConcern = this.s.writeConcern;\r\n    }\r\n\r\n    if (finalOptions.bypassDocumentValidation !== true) {\r\n      delete finalOptions.bypassDocumentValidation;\r\n    }\r\n\r\n    // Set an operationIf if provided\r\n    if (this.operationId) {\r\n      config.resultHandler.operationId = this.operationId;\r\n    }\r\n\r\n    // Serialize functions\r\n    if (this.s.options.serializeFunctions) {\r\n      finalOptions.serializeFunctions = true;\r\n    }\r\n\r\n    // Ignore undefined\r\n    if (this.s.options.ignoreUndefined) {\r\n      finalOptions.ignoreUndefined = true;\r\n    }\r\n\r\n    // Is the bypassDocumentValidation options specific\r\n    if (this.s.bypassDocumentValidation === true) {\r\n      finalOptions.bypassDocumentValidation = true;\r\n    }\r\n\r\n    // Is the checkKeys option disabled\r\n    if (this.s.checkKeys === false) {\r\n      finalOptions.checkKeys = false;\r\n    }\r\n\r\n    if (finalOptions.retryWrites) {\r\n      if (config.batch.batchType === UPDATE) {\r\n        finalOptions.retryWrites =\r\n          finalOptions.retryWrites && !config.batch.operations.some(op => op.multi);\r\n      }\r\n\r\n      if (config.batch.batchType === REMOVE) {\r\n        finalOptions.retryWrites =\r\n          finalOptions.retryWrites && !config.batch.operations.some(op => op.limit === 0);\r\n      }\r\n    }\r\n\r\n    try {\r\n      if (config.batch.batchType === INSERT) {\r\n        this.s.topology.insert(\r\n          this.s.namespace,\r\n          config.batch.operations,\r\n          finalOptions,\r\n          config.resultHandler\r\n        );\r\n      } else if (config.batch.batchType === UPDATE) {\r\n        this.s.topology.update(\r\n          this.s.namespace,\r\n          config.batch.operations,\r\n          finalOptions,\r\n          config.resultHandler\r\n        );\r\n      } else if (config.batch.batchType === REMOVE) {\r\n        this.s.topology.remove(\r\n          this.s.namespace,\r\n          config.batch.operations,\r\n          finalOptions,\r\n          config.resultHandler\r\n        );\r\n      }\r\n    } catch (err) {\r\n      // Force top level error\r\n      err.ok = 0;\r\n      // Merge top level error and return\r\n      handleCallback(callback, null, mergeBatchResults(config.batch, this.s.bulkResult, err, null));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handles the write error before executing commands\r\n   *\r\n   * An internal helper method. Do not invoke directly. Will be going away in the future\r\n   *\r\n   * @ignore\r\n   * @param {function} callback\r\n   * @param {BulkWriteResult} writeResult\r\n   * @param {class} self either OrderedBulkOperation or UnorderedBulkOperation\r\n   */\r\n  handleWriteError(callback, writeResult) {\r\n    if (this.s.bulkResult.writeErrors.length > 0) {\r\n      const msg = this.s.bulkResult.writeErrors[0].errmsg\r\n        ? this.s.bulkResult.writeErrors[0].errmsg\r\n        : 'write operation failed';\r\n\r\n      handleCallback(\r\n        callback,\r\n        new BulkWriteError(\r\n          toError({\r\n            message: msg,\r\n            code: this.s.bulkResult.writeErrors[0].code,\r\n            writeErrors: this.s.bulkResult.writeErrors\r\n          }),\r\n          writeResult\r\n        ),\r\n        null\r\n      );\r\n      return true;\r\n    }\r\n\r\n    if (writeResult.getWriteConcernError()) {\r\n      handleCallback(\r\n        callback,\r\n        new BulkWriteError(toError(writeResult.getWriteConcernError()), writeResult),\r\n        null\r\n      );\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\r\n  enumerable: true,\r\n  get: function() {\r\n    return this.s.currentIndex;\r\n  }\r\n});\r\n\r\n// Exports symbols\r\nmodule.exports = {\r\n  Batch,\r\n  BulkOperationBase,\r\n  bson,\r\n  INSERT: INSERT,\r\n  UPDATE: UPDATE,\r\n  REMOVE: REMOVE,\r\n  BulkWriteError\r\n};\r\n"]},"metadata":{},"sourceType":"script"}